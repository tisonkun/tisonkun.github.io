<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>开源社群需要什么代码贡献？</title>
    <url>/2022/04/10/code-contributions/</url>
    <content><![CDATA[<p>几天前 <a href="https://github.com/Xuanwo">@Xuanwo</a> 的一篇文章<a href="https://xuanwo.io/reports/2022-13/">《开源运营当论迹不论心》</a>讨论了 <a href="https://web.archive.org/web/20220403062947/https://mp.weixin.qq.com/s/mssWF5AoUG-vt-b5_QMtRA">TDengine 代码灭虫计划</a>活动中不尊重开源协同的规律，只是通过市场运营手段强行把开发者推进来的误区。</p>
<p>本文从这个例子出发，进一步举例讨论开源社群需要什么样的代码贡献。</p>
<span id="more"></span>

<h2 id="代码贡献应该拒绝形式主义"><a href="#代码贡献应该拒绝形式主义" class="headerlink" title="代码贡献应该拒绝形式主义"></a>代码贡献应该拒绝形式主义</h2><p>TDengine 这一活动最大的问题，在于它违反了软件开发的常识。</p>
<ol>
<li>可以通过 linter 彻底解决的问题，反而“养寇自重”以不断在主分支产生风格问题以“等待解决”。</li>
<li>可以随手解决的问题，例如 fix typo 等，反而专门建立 issue 甚至做成活动找“外部”成员来做。</li>
</ol>
<p>我在不同场合都坚持这样一个观点，开源协同的目的是生产高质量的软件。源代码开放带来的软件自由不提，我们运营一个开发者社群，是为了共同创造出解决实际问题的软件，跨越不同公司、组织和国籍的边界，在整个行业的范围内协同开发者做好一个软件。</p>
<p>TDengine 的做法反其道而行之，目的很明显都指向 issue 数量和 contributor 的数量，而不是一个更好的软件。开源软件不会因为参与的人变多就自动变好，为了追求数量刷出来的 issue 甚至降低了开发效率。</p>
<p><a href="https://book.douban.com/subject/26976995/">《社区运营的艺术》</a>反复提到，必须时刻防范形式主义。形式主义不仅让社群运转变得低效，并且会让关注问题解决，努力参与其中的成员感到挫败，因为他们不能以最优的解决方案处理问题，或者眼看着社群无意义的消耗却无能为力。</p>
<p>同样是处理 Linter 的问题，TiDB 的做法就正常得多。</p>
<p><a href="https://github.com/pingcap/tidb/issues/22979">Make some linters really happy</a> 这个 issue 首先引入了 golangci-lint 工具，然后由于工作量较大，分拆成不同的子任务欢迎其他参与者共同完成。</p>
<p>不过，TiDB 也有过形式主义的问题。为了显得“开放”，没有协调开发工作流，而是一次性地发布每个季度的工作计划，随后置之不理。这样的操作是没有意义的。</p>
<p>例如 <a href="https://github.com/pingcap/tidb/issues/14609">Call For Participation: SIG-Planner 2020&#x2F;Q1 Plan</a> 这个两年前的 issue 至今仍然没有解决，且不知道其中的子问题解了没解。</p>
<p>TiDB 2.4k 个 open issue 当中，有相当部分是各种“开放”运动创建的，事后就成了孤儿。这样试图激活代码贡献的手段，一而再再而三的烂尾，最终消磨了所有参与者的耐心。</p>
<h2 id="代码贡献应该源自实际需求"><a href="#代码贡献应该源自实际需求" class="headerlink" title="代码贡献应该源自实际需求"></a>代码贡献应该源自实际需求</h2><p>软件总是被它的使用者定义的。闭门造车做的功能和优化很容易脱离实际，飘在天上。开发开源软件，讲清楚软件是怎么用的是很重要的。因为软件本身就是为了解决问题，优化和功能如果不能更好的解决问题，或者甚至不知道问题是什么，那就变成空中楼阁，华而不实了。代码贡献除了避免形式主义，还应该源自实际需求。</p>
<p>比如，Apache BookKeeper 提案并实现了基于 etcd 的元数据管理，是因为 etcd 真的被广泛使用了，并且在云端部署环境下，很有可能有一个现成的 etcd 服务。集成 etcd 能够服务这类用户的场景，并且可能减少额外部署一套 ZooKeeper 集群的开销。</p>
<p>比如，Apache ZooKeeper 讨论过 Watches 不能够看到所有事件，而是单次触发的语义是否需要改进。Ted Dunning 给了一个非常经典的回应。</p>
<blockquote>
<p><a href="https://lists.apache.org/thread/fz9bkndvbntfjwxm952clh9vky3nwyd5">If you want to see all events, use Kafka.</a></p>
</blockquote>
<p>这个回应也得到了项目作者 Patrick Hunt 的认可。每个软件都有自己的定位，解决它所要解决的问题。用户永远不可能在一个软件当中解决所有问题，适当的组合不同的软件形成解决方案，是应用工程师的本职。对于开源社群来说，这也意味着它总是不能期待解决所有问题，而应该创造出可组合的基础构建块，并积极地和其他社群联合。如果你想解决所有的问题，那么结果往往是每个问题都解决得不好。</p>
<p>对于新功能的需求，通常首先应该讨论背景和动机，也就是谁为什么需要这样的能力，并且最好有实际的用户，比如提议人自己。我参与设计实现的 <a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-85+Flink+Application+Mode">FLIP-85 Flink Application Mode</a> 就立足于当时几家公司内部 Flink 作业部署运维的实际需求，功能实现之后，马上就可以测试投产。</p>
<p>对于缺陷修复，首先应该复现问题，确认问题有效之后定位问题再进行修复。如果问题无效，也就不需要提交代码修复了。例如无法复现、设计就是如此或使用方式有误，只需要分别回应 issue 后关闭。如果是有效而严重的问题，一般会由核心成员直接上手解决。例如 <a href="https://en.wikipedia.org/wiki/Log4Shell">Log4Shell</a> 和 <a href="https://www.microsoft.com/security/blog/2022/04/04/springshell-rce-vulnerability-guidance-for-protecting-against-and-detecting-cve-2022-22965/">SpringShell</a> 这样的情况，是不可能公开发布等待新的开发者出现并解决的。</p>
<p>即使是不严重的问题，一般来说相应模块的处理人也可以自己解决。对于不算困难的问题，如果社群活跃成员较多，且有新成员需要锻炼，可以推送到对应群体邀请解决。当然，由于是实际的缺陷修复问题，不会阻塞等待其他人，一旦自己有时间，或者发布日期将近，也就自己做掉了。如果其他人尝试解决但是不能如期完成，也应该友善说明并接手。</p>
<p>如果确认的软件缺陷没人主动解决，并且没有同类问题持续出现，那么说明这个问题可能不是一个真实存在问题。SkyWalking 的创始人吴晟在 Twitter 上提到“我们在 SkyWalking 信奉，没有人贡献的特性等于没用的特性”。同样，没有人修复的问题很可能就是不需要修复的问题。</p>
<p>对于重构，首先要问的是必要性。代码总是有不止一种方法写成，同义转换对于软件核心价值的开发没有直接意义。</p>
<p>一种有意义的重构是模块专家主导的重构。实际上，任何一个开发者在开发一个软件的时候，心里都会有一个认识模型。不同人的认识模型是不一样的。对于一个多人参与开发的软件来说，一个人读到另一块代码怎么看怎么不舒服，以至于不能很好的开发新功能或者修复缺陷的情况是很常见的。这也是软件开发人员交接之后，往往后继者会先把原来的代码进行一次重构的原因。只有符合核心开发者的认识模型，软件开发效率才能提升。反过来说，如果提交重构的补丁作者并没有深入参与该模块开发的需要，那么他的重构理由就很难独立成立，因为真正在开发这块代码的人很可能不喜欢这样的重构。这其实也是开源社群 Earn Authority by Contribution 的一个佐证。</p>
<p>另外一种有意义的重构是解决实际问题的重构。例如我在 TiDB 当中发起的 <a href="https://github.com/pingcap/tidb/issues/26022">Tracking issue for restructure tests</a> 测试框架重构的主要出发点，就是目前的<a href="https://internals.tidb.io/t/topic/141">测试框架无法与 GoLand 集成</a>，本地运行测试代价太大，导致开发者倾向于不写测试或者只写简单的测试，而缺乏测试覆盖率的软件，很难有信心合并代码变更，因为谁也说不准只是编译通过的补丁会不会引入额外的问题。</p>
<p>开源软件的开发过程当中，从一个框架迁移到另一个框架，往往能够产生大量的工作。例如 TiDB 的执行引擎换到基于 Chunk 的执行框架，就产生了数十名新的参与者。</p>
<ul>
<li><a href="https://pingcap.com/zh/blog/10mins-become-contributor-of-tidb-20190916">十分钟成为 Contributor 系列 | 助力 TiDB 表达式计算性能提升 10 倍</a></li>
<li><a href="https://pingcap.com/zh/blog/10mins-become-tidb-contributor-20190930">十分钟成为 Contributor 系列 | TiDB 向量化表达式活动第二弹</a></li>
</ul>
<p>同样的，测试框架从 pingcap&#x2F;check 迁移到 testify 也产生了数十名新的开发者。其中有的人从这里切入到 TiDB 社群，为 TiDB 站台；有的人重新回到了 TiDB 社群，再度找到自己的兴趣点。</p>
<p>确实，这样的活动未必能够有很好的“留存率”。但是开发者社群为什么要追求留存率呢？我在参与多个开源软件开发的过程当中总结到的是，如果我对这个软件非常满意，没有遇到什么需要解决的问题，那么我不会需要刻意去创造需求解决需求。维持一个开源社群，固然需要核心成员和资深开发者的长期投入也即留存，但是能够为软件解决某个特定问题的人，即使他只解决了这个问题就再也不出现了，难道创造的价值就会被消失吗？</p>
<p>例如，Apache Flink DataStream API 的核心作者 <a href="https://github.com/gyfora">Gyula Fora</a> 在 2014-2015 年完成这项工作后，六年间几乎销声匿迹。最近被 Apple 招募之后，在新的需求和开源领域影响力的驱动下，又开始了 <a href="https://github.com/apache/flink-kubernetes-operator">Flink Kubernetes Operator</a> 的密集开发。他所做的代码贡献，出自于自己的需求，也契合 Flink 社群中用户的需要，因为这样的原因提交的代码贡献，才能避免形式主义和为做而做的误区，直面需求并解决需求。</p>
<p>开源社群的参与者来来往往，作为项目维护者在维护项目期间，只要保证项目整体前进即可，不用太过关心某一个人为什么来了又为什么走了。而且，软件开发从来不相信人月神话，不是人数越多，就越能开发出好的软件。换个角度说，即使是 Apache 软件基金会的顶级项目，<a href="https://projects.apache.org/projects.html?number">Committer 数量超过 100 个的也不过 6 个项目</a>。对于现在动辄号称自己数百名开发者，上千名开发者的开源社群来说，核心成员占比极低，不是很正常吗？</p>
<p>我在发起或参与这样的活动的时候，只关注活动所绑定的这个开发任务，在活动的形式下是不是被高效地解决。至于活动结束后参与者能否找到与社群的共同利益，留下来共同成长，这至少不是活动本身所能完成的任务。</p>
<p>不过，以实际需求为出发点的活动，因为与参与者一同实际解决问题的经历，确实有可能为开源社群引入新鲜血液。</p>
<p>@Xuanwo 就是从 CNCF Community Bridge 活动参与到 TiKV 社群当中的，他为 TiKV 实现了 Enum 等多个算子的下推，并且至今仍然关注 TiKV 社群。</p>
<p>近期开源的 RisingWave 流数据库的存储引擎的主要开发者之一 @skyzh 也是通过 CNCF Community Bridge 参与到 TiKV 社群的。他在 TiKV 主力开发了 AgateDB 这个基于 LSM Tree 的存储引擎，虽然这个项目 TiKV 后来没有继续下去，但是在 RisingWave 的存储引擎当中延续了它的精神。@skyzh 最近发布的<a href="https://github.com/skyzh/type-exercise-in-rust">用 Rust 做类型体操</a>系列，我想也跟为 TiKV Coprocessor 设计 RPN 表达式有关。</p>
<p>Apache SkyWalking 通过 GSoC 的活动吸引到了 <a href="https://github.com/fgksgf">@fgksgf</a> 的参与，并在完成相关工作后顺利成为了 Apache SkyWalking Committers 的一员。他强大的带货能力把 Apache SkyWalking Eyes 带到了 TiDB 项目里，也是因为这个原因我才知道了这个项目并且进一步大规模宣传 Apache SkyWalking Eyes 在自动化检查 License Header 的优质体验。最近又看到他<a href="https://lists.apache.org/thread/lf1nvnw5ks97f8s47m2dgttssb7nq6rz">主导发布了 Apache SkyWalking CLI 0.10.0</a> 的消息，很为他高兴。</p>
<p>其实，本不需要这篇文章来讲一个浅显的道理，<strong>开源协同的目的是生产高质量的软件</strong>。为了这个目的产生的代码贡献，才是开源社群需要的代码贡献。让社群成员切身体会到自己在参与制造一个伟大的软件，才是维持社群吸引力的不二法门。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源社群</tag>
      </tags>
  </entry>
  <entry>
    <title>我们为什么要编纂历史？</title>
    <url>/2022/04/20/compiling-history/</url>
    <content><![CDATA[<p>早在今年初，<a href="https://opensourceway.community/">适兕</a>就建立了「开源之史」讨论小组，旨在探讨有关技术、人物、思想、文化等开源世界发生过的事件和演化。</p>
<p>一开始，我对这个小组保持观望态度，既期待能够从中了解一些或许自己还不知道的历史，又对历史研究抱有一定的怀疑。一直以来，我都推崇关注现在，解决实际问题，研究历史尤其是尚未有定论也没有“信史”的“开源之史”，到底有多大的作用，我并不确定。但是，近日来发生的一些事情，让我重新考虑“历史”的价值，也对标题提出的“我们为什么要编纂历史”这个问题有了新的理解。</p>
<span id="more"></span>

<p>清代龚自珍《定庵续集》有言，“欲知大道，必先为史。灭人之国，必先去其史。”</p>
<p>一个群体的历史不是平铺直叙，而是反映了这个群体对已经发生的事情的认识和定性。历史如果不能被正确的记录和认识，针对相应主题的讨论就是虚幻的，形成的知识也是缺乏基础的。</p>
<p>编纂历史的第一步是汇集史料。汇集史料这一步，是从各种输入源获取对已经发生的事情的记录。例如<a href="https://zhuangbiaowei.github.io/">庄表伟</a>翻译的<a href="https://zhuangbiaowei.github.io/opensource/history/2022/04/03/history-of-free-and-open-source-software.html">《自由和开源软件的历史》</a>从维基百科摘录而来，维基百科当中又有相应史实的出处标记，例如上文原文在维基百科上就有 76 条引用。</p>
<img src="/2022/04/20/compiling-history/references-history-of-foss.png" class="" title="References of history of free and open-source software">

<p>得益于互联网的发展，大众创作的维基法则也在汇集史料这一点上体现。例如，关于自由软件运动的发展，核心成员在各阶段的观点，以及不同时期发生的事件，在 <a href="https://www.gnu.org/philosophy/philosophy.html">Philosophy of the GNU Project</a> 和 <a href="https://www.fsf.org/campaigns/">Current campaigns by Free Software Foundation</a> 等页面都有记录。开源促进会也在自己的博客 <a href="https://blog.opensource.org/">VOICES OF OPEN SOURCE</a> 上记录了诸多时事。研究互联网时代的历史，史料的数量只会更多不会更少。</p>
<p>不过，修史并不是对史料的简单拼凑。汇集史料的下一步就是去伪存真。好的史书总有“信史”的称号，意即详实可信的史书。中国历史上有二十四史之说，其中的《史记》、《三国志》都是有名的信史。近日触发我考虑编纂历史的意义的，正是史实的准确记录和传播的价值。</p>
<p>互联网时代信息大爆炸，最近一段时间发生的事情，更是体现了每个人都是自媒体的环境下，谣言与辟谣的拉锯。我们发现很难说辟谣真的是在辟谣，也很难说谣言都不是谣言。到底我们怎么样把一个时期发生的事情相对准确地记录下来，或许是每一个人都值得思考的话题。</p>
<p>前面提到，历史反映了群体对已经发生的事情的认识和定性。先秦时期有董狐直笔和记录“崔杼弑其君”的齐太史的故事，但是越往后世发展，则历史为政治服务的特征就越明显。哪怕是《史记》和《三国志》这样的“信史”，也有迎合统治需要的神话传说或者明显的矛盾和曲笔。</p>
<p>编纂开源运动的历史，或许也会陷入到现实与理念的矛盾当中。开源运动一直以来都不只一种声音，1998 年的山景城会议，虽然云集了 Linux 的创作者、Python 语言的创作者、Perl 语言的创作者、Apache Httpd 的创作者还有 Tim O’Reilly 和 Eric Raymond 这样的开源先锋，但是会议达成的也只是一个笼统的基于开放源代码的合作的模糊共识。会议唯一形成的结论，就是在宣传上统一采用 Open Source 的表达。</p>
<p>后来的二十余年间，围绕出现了各式各样的参与者。例如才华横溢的工程师，FFmpeg 和 QEMU 的作者 Fabrice Bellard 和 SQLite 的作者 D. Richard Hipp 等。例如创造开源相关软件协议的律师，GPLv3 的联合撰写者 Eben Moglen 和开源专门律师 Heather Meeker 等。例如可以独立成为一个潮流开端的 RedHat 式开源技术公司，以及可以独立成为另一个潮流开端的 MongoDB 和 Elastic 式源码可得技术公司。往前追溯，则还有第一个系统地明确提出获取和使用源代码“自由”的自由软件基金会以及它的领导人 Richard Stallman 等。</p>
<p>适兕在<a href="https://opensourceway.community/posts/history-of-open-source/00-how-to-think-in-history-view/">《「开源之史」系列之一：该如何思考开源的历史？》</a>一文里写到关于开源的历史，要避免陷入“时间轴概述的误区”，因为开源并没有像年代表示那样呈上升趋势。</p>
<p>这正是因为开源这面旗帜下聚集的人员众多，自由软件运动、开放源代码运动和开源商业化浪潮，其实各自之间没有明显的承袭关系，反而更接近独立发展在同一个名称之下的不同势力。</p>
<p>前面举例的人物，互相之间对软件开发和源代码开放的理念甚至可能互相冲突，这也显得对于开源历史的编纂和基于对历史提出的定论来形成对未来的指导尤为重要。前面提到，山景城会议达成了对 Open Source 一词作为宣传表述的共识，但是后来由 Eric Raymond 和 Debian 的领袖 Bruce Perens 等人建立的开放源代码促进会（Open Source Initiative，OSI）并不是会议的直接结果。近年来，对于什么是开源，对于 OSI 及其提出的开放源代码定义（Open Source Definition，OSD）能否代表开源，其实暗流涌动，有过许多轮较量。</p>
<ul>
<li><a href="https://opensource.org/node/1099">The SSPL is Not an Open Source License</a></li>
<li><a href="https://techcrunch.com/2019/05/30/lack-of-leadership-in-open-source-results-in-source-available-licenses">Lack of leadership in open source results in source-available licenses</a></li>
</ul>
<p>以人物为划分基准的开源历史，在适兕的<a href="https://book.douban.com/subject/35716759/">《开源之迷》</a>当中有过尝试。这也是我对该书最喜欢的一部分。以运动潮流为划分基准的开源历史，或可区分成自由软件运动、开放源代码运动、开源商业化和沉默的大多数的开源软件这四大类，它们各自内在的起源和目的是很不相同的。以项目案例为划分基准的开源历史，则接近于我在创作中的《开源案例库》的叙述方式。</p>
<p>编纂历史，要在过程中体现出对历史的态度，即基于史实和“史识”评价乃至断论一段历史。上面提到的不同切分方式，则是对开源历史建模的一种思考。《史记》以本纪、世家、列传、表和书为体例，《汉书》则开创了纪传体断代史的先河，它们各自为历史叙事定下一种叙述模型。然而开源的历史应该怎么讲，有哪些线索、哪些关键要素，目前仍无定论。甚至于开源这个词本身，是否符合当前的需要，也尚处于争论当中。例如我在不同场合会提到开源不止开放源代码，但是 Open Source 这个词提出的背景，确实强调的就是开放源代码，我们是不是需要一个更好的表述方式，也是一个暂时没有结论的问题。</p>
<p>除了开源的历史，再回到触动我思考历史相关的问题的出发点，自二十四史以后，现实是如何发展到现在的，我们有没有历史可以依据？我想很多人也并不清楚。对于时事的讨论，我看到参与者很容易陷入到身份政治的桎梏里，枉顾事实只管站队后相互抨击。且不说这样的情况发展下去只会在原本万物互联的世界里形成一个个信息茧房，这些抨击本身也是虚幻的。因为失去了对事实的探究，追求宏大叙事或者以点概面急速上升，我们没能关注到具体的人、具体的事到底是怎么发生的，到底为什么发生。</p>
<p>我们看《史记》、看《三国志》，多的是以人物和事件为核心的叙事。如果能够再多一些对具体的人、具体的事的聚焦，撕开身份和站队这面无差别的旗帜，迫使其中的个人思考他的境地和责任，或许比起，一个模糊的概念碰撞另一个模糊的概念，会更有价值一些。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>《知识社群》书评</title>
    <url>/2022/02/27/cultivate-communities/</url>
    <content><![CDATA[<p>时隔两年，以姜宁老师的分享为契机，我重读了<a href="https://book.douban.com/subject/35083568/">《知识社群》</a>一书。结合这两年在开源社群方向的经验，我从中发现了不少极具实践价值的内容。</p>
<p>《知识社群》一书从知识社群的社会性出发，从知识社群的历史沿革，全球知识经济的发展进程，以及知识社群在知识时代的机遇三点立论，阐述了知识社群的时代价值。进一步地，本书介绍了知识社群的三个结构要素，划分了知识社群发展的五个阶段，归纳了知识社群培养的七个原则。本书对知识社群的定义如下。</p>
<blockquote>
<p>知识社群是这样一群人，他们有共同的关注点、同样的问题或者对同一个话题的热情，通过在不断发展的基础上相互影响，深化某一领域的知识和专业技术。</p>
</blockquote>
<span id="more"></span>

<h2 id="领域、社群和实践"><a href="#领域、社群和实践" class="headerlink" title="领域、社群和实践"></a>领域、社群和实践</h2><p>本书提出的知识社群三个结构要素分别是领域、社群和实践。</p>
<blockquote>
<p>领域创造共同点和共同身份的感觉。一个明确的领域能够确定社群的目的以及它对成员和其他人的价值，从而说明社群的合理性。这样的一个领域可以鼓舞成员们做出贡献、积极参与，指导他们的学习，使他们的行动具有意义。了解领域的范围和最前沿，使得成员们能够准确地决定哪些东西值得分享，怎样提出想法，追踪哪些活动，还使他们认识到试探性或不完整的想法的潜力。</p>
</blockquote>
<p>规划一个新的开源社群，首要解决的就是核心开源软件的定位问题，也就是社群将关注在哪个技术领域。这个技术领域可以由一组用户需求，一个现有软件，或者一系列论文定义。</p>
<p>例如，Apache Kafka 一开始定位在解决日志存储和消费的业务问题上，Apache Flink 实现流式计算 API 后对标 Apache Storm 提出富有竞争力的有状态数据流计算定位，Apache Hadoop 则是对 GFS 和 MapReduce 论文的开源实现。</p>
<p>明确领域定位，才能降低开源社群成员交流的门槛。大部分的开源项目不是一个全新的问题，而是现有问题的解决或者现有方案的改良。因此，明确与现有概念之间的联系，才能够使得已经关注现有领域的人能够迅速理解新社群的领域定位，找到共同点和共同身份。不需要从头接触一个陌生的领域，而是对比与现有概念之间的联系和区别，就可以提出一系列的问题，也能理解什么问题是值得分享的。</p>
<p>例如，设计一门编程语言的时候，定位在静态类型或动态类型，就是完全不同的方向。相关领域的专家完全有可能分别拿 Haskell 和 Lisp 来比对概念上的差别，当前语言还没有实现的，尝试实现、模仿或者论证为什么不能实现。曾经对当前实现不满而因为种种原因无法落地的改进方案，抛出来与社群成员分享并争取在新项目当中实现。</p>
<p>领域的定位不是固定的问题，而是与社群一起演变的知识范围。领域的定位也不是抽象的兴趣，而是由社群共同经历的关键事件或问题组成的。</p>
<p>从现有概念延伸到新的知识社群的领域之后，社群存续下去而不是合并到现有社群的理由，就是自己的差异点。这些差异点不是一成不变的，随着不同人的加入可能发生很大的变化。例如，Apache Flink 一直在分布式计算引擎领域当中，但是在 14 年之前，它还是一个注重批处理负载的软件。直到两位开发者在 2014 年中的时候实现了 DataStream API 以后，才转向流式处理领域。例如，Perl 6 项目最初在设计上大量承袭了 Perl 的设计，并且很大程度受到那段时间的面向对象浪潮的影响。但是在 Pugs.hs 项目带来了 Haskell 社群的新鲜血液和函数式编程的思想以后，不少语言设计开始针对函数式编程的范式做出优化。而 Perl 6 的并发编程模型，则是在来自 Node.js 社群的强力开发者加入领导项目开发以后，利用 Node.js 所使用的 libuv 库搭建起来的。</p>
<p>可以看到，领域的问题都是非常具体的，能够围绕解决现有问题或改良现有方案分享知识和进行实践。领域的定位如果太过抽象，例如书中提到的“技术技巧”，那么社群就更像是一个兴趣小组甚至只是一组非常松散的圈子关系，因为围绕抽象议题提出的观点往往很难落到实处，也就很难激起社群成员的兴趣和创造价值。</p>
<blockquote>
<p>社群创造学习的社会结构。一个强大的社群能培养互动精神，培养基于相互尊重与信任的关系。他鼓励人们分享想法，暴露自己的无知，提出困难的问题，并且仔细倾听，这是一种混合的气氛：人与人有着亲密的关系，同时又相互坦诚开放地提出和探讨问题。</p>
</blockquote>
<p>社群对有效的知识结构非常关键。知识社群不仅仅是一个网站、一个知识库或者最佳实践集合，重要的是相互影响和共同学习，并在彼此之间建立联系的人。参与社群活动使社群成员形成归属感和相互的承诺。每个人分享对于某个领域共同的整体看法，而又在特定问题上带来个人的观点，这就创造了一种总和大于组成部分的社会学习结构。</p>
<p>虽然一个开源共同体可能为了推动软件的开发会建立相应的组织结构，但是在所有知识社群当中，知识的交换都是自由的，或者说去中心化的。Apache 软件基金会在 <a href="https://www.apache.org/theapacheway/index.html">The Apache Way</a> 当中强调了它所构建的开源共同体是由平等的个体所构成的。</p>
<blockquote>
<p>Community of Peers: individuals participate at the ASF, not organizations. The ASF’s flat structure dictates that roles are equal irrespective of title, votes hold equal weight, and contributions are made on a volunteer basis (even if paid to work on Apache code). The Apache community is expected to treat each other with respect in adherence to our Code of Conduct. Domain expertise is appreciated; Benevolent Dictators For Life are disallowed.</p>
</blockquote>
<p>书中提到，知识存在于人类认识事物的实践当中。它不是一种物质，不能像游戏当中双击使用书籍即可获得经验和智慧。只有通过社群的形式将关注到同一个领域上的个体聚拢起来，经过运营和管理有意识地促进知识的流动，才能促进知识的动态演进，并将知识带来的价值传达给每一个社群成员，最终使得社群成员所在的组织以及社群本身受益。</p>
<blockquote>
<p>实践是社群成员分享的一套架构、想法、工具、信息、风格、语言、故事和文件。领域指出社群关注的主题，而实践是社群开发、分享和保持的特定知识。社群建立一段时间以后，成员们认为彼此应该已经掌握了社群的基本知识。大家分享共同的知识和资源，使得社群能够高效地处理领域内的问题。</p>
</blockquote>
<p>知识社群不是魔法，它不能够直接将一个对领域一无所知的人转换成一个能够直接为社群创造核心价值的人。但是，社群可以通过实践的分享，将最佳实践总结成文档，在社群成员当中建立如何基于情景判断的共识，来提高知识社群交换知识、创造知识的效率。通过分享实践，知识社群扩大了自己的影响力，并且建立了一个隐形的参与要求。在正式成员之间，最佳实践是众所周知的，因此沟通的效率也将显著地提高。</p>
<h2 id="知识社群的发展阶段"><a href="#知识社群的发展阶段" class="headerlink" title="知识社群的发展阶段"></a>知识社群的发展阶段</h2><p>本书在介绍知识社群的发展阶段之前，首先讨论了培养知识社群的七个原则，这些原则将会贯穿不同发展阶段的关注点。</p>
<ol>
<li>精心设计社群的演化历程</li>
<li>在内部和外部的不同观点之间建立对话</li>
<li>鼓励不同程度的参与</li>
<li>既发展社群的公共空间，也发展社群的私人空间</li>
<li>以价值为关注点</li>
<li>组合熟悉和兴奋的感觉</li>
<li>构建社群节奏</li>
</ol>
<h3 id="知识社群的潜在期"><a href="#知识社群的潜在期" class="headerlink" title="知识社群的潜在期"></a>知识社群的潜在期</h3><p>知识无处不在。当围绕着同一个领域的一群人开始交换知识和实践的时候，一个非正式的知识社群就形成了。从非正式的知识社群转变成为正式的知识社群，意味着它开始强化社群的三个关键要素。</p>
<ul>
<li>关键的领域问题是定义领域的范围。</li>
<li>关键的社群问题是找到那些已经就这个主题形成网络的人，帮助他们想象网络的扩张和知识分享活动的增加会发挥怎样的价值。</li>
<li>关键的实践问题是识别共同的知识需要。</li>
</ul>
<p>这三个问题的目的都是找到潜在的社群成员之间足够多的共同点，从而使得即将构建的知识社群能够创造足够凝聚成员的价值。<a href="value-creation.md">共同创造价值</a>是知识社群的最终目的。社群依靠它提供给成员的价值来推动，社群成员需要看到他们的热情怎样转变成有用的东西。</p>
<p>另一方面，启动社群不是从头开始。如果社群能够为其他人创造价值，那么一定已经存在围绕社群关注的领域形成网络的人。告诉他们你的社群能够就他们关注的领域提供足够多的价值，他们的知识和见解也能够在其中转变为实践。以开源共同体的潜在参与者来说，很少有人能够拒绝这样的诱惑。前提是你的社群真的对他们关注的领域有足够优质的实践。</p>
<p>我在一份规划开源社群的草案当中列出的一个关键问题，就是明确社群期望某种形式的参与，并思考可能的参与者现在在哪。书中写到，启动一个知识社群，需要同时发现你可以在什么基础上组建，并想象这个基础的潜力能够把你带到哪里。如果忽视了目前已经形成的网络，那么社群将很难吸引到最有可能成为早期参与者的人。但是如果只是考虑目前的网络，就不能超越个人的限制而为社群引入新的看法。</p>
<p>对于一个新的开源社群来说，一个常见的问题就是对参与者有过于苛刻的预期，并且在预期被屡次打破以后反转成一种彻底的不信任。实际上，哪怕是最有热情的参与者，也需要在持续的价值创造中找到和社群发展的共同利益。尤其是对于一个公司内部的软件团队，考虑突破组织边界以开源社群的方式运作的时候，不同背景带来的信息差是不可避免的。</p>
<p>这一方面需要建立起对话的渠道，就像我在 <a href="https://mp.weixin.qq.com/s/gOcQpXtUPqr1Ti7Hkyr_RQ">Open Discussion</a> 当中介绍的一样。另一方面，也需要认识到社群当中存在不同程度和不同类型的参与。</p>
<p>本书当中也采用了同心圆形式的社群引力模型，核心人员往往只占有 10% 左右，积极参与者也不过 20% 上下，剩下的七成左右的参与者，不会对社群的发展产生明显的促进。当然，这些比例和每个个体的行为是会动态流动的。社群的核心组对这样的情形应该有足够的预见性，避免对每个社群成员都予以核心成员的期望，或者按照市场营销的漏斗模型强迫每个成员选择向核心成员的“转化”或者离开。</p>
<p>这一阶段最重要的就是广泛的接触潜在成员和联系社群成员，通过人与人的联系和知识的交换以及实践的交流，定义出领域的范围、社群的主要意图和富有吸引力的切入点。如果社群能够度过这个阶段，往往能够发现潜在的社群协调员和思想领袖。</p>
<p>社群协调员会关注到社群新人的招募，会见潜在的成员，并联络核心成员以对齐社群对关键问题的认识和增强人际连接。思想领袖是社群关注的领域的专家，他们能够定义前沿问题，或者本身是具备丰富经验、德高望重的从业者。思想领袖的加入为社群提供了强有力的凝结核，试想 Ruby on Rails 的作者为 Ruby 社群带来了多少 web 开发者的参与。</p>
<p>书中分点罗列了这一阶段的典型工作计划，作为书评无法面面俱到的议论，但是仍然值得引用以作推荐。</p>
<ul>
<li>决定社群的主要意图</li>
<li>定义领域，识别有吸引力的问题</li>
<li>证明行动的理由</li>
<li>识别潜在的协调员和思想领袖</li>
<li>会见潜在成员</li>
<li>联系社群成员</li>
<li>发展社群的初步设计</li>
</ul>
<h3 id="知识社群的接合期"><a href="#知识社群的接合期" class="headerlink" title="知识社群的接合期"></a>知识社群的接合期</h3><blockquote>
<p>如果一个社群能够把对现状的良好理解和对未来发展方向的构想结合起来，它就已经具备条件，可以向接合期转变了。</p>
</blockquote>
<p>社群启动的时候，正如一家创业公司最初的商业计划，看起来往往是脆弱甚至站不住脚的。如果一个社群的领袖能够有信心地宣传社群的目标，介绍当前的情况，并说明如何从当前的情况逐步实现最终的目标，那么社群就可以开始举办各种活动和正式启动，扩大互相信任的社群成员的范围了。</p>
<ul>
<li>关键的领域问题是建立在这个领域内分享知识的价值。</li>
<li>关键的社群问题是充分发展关系和信任，使成员们能够讨论实践中真正复杂的问题。</li>
<li>关键的实践问题是明确哪些知识应该分享和怎样分享。</li>
</ul>
<p>信任在这一阶段极为重要，没有它，社群成员很难发现领域最重要的方面和社群真正的价值。虽然每个人都知道平等的交流，相互请教和寻求帮助能够提升自己和他人的知识水平，解决问题的成员也能积累自己的声誉和经验，但是缺乏信任的环境当中，大部分人会选择沉默或观望，而这种沉默和观望如果没有核心成员和积极的参与者以身作则破除不信任的印象，就会不断恶化，使得社群无法产生价值，进而失去由共同的目标的背景聚拢起来的早期成员。</p>
<p>建立信任，不仅仅是核心成员以身作则带来的形式上的安全感，还涉及到社群成员对社群目标的信任。前面提到，共同创造价值是所有社群的最终目的，不同社群只是在创造什么价值，以及如何创造价值上有所差异。如果不能在聚拢起早期成员之后，持续地回馈知识分享的价值和知识实践的价值，那么大部分参与者将会保持或者变成观望的状态，而不是付出足够的时间精力和热情投入到社群当中来。这也是我常说的开源参与者的思路是“谁赢他们帮谁”。</p>
<p>例如，《大教堂与集市》在总结 Linux 的成功经验的时候，就提到了 Linus 在早期开发的时候经常每天发布新的版本，新的版本当中包括了社群成员提交并被接受的补丁。这种直接回馈参与者，让他们看到自己的参与真的能够赢得回报，能够在社群当中建立起最朴素的信任关系。我在提及自己为什么参与 Perl 6 和 Apache Flink 这两个开源社群的时候，也强调了能够及时得到响应，解决自己的问题，并且提交的补丁能够被合并和发布，在社群当中看到我的努力帮到了更多的人，这种喜悦和认同感是联系社群成员的关键。</p>
<p>我和开源社群维护者交流的时候，一定会问的一个问题就是参与者为什么要进入你的社群，你能提供什么价值。尤其是作为一个知识社群，你在领域知识上的领先性体现在哪里？如果是一个自研项目开源的情况，往往项目的所有人都转过好几手，团队负责人只是接受命令开放源代码，那么他是很少考虑这个问题的。实际上，他本人可能都不太关注这个项目有什么用，为什么存在。</p>
<p>如果一个社群只是纯粹的复制别人做过的工作，那么顺着开源文化将会导向上游优先的结果。Apache 孵化器在接受项目的时候，就会衡量这个项目是否已经有同类已经存在，如果已经存在，那么加入这个社群，比起另起炉灶分裂是要更合理的。</p>
<blockquote>
<p>We prefer “Do NOT confuse users” because we accepted projects nearly doing the same thing. We always encourage more people could join together and build a more powerful project and community, rather than building several similar projects.</p>
</blockquote>
<p>同样，书中对接合期提供了一个典型的工作计划。这个计划的假设更多是在公司组织当中发起一个知识社群。</p>
<ul>
<li>向成员说明理由</li>
<li>启动社群</li>
<li>发起定期的社群活动</li>
<li>赋予社群协调员合法地位</li>
<li>在核心组成员之间建立联系</li>
<li>发现值得分享的想法、见解和实践</li>
<li>明智地整理文件</li>
<li>识别提供价值的机会</li>
<li>经理的介入</li>
</ul>
<h3 id="培育和维持知识社群"><a href="#培育和维持知识社群" class="headerlink" title="培育和维持知识社群"></a>培育和维持知识社群</h3><p>书中还介绍了知识社群的在启动和实现正常运转以后，走向成熟和管理的后续阶段。限于一篇书评能够关注到的重点有限，这里不做展开论述，只做重点罗列，以期能够激起各位阅读原版的兴趣。</p>
<p>成熟期的关键问题</p>
<ul>
<li>关键的领域问题是定义在组织中的角色以及与其他领域的关系。</li>
<li>关键的社群问题是管理社群的边界，因为这时的社群已经不仅仅是从事同一职业的朋友网络。在定义新的、更广阔的边界时，社群必须保证不脱离自己的核心目的。</li>
<li>关键的实践问题不再是简单地分享想法和见解，而是认真地组织和管理社群知识。随着社群形成更强的自我意识，核心成员开始认识到真正的前沿知识和知识社群的差距，感到需要更系统地定义社群的核心实践。</li>
</ul>
<p>管理期的关键问题</p>
<ul>
<li>关键的领域问题是保持领域的合理性，在组织中发出自己的声音。</li>
<li>关键的社群问题是保持有活力、吸引人的风格和关注点。</li>
<li>关键的实践问题是保持前沿地位。</li>
</ul>
<p>《知识社群》一书立论的基础跟开源共同体还是有所不同，它主要关注到企业应该如何发起、维持和培养知识社群，并从知识社群的蓬勃发展中受益。当然，相当一部分开源共同体也遵循这样的模式，由企业当中的最佳实践出发，以开放源代码和开源协同的方式跨越组织边界交流知识和实践以解决领域当中实际的问题。</p>
<p>本文主要的关注点还是在于社群本身的健康发展，原文关于如何将社群的价值和组织的价值结合起来，有更加详细的分点讨论。简而言之，就是社群作为一个独立的结构，如何找到它与公司组织利益的共同点，是它能够获取资源和赢得员工信任的关键。而如何找到社群发展与个人发展的共同点，则是持续吸引参与者的关键。</p>
<p>其中对于企业组织的价值，我在过去几天有过一段论述：</p>
<p>开源运营，对于企业来说有两个主要目的，一个是技术品牌的建立，一个以开源协同的方式打造成为行业标准的软件。这两个做好了，技术公司的技术知识优势，人才吸引力和留存率，还有成为标准以后的赢家通吃的价值，就非常可观了。</p>
<p>最大的挑战是如何协调公司的利益和社群的利益，使得两者尽量互不冲突的往前去走，相互能够合作。这个能够达成好的结果的前提是各方能够坦诚沟通，所以需要一个渠道和真正的去沟通。至于沟通下来仍有冲突的各种情况，做好预案就行了。</p>
<p>现在的开源处于一个相对好的时代，MongoDB 和 Elastic 当初面临的那种激烈冲突不太可能再次发生了。当然最终能够守住自己的利益，还是依赖自己强大的实力，不管是技术实力、谈判能力，还是其他。</p>
<p>我现在感觉到最难找的是有技术能力，且认同开源理念的团队。有技术实力，才能够在运营的时候依靠正道的方法掌握主动权。否则所谓的“运营”，就会变成为了技术不足的团队“善后”社群的技术挑战，而采取排他垄断的一个部门。这样就跟开源的理念背道而驰了。</p>
]]></content>
      <categories>
        <category>大图书馆</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源社群</tag>
      </tags>
  </entry>
  <entry>
    <title>高效参与开源的诀窍</title>
    <url>/2021/12/05/effective-open-source-participant/</url>
    <content><![CDATA[<p>大部分人参与开源社区会面临的一个巨大挑战，那就是缺乏时间。本文试图提供一种方式，帮助想要参与开源社区的同学高效利用有限的时间。</p>
<p>在一个开源社区里，maintainers 需要关注的范围比 contributors 要大得多。本文分别讨论这两类人群适用的参与开源社区的技巧，以减少过程中的摩擦，提高时间的利用率。</p>
<span id="more"></span>

<h2 id="Contributors"><a href="#Contributors" class="headerlink" title="Contributors"></a>Contributors</h2><h3 id="第一步要加入社区"><a href="#第一步要加入社区" class="headerlink" title="第一步要加入社区"></a>第一步要加入社区</h3><p>参与开源社区的第一步就是加入社区。加入社区的方式有很多，可以订阅邮件列表，关注开发活动，参与技术或非技术讨论，等等。很多希望参与开源社区的人迟迟迈不出第一步就是忽略了自己首先要加入社区，跟社区建立起联系。</p>
<p>一个典型的错误做法是完全不顾开源社区是开发开源项目的主体，一头钻进技术细节里，暗搓搓地做一个“大功能”，然后希望社区尽快合并这个补丁，让自己得到荣誉。</p>
<p>Linux Foundation 有一篇博文明确反对了这种做法。</p>
<blockquote><p>Some organizations make the mistake of developing big chunks of code in house and then dumping them into the open source project, which is almost never seen as a positive way to engage with the community. The reality is that open source projects can be complex, and what seems like an obvious change might have far reaching side effects in other parts of the project. Any significant change is likely to require some community discussion before it moves to implementation to make sure that there are no side effects and that the solution is aligned with the broader goals for the project. While you discuss it with the community, it can help to focus on the problem, rather than a specific solution, before you invest too much time in the creation of a body of code.</p>
<footer><strong>Linux Foundation</strong><cite><a href="https://www.linuxfoundation.org/tools/participating-in-open-source-communities/">Participating in Open Source Communities</a></cite></footer></blockquote>

<p>一个现实的例子，前几天有人问我，自己做了一个 Flink StateBackend 的实现，提交给社区是不是就能当 PMC 了。这个问题属实把我整不会了。从来没有在社区当中亮相的人，突然出现并提出自己实现了一个“大功能”，在其他成员眼里跟民科没什么不同。绝大部分情况下，这种实现跟上游社区的开发节奏是脱节的，很难合回去。也就是说，闭门造车的形式自我感动地开发项目，即使花费了时间，大概率还是白忙一场。</p>
<p>刚开始接触 Flink 社区的时候，我就按照项目文档的提示订阅了 users 和 dev 两个邮件列表。实话说，最初的三个月，我基本看不懂他们在说什么。当时的我尽可能地读每一封邮件，从邮件里面引用的链接一个个点进去了解背景，混沌当中建立起对项目的初步印象。直到四个月后第一次提交代码，这个祛魅的过程才算完成。从此以后，我逐渐能够轻松地参与到技术讨论，也掌握了 review 的沟通习惯。</p>
<p>最近，我在跟人介绍 Engula 项目的时候，也是先发<a href="https://github.com/engula/engula/discussions">讨论区</a>和<a href="https://discord.gg/AN6vgVXaHC">聊天室</a>的链接。新成员可以阅读过往的讨论，挂在聊天室里，观察社区讨论问题和推进工作的方式，了解已有的设计实现和结论。参与闲聊或者回复感兴趣的话题，找到自己愿意投入的工作。只有这样，才能进一步深入参与开源社区，而不是接触了好几年，却始终迈不出第一步。</p>
<h3 id="找到感兴趣的问题"><a href="#找到感兴趣的问题" class="headerlink" title="找到感兴趣的问题"></a>找到感兴趣的问题</h3><p>要想利用有限的时间创造更多价值，最好的方法是找到一个感兴趣的问题，然后持续投入进去直到解决。</p>
<p>一个典型的错误做法是强迫自己做着不感兴趣的工作。这种情况下，由于内心是抗拒的，即使投入再多的时间，也几乎不会有产出。</p>
<p>可能有人会不理解，开源社区的 contributor 都是自愿参与，如果不想做某个工作，不是不做就可以了吗。其实不然，社区成员身处其中很容易感受到无形的社交压力。</p>
<p>一种情况是不懂得拒绝。知乎上有个问题，<a href="https://www.zhihu.com/question/475269038/answer/2045981148">如何优雅地拒绝开源项目的 PR 邀请</a>，讲的就是这种情况。我在回答里分享了一个自己拒绝 Flink 社区成员里的 PR 邀请的案例。另一种情况是错误估计难度，即自以为能搞定这个工作，做的过程里发现不对，又不好意思改口说自己搞不定。应对这些情况的方法非常简单，直截了当地说明情况即可，解放自己避免浪费时间。</p>
<p>另外一个难题是自己往往对比较有挑战性的工作感兴趣，但是从一个刚接触项目的 contributor 到能够完成一个复杂任务之间有一道坎。</p>
<p>要跨过这道坎，同样需要积极采取行动，而不要独自纠结。首先可以考虑从简单的工作入手，比如阅读项目文档时发现的拼写错误。一个简单的贡献能带你走完整个 contribution 流程。一回生二回熟，做其他有挑战性的工作也就不会在流程上踩坑。其次可以保持和 maintainers 的交流，以了解现有逻辑的设计背景和演进过程。只有对工作涉及的逻辑有充分的了解，才能写出高质量的代码。高质量的代码也意味着更少的返工和不必要的争论，也就避免了时间的浪费。</p>
<h3 id="建立与其他成员的联系"><a href="#建立与其他成员的联系" class="headerlink" title="建立与其他成员的联系"></a>建立与其他成员的联系</h3><p>随着参与的深入，总有你一个人无法完成的工作。开源协同的价值就在于跨越所属组织的边界合作开发项目。合作的基础是成员之间的信任，也就是良好的关系。</p>
<p>开源社区是围绕开源软件建立起来的。但是并不只有软件本身带来技术价值，人与人的连结带来认同感和归属感，这些也能满足社区成员的需要。此外，相互信任的基础能很大程度提升价值创造的效率，例如减少浪费在同步和对齐上的时间。因此，建立并保持与其他项目成员的关系至关重要。</p>
<p>做到这一点的方式就是充分的沟通。同样，这需要以开放的心态对待平时的交流。不要把所有事情都憋在心里。不要纠结于想清楚所有细节再开始沟通，其他成员一时间内往往没办法追上你所想的所有细节。我的建议是，当你有一个初步的想法，也做了力所能及的调研，就可以整理一下，发布到社区当中征求意见。</p>
<p>我给 Engula 项目做了一个<a href="https://github.com/engula/engula.github.io/pull/15">社区计划</a>。老实说，内容并不成熟，但是我一个人干想也得不出结论，所以在经过几轮自我 Review 以后，就先抛出来征求意见。另一个例子是 Engula 的 maintainer @huachaohuang 想为 contributor 提供开发文档，于是就发起了一个<a href="https://github.com/engula/engula/discussions/84">关于 Dev Guide 的讨论</a>。正好我对这个话题也早有想法，当我看到发出来的讨论以后，发现他也在关注这个话题。于是我花了一个小时把自己的想法写下来，经过讨论以后提 PR 推进主分支。</p>
<p>沟通协作的过程里冲突在所难免。我在好几个项目里都别人讨论甚至争论过很多次技术问题，给别人的行为提过意见，也夸赞过好的做法。开源社区解决冲突的方式比较朴素，一般是有话直说，尽量客观地达成共识，按照流程约定做出决策。不用整那么多弯弯绕浪费时间。</p>
<p>举一个现实的例子，曾经有人跟我抱怨提上去的 PR 被 maintainer 挑战了，问我应该怎么回复。怀疑 maintainer 是不是有偏见，抱怨很难跟 maintainer 沟通，大量的时间精力浪费在纠结这些臆想出来的问题，自然是筋疲力竭，感觉在开源社区里寸步难行。</p>
<h3 id="适合参与开源协同的工作"><a href="#适合参与开源协同的工作" class="headerlink" title="适合参与开源协同的工作"></a>适合参与开源协同的工作</h3><p>最后，关注到相当一部分 contributors 的公司员工的身份。这显然会影响到他们参与社区的动力和能力。</p>
<p>主要的挑战是，如果工作期间不允许参与开源社区，同时工作本身已经消耗了太多的时间精力，那么 contributors 对参与开源社区也只能是有心无力。这其实是很长一段时间里开源社区的参与在国内发展缓慢的原因。大量的开发者都在过度工作，下班只想躺平休息，没有动力再谈什么开源贡献。</p>
<p>不过，随着时间的发展，情况也在发生着变化。越来越多的公司采用更加灵活合理的工作时间，尤其是以研发为核心竞争力的公司。如果你所在的公司仍然要求超负荷工作，燃烧生命赚血汗钱，那么是时候找份新工作了。时代已经变了，就让这些公司被无情的淘汰吧。</p>
<p>另一个方向是考虑在工作期间参与开源社区。如果你确实喜欢某个开源项目，那么最佳策略就是找一份允许你全职投入这个项目的工作。这样的工作岗位如今并不少见。尤其是随着企业级解决方案越来越倾向于采用开源组件，企业对熟悉开源软件的人才的需求只会日益增加。如果找不到全职投入开源项目的工作，与之相关的工作也是备选方案。</p>
<p>不过，即使这份工作允许你全职投入开源项目，也并不意味着你能够参与开源社区。特别是当你的老板认为参与开源社区不能为公司创造价值的时候。面对这个问题，首先你可以问问你的老板，说不定他不这么觉得，那就省事儿了。如果你的老板确实难以理解，那你就得像兜售一个技术方案一样向他宣传参与开源社区的价值了。我在其他的文章里对这一点已经有不少讨论，你可以看看。</p>
<p>普适的时间管理手段这里就不展开介绍了，各种相关书籍和 GTD 方法论都很值得一看。</p>
<h2 id="Maintainers"><a href="#Maintainers" class="headerlink" title="Maintainers"></a>Maintainers</h2><h3 id="发展新成员"><a href="#发展新成员" class="headerlink" title="发展新成员"></a>发展新成员</h3><p>Maintainers 比起 contributors 需要关注的更多的事情。随着开源项目日渐复杂，开源社区逐渐成长，单靠一个人的力量很难处理好所有的事务。这个时候，就需要 maintainer 适时地发展项目维护的队伍。</p>
<p>首先需要理清 maintainer 头衔的定位。实际上，大部分项目的维护是个苦力活，而 maintainers 就是一群承担这些工作的社区成员。Maintainers 可能会拥有合并 PR 的权限，在社区治理中能投票做决策，确定项目发展的方向。但是，这种权限并非特权。在一个健康的社区里，任何社区成员都可以做技术讨论，也可以就社区发展话题提出自己的观点。对于技术观点，客观上更加合理的方案理应被采纳。对于社区发展话题，maintainers 也一定会考虑建设性的提议。</p>
<p>可能有不少人把成为 maintainer 当成参与开源社区的目标，这是很好的。如果你理解了 maintainer 的职责，通过 contribution 积累了足够的信誉，成为 maintainer 为开源社区服务，这个头衔是一个显式的认可。不过，大可不必过分纠结于 maintainer 头衔。这只是对 contribution 认可形式的其中一种，而不是唯一一种。</p>
<p>Maintainers 的职责并不轻松，所以 Python 社区和 Apache 软件基金会下的项目社区都会有一个询问 contributor 是否愿意成为 maintainer 的流程。也存在 contributor 拒绝邀请的情况，因为就像前面提到的，健康的开源社区里，只要提议是合理的，就能凭借其客观的优势胜出。成为 maintainer 并不意味着在方案选择上有特权。</p>
<p>对于 contributor 的感谢，也可以通过宣传渠道发布。比起一个模糊的 maintainer 头衔，作为技术人员，我会更在意这个人实际在开源社区里实际完成的事情。</p>
<p>基于上面的认识，我们引出下一个观点。Maintainers 发展新成员，必须是有选择性的。</p>
<p>这种选择性的主要依据是维护项目的需要，而不是追求数量或者过分在意 diversity 等等。这可以类比到开发软件的目的是提供技术价值，而不是代码行数或者所采用的编程语言的数量。</p>
<p>一个典型的错误案例是出于自己同时是公司员工的身份，被命令将 maintainers 的人数发展到某个数字。这种指标只关注数字而不关注具体的人，而且往往定得脱离实际。公司员工迫于指标压力很容易降低 maintainers 的标准，逮到一个算一个的凑人头，或者为了 diversity 对不同背景的 contributor 采取不同的标准。这样发展出来的 maintainers 不仅不能分担项目维护的职责，还很有可能因为不胜任而产生新的问题。</p>
<p>另一个典型的错误经常出现在个人项目上，当个人项目发展壮大，唯一的 maintainer 想要发展新成员时，很容易陷入到要找一个自己的分身的误区。 也就是说，新的 maintainer 必须和自己一样能够关注到项目的方方面面。这是不对的。没有两个人完全相同。只要一个 contributor 有足够的信誉，并且能在项目或社区的维护的某个方面上承担职责，他就是一个好的 maintainer 人选。</p>
<p>不过，这里讲到的信誉是一个非常主观的概念，提名 maintainer 的倾向每个项目也各有不同。</p>
<ul>
<li>Perl 社区最初由 Larry Wall 独裁。近年来，随着他逐渐淡出核心成员圈子，Perl 社区的治理实际上已经变成由 28 人组成的 core team 负责。</li>
<li>PostgreSQL 社区由 7 人组成的 core team 和 28 位 committers 处理所有工作。</li>
<li>ASF 治下的项目有一套比较固定的<a href="http://www.apache.org/foundation/how-it-works.html#roles">治理模型</a>。具体到每个项目，例如 <a href="https://pulsar.apache.org/en/contributing/#becoming-a-committer">Apache Pulsar</a> 和 <a href="https://flink.apache.org/contributing/how-to-contribute.html">Apache Flink</a> 会有自己具体的要求和倾向。</li>
<li>Spring Project 社区的 committers 都是 Pivotal 公司或 VMWare 公司的员工。但是它显然也是诞生于开源协同的作品。</li>
<li>Linux Kernel 基本上还是由 Linus 独裁。同时，海量的驱动和架构支持有各自的 maintainer 进行维护。参考 <a href="https://www.kernel.org/doc/html/latest/process/maintainers.html">Linux Kernel Maintainers 页面</a>。</li>
<li>Netty 社区没有明确的规则。Trustin Lee 发起项目并独自维护了三年。随后，Norman Maurer 和 Scott Mitchell 等少数几个人持续参与，成为 maintainer 并共同维护 Netty 项目至今。</li>
</ul>
<p>如果让我对 maintainer 提一个基础要求，我会希望他在项目或社区中做出了卓越的贡献，并且当前的 maintainers 团队乐于和他一起工作。</p>
<h3 id="结构化流程"><a href="#结构化流程" class="headerlink" title="结构化流程"></a>结构化流程</h3><p>除了增加项目维护的人员，另一个基本的减少时间浪费的手段就是结构化流程。我们分点介绍其内涵。</p>
<p><strong>第一点是直觉大于文档</strong>。对于托管在 GitHub 上的项目来说，help wanted 和 good first issue 标签是一个众所周知的约定。合理标记 issue 能让 contributor 按照过往的经验快速找到切入点。我在<a href="https://github.com/pingcap/community/issues/516">修订 TiDB 社区的治理方案</a>的时候，也是以跟 GitHub 开箱即用的功能亲和为主要目标之一。如果参与一个开源项目有太多新东西要学，那么 maintainers 就有的是要解释的东西了。大部分人效率最高的路径是完全凭直觉做事，并取得好的结果。所以如无必要，请勿设立复杂的规则。</p>
<p><strong>第二点是文档大于口述</strong>。直觉毕竟只能解决部分问题，对于特殊的或者需要强调的内容，明确记录下来作为文档绝对是个好主意。</p>
<p>不过文档首要的还不是记录流程，而是项目的目标或者叫定位。这是每个对项目感兴趣的人都会问的问题，高水平的 contributor 尤甚。他们不仅仅是想在开源社区里做简单的工作，更想成为一个伟大的或富有价值的项目的缔造者。如果你想为你的项目吸引到高水平的开发者，那么最好是确定一个清晰且令人振奋的目标，并将它展示在最显眼的地方。例如，Apache Flink 的定位是数据流上的有状态计算，其中有状态这点是开源世界里开创性的工作。例如，PostgreSQL 的定位是世界最先进的开源关系型数据库。例如，Elixir 语言的目标是构建可扩展和可维护的应用。</p>
<p>其次是约定俗成的文档，包括 README 和 CONTRIBUTING 等等。其中一般包含项目的简介，开始使用的方法，参与贡献的基本流程，和指向更多文档的链接。大部分 contributor 会尝试寻找和阅读这些文档。如果他们能从其中解决自己的问题，就不需要 maintainer 花时间说明了。至少，在有人提问的时候，直接发一个文档的链接，也能省不少事儿。</p>
<p>另一个值得强调的是 Code of Conduct 即行为准则。提名新的 maintainer 之前最好确保被提名人知悉和理解社区行为准则。行为准则通常是一些涉及平等、尊重和避免冒犯的原则。虽然大多数开源社区很少遇到严重违反行为准则的情况，但是 maintainers 应该对此保持敏感。这类问题一旦处理不当，很容易演变成政治斗争，甚至导致社区分裂或项目停摆。</p>
<p>最后是设计文档。Contributors 要深度参与技术贡献需要了解相关代码的设计背景和演进过程，设计文档就是最好的参考材料。良好的代码质量有助于避免 contributor 阅读源码时受挫，但是项目固有的复杂度还是需要设计文档来辅助解释。如果代码质量和设计文档都缺位，想要深度参与技术贡献的 contributor 就不得不指望 maintainer 花费大量的时间解释和指导了。这点对于 maintainer 自己也是一样的。当你想要做一个新的功能，如果没有好的技术文档，你也得懵圈，也得拉人反复对齐。</p>
<p><strong>第三点是避免私下讨论</strong>。有关项目和社区的讨论，唯一的信源应该是一个公开的渠道。例如，ASF 治下的项目要求所有有效的讨论都应该发生在邮件列表上。例如，大部分托管在 GitHub 上的项目隐含了讨论应该发生在 GitHub 平台上。社区成员可能还会通过其他的沟通渠道辅助交流，例如即时通信软件。但是这些辅助渠道的讨论需要被抄送到唯一信源上才实际生效。这样，contributor 才能在无需了解诸多渠道的前提下有能力获取所有有价值的信息。</p>
<p>这些公开讨论的内容以及表现出来的做事方式，就是社区当中的“活文档”。模仿是人类的天性，如果你希望别人遵循某种做事方式以减少冲突，那么最好以身作则，再带动更多的人跟随。前面讨论 contributor 的参与技巧时候说过，加入社区并首先观察别人是怎么做的，是一种避免浪费时间的好方法。那么与之相对的，maintainer 也要在项目维护和日常交流方面为此提供方便。</p>
<blockquote><p>Open Communications: as a virtual organization, the ASF requires all communications related to code and decision-making to be publicly accessible to ensure asynchronous collaboration, as necessitated by a globally-distributed community.</p>
<footer><strong>Apache Software Foundation</strong><cite><a href="https://www.apache.org/theapacheway/index.html">BRIEFING: THE APACHE WAY</a></cite></footer></blockquote>

<p><strong>第四点是考虑自动化</strong>。结构化的流程更容易自动化。当你的流程越来越结构化，那么是时候考虑自动化它了。显然，无需 maintainer 亲自动手的自动化流程能够减轻项目维护的压力。</p>
<p>同样，最好的自动化是符合直觉的。GitHub 平台提供了一系列自动化的支持。尤其是 <a href="https://github.com/features/actions">GitHub Actions</a> 发布以后，自动化的灵活性得到了进一步的提升。利用项目代码托管的平台提供的开箱即用的能力做自动化，能够最大程度的避免各种冲突。</p>
<p>自动化还应该建立在现有的成熟流程上，而不应该凭空生造一个流程。好的案例包括提交文档变更后自动部署文档页面，利用 merge bot 提高 pull requests review 和 merge 的效率等等。</p>
<p>其中，后者的采用是有两面性的。许多代码提交极其活跃的开源社区也仍然不需要引入自动化流程。当然，测试基本是自动化的，至少有脚本。不过 review 和 merge 还是可以人工完成的。我比较认同 merge bot 的地方是有些实现了排队合并功能以及 roll up 打包测试功能。这两个功能在保证合入主分支的代码是基于最新的主分支测试过的前提下，减少了需要进行测试的次数和人为协调的负担。但是，有些 merge bot 强制要求 review 和 merge 走非常严格的审批流程，把这个过程变得复杂不堪，这是我非常反对的。所以在引入 merge bot 之前，请确保你清楚地知道它如何改善协作效率，并保留回滚的能力。</p>
<p>另一个典型的错误案例是 stale bot 的自动关闭功能。真的，没人喜欢这个功能。开发者来到社区是为了和人建立联系，共同开发好的软件，而不是为了被机器人支配。应对 issue 或 PR 的积压问题，首先应该尽可能的及时处理。其次，大部分积压的 issue 是无效的内容，例如愿望清单和模糊的想法，这些只需要快速关闭即可。对于低优先级的 bug issue 的积压，既然问题是实际存在的，也不是 wontfix 的情形，凭什么关掉呢？如果当前的 maintainers 积极主动地处理 issue 和 PR 还是处理不过来，那么是时候寻找一个新的 maintainer 了。</p>
<blockquote><p>Users SHALL NOT log feature requests, ideas, suggestions, or any solutions to problems that are not explicitly documented and provable.</p>
<footer><strong>Collective Code Construction Contract</strong><cite><a href="https://rfc.zeromq.org/spec/42/#24-development-process">Development Process</a></cite></footer></blockquote>

<p>流程自动化的标杆案例包括 <a href="https://github.com/kubernetes/test-infra/tree/master/prow">Kubernetes 社区</a>和 <a href="https://github.com/rust-lang/homu">Rust 社区</a>。在学习这两个社区的做法的时候，需要强调的是</p>
<ol>
<li>请关注这两个社区为流程自动化投入了多少人力。</li>
<li>请关注这两个社区是在什么时候引入了何种自动化逻辑。</li>
<li>请关注这两个社区的成员如何利用自动化流程。</li>
<li>请关注这两个社区在流程自动化上的异同。</li>
<li>请关注这两个社区推行流程自动化时的讨论，尤其是争议。</li>
<li>请勿货物崇拜，直接照抄它们的方案。否则你会死得很惨。</li>
</ol>
<p>既然 Rust 社区都不抄 Kubernetes 社区的方案，你为啥贸贸然就要抄？</p>
<h3 id="日常事务"><a href="#日常事务" class="headerlink" title="日常事务"></a>日常事务</h3><p>前面讲的是一些整体的做法，回到每个 maintainer 身上，实际的项目维护工作其实是日常事务。</p>
<p><strong>最常见的问题是开发的风险控制</strong>。开源项目通常会有自己的版本发布周期。有时候你希望下个版本能交付某几个关键功能或改进，而这些工作并不都是由你一个人完成。尤其是，你之所以想交付这些变更，是因为公司的要求，而开发团队包括并非公司员工的成员。这个时候就需要你做好项目的风险控制。</p>
<p>从公司员工的角度，我介绍过开源项目和商业公司独立运营的协同模型。运用这个模型，可以把商业上紧急的需求实现在 fork 仓库上，交付 hotfix 应对紧急情况。稍后，把改动 contribute back 到开源项目当中。这样就可以把商业要求和软件开发的工程要求隔离开来，避免向开源社区倾倒粗糙的补丁。<a href="https://github.com/streamnative/pulsar">Stream Native</a> 就在公司组织下有 Apache Pulsar 的 fork 仓库。我没有仔细研究过他们的具体做法，但是显然他们把一些公司关心的内容都放在 fork 仓库上记录。让上帝的归上帝，凯撒的归凯撒。这是好文明。</p>
<p>如果评估出来更合适的做法是把改动直接做在上游，那么我会建议在需要严格控制风险的情况下，直接由公司员工组成开发团队。当然，这些员工得靠自己的努力在开源社区当中赢得信誉，而不是只根据职位就被允许直接提交代码。如果同样的需求已经有其他团队在做，那么沟通就是必要的。如果信得过这个团队，保持关注并提供帮助即可。否则，可以尝试接管项目开发。Flink 社区的 <a href="https://issues.apache.org/jira/browse/FLINK-16654">FLIP-85</a> 提案是我和 Uber 的工程师分别独立提出的。经过几轮邮件列表上的讨论，最终由阿里的工程师主导实现。我参与了 review 和提供了部分参考实现。</p>
<p>上面讲的是一个好的案例。其实对于一个活跃的开源社区来说，PR 冲突的情况不会太少，种类也很多。</p>
<p>TiDB 社区发生过一起有名的 <a href="https://github.com/pingcap/tipb/pull/208">Xuanwo 事件</a>。完全相同的两个补丁，后提交的反而先被合入，导致先提交的被迫关闭。尤其是这个事件发生在并不繁忙的仓库上，并且两个补丁提交的时间相差一个月。这是一种非常典型的情况，需要 maintainers 保持对项目范围内发生的活动的关注。</p>
<p>Flink 社区有不少经典的乐子。<a href="https://issues.apache.org/jira/browse/FLINK-10052">FLINK-10052</a> 作为我从 2019 年就和 @lamberken 配合修复完成并经过生产环境验证的高严重性问题，在过去的三年里提交的三个补丁都因为缺乏响应最终没有合并。这也导致不少用户被迫手动打补丁。<a href="https://issues.apache.org/jira/browse/FLINK-11937">FLINK-11937</a> 是另一个例子。两家员工提供了不同的方案，其中一方缺少社区话语权，无力单独推进合并，另一方有能力但是无意推进，也不允许其他人推进。同样的案例还有 <a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-44%3A+Support+Local+Aggregation+in+Flink">FLIP-44</a> 和 <a href="https://lists.apache.org/thread/snlsb5z9lcogdo7359dcwr4hn5qpymlo">Queryable State</a> 等等。</p>
<p>Flink 的例子其实证明了商业公司需要通过 fork 仓库的来应对商业需求。另外也可以看到这些讨论的发起人是如何被 stale bot 二次伤害的。</p>
<p>从开源协同的角度，contributor 不是程序，而是真实的人。上面提到的沟通手段，去掉公司员工的背景也同样适用。商业公司要做风险控制，开源社区也是一个组织，也可以做风险控制。只不过，开源社区是一个开放式组织。在这个环境下控制风险的手段不是管控，而是协同。前面讲到的文档和结构化的流程在这里同样可以起作用。信息在 contributor 之间自由流通，就不会有 FUD 产生的伤害。平时保持和其他 contributor 的联系，就能知道当前的工作最应该找谁一起做。</p>
<p>大部分情况下，contributor 是能够自我驱动和自我激励的。他们爆发出的创造力不可小觑。单就时间上的风险而言，如果你在开发文档里明确写下开发周期和发布模型，contributor 是乐于见到自己参与或主导开发的工作随新版本一起发布的。越是自我驱动参与开源社区的 contributor 越重视积累信誉。这个过程中，如果你作为 shepherd 指导或参与进去，只需要切实地关注和解决开发团队成员遇到的困难，并在需要时帮助他们管理好进度。</p>
<p>其他的沟通技巧和 maintainer 的最佳实践这里不再展开。Open Source Guides 提供了这个话题非常有益的补充，推荐延伸阅读。</p>
<ul>
<li><a href="https://opensource.guide/best-practices">Best Practices for Maintainers</a></li>
<li><a href="https://opensource.guide/leadership-and-governance">Leadership and Governance</a></li>
<li><a href="https://opensource.guide/building-community/#growing-your-community">Building Welcoming Communities</a></li>
</ul>
<h2 id="Have-fun"><a href="#Have-fun" class="headerlink" title="Have fun"></a>Have fun</h2><p>不论是 contributor 还是 maintainer 你都已经通过参与开源社区为社会创造出了价值。时不时想想你为什么要参与或维护这个项目，回顾这个项目已经取得的成就。你已经做得很好了。</p>
<p>软件都有自己的生命周期，开源软件也不例外。开源社区的工作也不是你生活的全部。如果你找到了新的乐趣，完全可以把项目交给其他 maintainers 维护，或者直接归档。如果开源项目的维护已经超出你的能力范围或者消耗了太多的时间精力，也可以休息一段时间甚至放弃对项目的维护。作为开源社区成员的你没有义务非得维护这个项目或者响应别人的请求。你把自己的工作自由的提供给其他人利用，已经创造了非常客观的价值。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>Protobuf Gradle Plugin 的用例</title>
    <url>/2022/03/08/gradle-protobuf/</url>
    <content><![CDATA[<p>近日尝试利用 <a href="https://github.com/apache/ratis">Apache Ratis</a> 这个项目包装一个 Raft 协议驱动的状态机的时候，遇到了需要用 Protobuf 传输数据的场景。由于 Gradle 构建工具的门槛和 Java 语言项目的某些惯例碰到了使用上的问题，这里记录一下我在这个玩具项目当中的用例。</p>
<span id="more"></span>

<p>首先介绍一下整个项目的主要目录结构，这里只包含最小复现需要的集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">project/proto/</span><br><span class="line">project/proto/RMap.proto</span><br><span class="line">project/build.gradle</span><br><span class="line">project/settings.gradle</span><br></pre></td></tr></table></figure>

<p>其中 <code>settings.gradle</code> 只有一行默认生成的 <code>rootProject.name = &#39;dryad&#39;</code> 信息，<code>RMap.proto</code> 是一个普通的不包含 gRPC 定义的 proto 文件。<code>RMap.proto</code> 文件内容如下</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;org.tisonkun.dryad.proto.rmap&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;RMapProtos&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_generate_equals_and_hash = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> dryad.rmap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetRequest</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> key = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetResponse</span> &#123;</span><br><span class="line">    <span class="type">bool</span> found = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> key = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> value = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">PutRequest</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> key = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">PutResponse</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要使用 <a href="https://github.com/google/protobuf-gradle-plugin">Protobuf Gradle Plugin</a> 的逻辑都在 <code>build.gradle</code> 文件里，文件内容如下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;com.google.protobuf&#x27;</span> version <span class="string">&#x27;0.8.18&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;com.github.johnrengelman.shadow&#x27;</span> version <span class="string">&#x27;7.1.2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    mavenLocal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">17</span></span><br><span class="line">targetCompatibility = <span class="number">17</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.google.protobuf:protobuf-java:3.19.2&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.apache.ratis:ratis-thirdparty-misc:0.7.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    protobuf files(<span class="string">&quot;proto/&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protobuf &#123;</span><br><span class="line">    protoc &#123;</span><br><span class="line">        artifact = <span class="string">&#x27;com.google.protobuf:protoc:3.12.0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shadowJar &#123;</span><br><span class="line">    configurations = []</span><br><span class="line">    relocate <span class="string">&#x27;com.google.protobuf&#x27;</span>, <span class="string">&#x27;org.apache.ratis.thirdparty.com.google.protobuf&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和构建工具采用的版本信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 7.4</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2022-02-08 09:58:38 UTC</span><br><span class="line">Revision:     f0d9291c04b90b59445041eaa75b2ee744162586</span><br><span class="line"></span><br><span class="line">Kotlin:       1.5.31</span><br><span class="line">Groovy:       3.0.9</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.11 compiled on July 10 2021</span><br><span class="line">JVM:          17.0.2 (Eclipse Adoptium 17.0.2+8)</span><br><span class="line">OS:           Mac OS X 10.15.7 x86_64</span><br></pre></td></tr></table></figure>

<p>这个用例当中有两个注意点。</p>
<p><strong>第一个注意点是 protobuf 的配置方式。</strong></p>
<p>可以看到在 <code>dependencies</code> 配置块中声明了 proto 文件的路径。我不记得是不是有默认的查询路径比如 <code>&lt;project&gt;/src/main/proto</code> 这样的，但是建议还是明确写出来为好，毕竟业界也没有什么公认的标准，每个插件工具的假设不一定采用同一套约定。</p>
<p>另外就是 <code>protobuf</code> 配置块中声明了 <code>protoc</code> 工具的版本。Protobuf Gradle Plugin 的<a href="https://github.com/google/protobuf-gradle-plugin#customizing-protobuf-compilation">官方文档</a>当中还介绍了如何整合 gRPC 等插件等控制 <code>protoc</code> 编译过程的方式。玩具项目当中不需要，因此略过。</p>
<p>最后是 <code>protoc</code> 和 <code>protobuf-java</code> 的版本不一样，如果还要引入 gRPC 的插件和 JAR 包依赖，还会有其他不一样的版本。这是因为 Protobuf 生态并不是整体同步发布的，而是各个组件很大程度上自主开发和发布的缘故。具体的兼容矩阵我没有研究过，但是一般来说锁定了某个版本就不太会轻易升级了。比如 Apache Hadoop 的 Protobuf 版本一直停留在 2.5.0 版本上。印象中 3.0 版本以后的兼容性还是比较好的，3.10+ 版本之间的升级还算顺滑。</p>
<p><strong>第二个注意点是 Gradle Shadow Plugin 插件的使用。</strong></p>
<p><a href="https://imperceptiblethoughts.com/shadow/">Gradle Shadow Plugin</a> 很大程度上是 <a href="https://maven.apache.org/plugins/maven-shade-plugin/">Maven Shade Plugin</a> 的同位替代。也就是说，服务于需要把依赖项一起打成一个大 JAR 包的场景。</p>
<p>通常来说，Maven 或 Gradle 项目打包的时候，依赖项都不会进入到最终产物当中。因为打包就只是对你写的这些代码编译出来的 class 文件打包，而不是像 C &#x2F; Rust 这种产生二进制可执行文件的思路。Java 语言程序运行起来，是需要程序员把所有的依赖项都写进 classpath 里，再指定要运行的类，执行其 Main 方法启动的。这种情况下打包不需要把依赖项都搭进去。</p>
<p>这种方案对于企业自己管理所有依赖，大部分软件是自包含少依赖的大型软件的场景是比较合理的。但是随着互联网的兴起和合作开发效率提升，一个项目依赖大量其他项目的情形越来越多，这些其他项目也有自己的开发周期，往往会产生多个版本的 JAR 包发布产物。这种情况下再要求程序员自己去管理依赖项，管理 classpath 的内容，在生产上就是既繁琐有不可靠的了。</p>
<p>因此，Gradle Shadow Plugin 和 Maven Shade Plugin 解决的问题就是把所有依赖在打包的时候也打进构建产物当中，产生一个 <code>project-all.jar</code> 文件。用户可以直接把这一个 JAR 包加入 classpath 就能保证所有的依赖都已经就绪。甚至在 MANIFEST 文件中写好默认的 MainClass 信息，就能通过 <code>java -jar</code> 命令将大 JAR 包以一种形如二进制可执行文件的方式运行起来。</p>
<p>不过，我们这里用上的不是打一个大 JAR 包的功能，而是在这个大需求下解决 package relocation 问题的功能。</p>
<p>Java 语言程序依靠全限定名来识别一个类，每个 ClassLoader 都对每个全限定名都只会加载一个类实例。如果 classpath 当中存在两个相同全限定名的类，那么根据 ClassLoader 的实现策略，可能会加载其中任意一个，或者报错。</p>
<p>对于服务端应用例如 Apache Flink 和 Apache Ratis 而言，它们自己需要依赖 protobuf 或 akka 等三方库，同时它们自己的用户也有可能依赖这些三方库，那么用户内部逻辑使用的三方库版本，跟用户逻辑需要跟服务端打交道时使用的三方库版本，就有可能在 classpath 当中同时存在。如果这两个版本不兼容，就会出现运行时错误。</p>
<p>由于服务端应用往往受众更广，通常来说解决方案是用户应用程序采用跟服务端相同的依赖版本。但是如果用户不是直接依赖跟服务端可能冲突的三方库，而是间接依赖，那么这个版本对齐的工作往往就很难做了。</p>
<p>另一种形式是形如 akka 生态当中的 play 框架，直接暴露操作 akka 底层数据结构的接口，用户自己不依赖 akka 而是通过 play 提供的接口使用 akka 的能力。但是这种形式只对 akka 和 play 这样由同一个团队开发的软件是比较合适的，放在更加复杂的开源软件生态当中就很难配合了。</p>
<p>因此从服务端的角度出发，为了避免用户遇到这一难题，一个彻底的解决方法就是 package relocation 更改自己依赖的三方库的全限定名。</p>
<p>比如上面 <code>build.gradle</code> 里配置项显示的</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">shadowJar &#123;</span><br><span class="line">    configurations = []</span><br><span class="line">    relocate <span class="string">&#x27;com.google.protobuf&#x27;</span>, <span class="string">&#x27;org.apache.ratis.thirdparty.com.google.protobuf&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着把所有 <code>com.google.protobuf</code> 的文本都替换成 <code>org.apache.ratis.thirdparty.com.google.protobuf</code> 的字样，也包括字符串当中的情况，以应对动态加载的用例。</p>
<p>这样，服务端最终打出来的 JAR 包里，使用的类全限定名就不是 <code>com.google.protobuf.Message</code> 而是 <code>org.apache.ratis.thirdparty.com.google.protobuf.Message</code> 了，这也就跟用户依赖的 <code>com.google.protobuf.Message</code> 不同，从而不会起冲突。</p>
<p>当然，这种 package relocation 不仅仅在服务端的使用上会改掉全限定名，也需要类的实现本身也是以新的全限定名来提供的。因此 Apache Ratis 项目提供了 <a href="https://github.com/apache/ratis-thirdparty"><code>ratis-thirdparty-misc</code></a> 库，Apache Flink 项目提供了 <a href="https://github.com/apache/flink-shaded"><code>flink-shaded</code></a> 库。其中的内容就是把服务端依赖的软件以 relocate 之后的名称重新发布。</p>
<p>对于这个玩具项目来说，它需要的是保持跟 Apache Ratis 服务端一样的 protobuf 依赖的全限定名，保证能够嵌入到 Apache Ratis 的服务端实现当中。对于其中的 proto 定义部分，它并不需要真的把依赖项也打进自己的 JAR 包里，这个打大 JAR 包的工作会交给最终的 dist package 完成。所以我们还需要把 Gradle Shadow Plugin 默认打入所有运行时依赖的行为变掉。这就是 <code>configurations = []</code> 一行起的作用，把打入最终 JAR 包的依赖项置空，这样就只会包含 proto 文件编译出来的 class 文件了。这样的用例，其实与 Maven Shade Plugin 的惯用法有较大的差别，更像是 <a href="https://code.google.com/archive/p/maven-replacer-plugin/">Maven Replacer Plugin</a> 的用法。</p>
<p>最后作为小 tip 值得一提的是，上面提到 package relocation “也包括字符串当中的情况，以应对动态加载的用例”。这其实导致了 akka 项目很难利用常规的 package relocation 插件来完成这个工作。惯例上，Java 语言项目的全限定名以域名开头，形如 <code>com.google.protobuf</code> 或 <code>org.apache.ratis</code> 等等。一般而言这种形式的字符串只会出现在类的全限定名当中。然而，akka 作为一个 Scala 项目采用了 <code>akka.actor</code> 形式的全限定名前缀。不幸的是，这种前缀模式跟 akka 的配置项是重叠的。这就导致 package relocation 会同时改变配置项的名称。这其实不是我们想要的，因为这样用户也要跟着改配置项的名称才能跟 relocate 之后的 akka 库交互，这通常来说是非常难做到并且与大部分开发者的直觉和生态项目的假设是冲突的。</p>
<h2 id="20220626-更新"><a href="#20220626-更新" class="headerlink" title="20220626 更新"></a>20220626 更新</h2><ol>
<li>这样 relocated 以后的结果，只会体现在本仓库再次被依赖时。因为 shadowJar 作业发生在打包阶段，因此如果在同一个包内使用 Protobuf Plugin 生成的类，此时依赖的还是 relocated 前的全限定名。</li>
<li>多模块的 Gradle 项目中，一个子项目依赖 shadowJar 产生的另一个子项目需要形如 <code>implementation project(path: &#39;:foo-proto&#39;, configuration: &#39;shadow&#39;)</code> 的语法。</li>
<li>如果使用 Intellij IDEA 来开发，需要在 <code>build.gradle</code> 里加载名为 <code>idea</code> 的 Gradle Plugin 才能正确索引 Protobuf Plugin 生成的文件。</li>
</ol>
<p>具体可以参考在线的完整案例 <a href="https://github.com/korandoru/dryad">Dryad</a> 仓库。</p>
]]></content>
      <categories>
        <category>天工开物</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Java</tag>
        <tag>Protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 是怎么工作的？</title>
    <url>/2022/04/15/how-cmake-works/</url>
    <content><![CDATA[<blockquote>
<p>关于开源软件的发布相关的内容还在构思当中，先摆烂重发部分以前讨论过的关于构建系统的文章。构建和发布密不可分，可以认为都是持续交付流水线的一环。</p>
<p>我会分多篇文章讨论软件发布和开源软件发布的各个方面，文章内容再加以提炼放到编撰当中的《开源指南》里。</p>
</blockquote>
<p>构建系统是软件开发的重要组成部分，生产环境中的绝大多数软件都由多个组件所组成，由一系列依赖和分散的编译单元聚合而成，而自动化这些组件的集成的系统，就是构建系统。</p>
<p>笼统地说，构建系统负责除了应用代码编写以外的，所有从代码到可执行文件的步骤的自动化。其中，查找、编译和链接等具体执行由其他工具支持。构建系统本身处理的内容分为两大部分，第一部分是构建过程各个步骤的编排，第二部分是包管理或说第三方依赖管理。这两者的区别可以参考 Java 生态中 Ant 和 Ivy 的区别和联系。狭义的构建系统仅包括第一部分，因为狭义的构建过程只关心有某种方法可以取得依赖并将其引入构建，而不关心依赖本身是怎么管理和获取的。</p>
<p>那么，本文主角 CMake 是哪一种或者两者都是呢？</p>
<span id="more"></span>

<h2 id="CMake-是构建系统生成器"><a href="#CMake-是构建系统生成器" class="headerlink" title="CMake 是构建系统生成器"></a>CMake 是构建系统生成器</h2><p>CMake 两者都不是，作为 C&#x2F;C++ 生态构建系统事实标准的 CMake 其实是一个构建系统生成器。CMake 的主要功能是描述项目结构，表达模块依赖，从而以人类友好的方式表达构建过程步骤编排的需求，最终从声明式的 CMake 代码中生成实际的构建系统，比如生成一系列 GNU Make 构建需要的文件。</p>
<p>举个例子，假设我们有一个 hello world 代码文件 main.cpp 和对应的 CMake 项目描述文件 CMakeLists.txt 如下。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ (root) tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── main.cpp</span><br><span class="line">$ (root) cat CMakeLists.txt</span><br><span class="line">cmake_minimum_required(VERSION 3.19)</span><br><span class="line">project (hello_cmake)</span><br><span class="line">add_executable(hello_cmake_exe main.cpp)</span><br><span class="line"></span><br><span class="line">$ (root) mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make</span><br><span class="line">$ (root/build) ls</span><br><span class="line">CMakeCache.txt      Makefile            hello_cmake_exe</span><br><span class="line">CMakeFiles          cmake_install.cmake</span><br><span class="line">$ (root/build) ./hello_cmake_exe</span><br><span class="line">Hello CMake!</span><br></pre></td></tr></table></figure>

<p>可以看到，CMakeLists.txt 里关键的内容是 add_executable 一行。这行表达了我们希望在项目中创建一个名为 hello_cmake_exe 的可执行文件，它的构建要素是 main.cpp 文件。</p>
<p>我们通过 <code>cmake</code> 命令在当前目录下创建了 GNU Make 构建需要的 Makefile 文件及其依赖，随后执行 <code>make</code> 命令实际完成构建。</p>
<h2 id="CMake-围绕构建目标声明"><a href="#CMake-围绕构建目标声明" class="headerlink" title="CMake 围绕构建目标声明"></a>CMake 围绕构建目标声明</h2><p>刚开始接触 CMake 的同学往往会被它茫茫多的指令吓到，尤其是神秘的结构化语法、没有命名规律的声明、不知所云的参数列表和复杂的命令行参数，让人不知道从何入手。</p>
<p>其实，CMake 尤其是现代化的 CMake 核心是围绕构建目标来组织声明，上一节例子中 add_executable 一行里的 hello_cmake_exe 就是一个构建目标。此外，add_library 定义的库也是一种构建目标。可执行文件和库是构建最终对用户可见的产物，CMake 对项目模块依赖的声明就是围绕着这两种目标来展开的。</p>
<p>add_executable 和 add_library 的第一个参数说明了构建目标的名称，它必须是全局唯一的符号，并且随后全局可访问；紧跟着是各自专有的控制参数，例如可以指定库是静态链接还是动态链接等；再之后是一个可变长度的源文件数组，用于描述直接参与构建当前目标的源文件。</p>
<p>CMake 的声明参数是一系列空格隔开的符号或字符串，同时每个命令都可以有自己的参数列表，这些参数列表没有统一的风格，同时仅通过位置区分而没有命名参数，可以说是 CMake 最为用户不友好的一点了。</p>
<p>定义了构建目标之后，就是描述构建目标的各种特性。上面两个命令列出了构建目标所需的源文件，但是还有链接时的库依赖，这就需要 target_link_library 来声明目标构建依赖的库。构建目标可以是 add_executable 或 add_library 声明的，库可以是 add_library 声明的构建目标，也可以是库文件等。</p>
<p>此外，构建目标可能还需要包含头文件等 include 预编译命令依赖的文件，除了在 add_executable 和 add_library 中加入以外，还可以随后通过 target_sources 逐个包含，或者更常见的，通过 target_include_directories 包含目录下的文件。</p>
<p>最后，构建目标在编译时还可能有一系列编译选项和宏定义等，可以通过 target_compile_options 和 target_compile_definitions 来声明。</p>
<p>可以看到，链接、文件包含和编译选项的命令都以 target_xxx 的形式出现，第一个参数是 add_executable 或 add_library 声明的构建目标。这就是现代化的 CMake 围绕构建目标声明的含义。</p>
<p>值得一提的是，旧版的 CMake 不支持 target_xxx 形式的命令，而是通过不带 target_ 前缀的命令来表达相似的含义，但是旧版的命令是通过修改全局状态和获取全局状态来声明的，而非按照构建目标所构成的命名空间区分开的。举例来说，include_directories 命令将导致之后及子项目中的所有构建目标在编译时都带上此命令引入的路径下的文件。显然，这很容易导致声明的泄漏，尤其在项目层次复杂，引入其他子项目或作为子项目被其他项目引入时，容易出现难以排查的非预期构建结果，也就限制了项目规模的扩大。</p>
<p>现代 CMake 的最佳实践是牢记围绕构建目标组织声明，不仅能避免意外的声明泄漏，还能获得更好的表达力。</p>
<h2 id="CMake-灵活地支持三方库"><a href="#CMake-灵活地支持三方库" class="headerlink" title="CMake 灵活地支持三方库"></a>CMake 灵活地支持三方库</h2><p>一开始我们就提到，广义的构建系统包括三方库的依赖管理。即使是狭义的只处理构建步骤编排的构建系统，也需要有某种方式引入三方库的依赖。</p>
<p>程序设计实践发展至今，引入三方库依赖的方式无非是 systemwise 安装依赖，vendor 方式携带依赖和利用依赖管理系统的接口与专门的依赖管理系统协作。CMake 支持以上三种形式的三方库依赖引入方式，并且抽象了自己统一的 find_package 接口。</p>
<p>我们先介绍 find_package 接口，它的主要使用形式如下。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">find_package(&lt;PackageName&gt; [version] [REQUIRED] [[COMPONENTS] [components...]])</span><br></pre></td></tr></table></figure>

<p>后面都是可选项，最基础的使用形式就是 find_package 加一个 PackageName 信息。CMake 会在约定路径和通过选项指定的路径下搜索名为 FindPackageName.cmake 的文件，并执行其中的逻辑以设置一些关键的变量。约定的 PackageName_FOUND 标识是否找到对应的依赖以进行差别处理逻辑，其他的变量则根据不同 FindPackageName.cmake 的策略有所不同，通常包括该依赖暴露的头文件信息，可供链接的库的信息，以及库的构建目标等等，并可能按照模块进行划分以获得更细粒度的导出控制。</p>
<p>不少成熟的三方库都得到了 CMake 的原生支持或者提供了可移植的 Find 脚本，例如 Protobuf 和 Boost 等。这些 Find 脚本通常被写成仅搜索系统级路径的形式，也就是原生支持了查找 systemwise 安装的第三方依赖的方法。换个角度看，也就是把 <code>/usr/</code> 和 <code>/usr/local/</code> 等经典安装路径等同于 Maven 当中的 <code>.m2</code> 路径来处理。</p>
<p>然而，systemwise 的方式对运行环境的侵入性明显，很容易影响 PATH 环境变量和实际使用的三方库，同时容易产生难以解决的版本冲突问题。通常只在临时开发或者隔离性较强的容器环境中才考虑采用这种方法。</p>
<p>为了避免 systemwise 的安装依赖，另一种方案是 vendor 方式携带依赖，也就是常说的 third party 或 contrib 或 submodule 等等。ClickHouse 重度使用了这种模式，几乎 vendor 了它的所有依赖。C &#x2F; C++ &#x2F; Scheme 广泛流行的库通常也是通过此种形式来组织的，Go 语言在 go mod 面世之前乃至现在都广泛使用了 vendor 的依赖引入模式。</p>
<p>具体地说，vendor 的含义就是依赖库和根项目在源代码层面一起分发，从而在下载根项目源代码时同步就绪了所有依赖库的代码。前面提到原生的 Find 脚本通常只搜索系统级路径，因此 vendor 通常也需要手动编写 CMake 脚本引入依赖项的问题。</p>
<p>最理想的情况是三方库已经充分考虑了作为子项目被外部引入的情况，例如 GoogleTest 或 gRPC 等。它们在项目的根目录下有 CMakeLists.txt 文件来定义和导出项目的构建目标和头文件、静态链接库等信息，只需要在父项目中通过 add_subdirectory 声明引入三方库，就可以在 CMake 的解析框架下导出所有需要的符号。</p>
<p>然而，现实往往是更复杂的。有些三方库未曾想过跟其他项目协作，有些三方库并不支持 CMake 或者实现的 CMake 脚本有问题，例如典型的 Poco 项目的 ENABLE_TESTS 选项命名很容易冲突，又未启用相应的 CMake Policy 以允许上层临时屏蔽选项。诸如此类的细节问题常常引出难以排查的非预期构建结果，所以富余人力的项目研发团队倾向于撰写一个轻量级的 CMake 层来管理三方库。</p>
<p>典型的例如 ClickHouse 项目，它几乎对所有的项目都配备了一组 CMake 脚本，并且精心裁剪了依赖库的文件，仅保留构建相关的文件。在根项目的 CMake 文件中，通过 include 执行来执行这组配置三方库依赖的 CMake 脚本，从而达到和 find_package 或者丝滑的 add_subdirectory 类似的符号导出效果。</p>
<p>不过，上面提到的手写 CMake 脚本跟直接调用 find_package 的方式并不冲突，从导出符号的角度看，效果是一样的。但是，我们还能做得更加一致，即利用 find_package 提供的机制，将 vendor 的依赖作为 systemwise 依赖的前置或后置候选被挑选和导入。通过自定义 Find 脚本的逻辑，兼容 systemwise 的引入方法，再修改 CMake 查找 Find 脚本的配置，就可以实现 CMake 脚本里一致的使用 find_package 声明来引入三方库依赖了。</p>
<p>最后讨论的引入三方库依赖的方式是与其他专门的依赖管理系统协作，例如 vcpkg 或 conan 等。这两者都有自己的中央仓库，类似于 Maven Central 或 JCenter 等，来管理三方库，包括版本、平台、名称和库的具体内容等。</p>
<p>vcpkg 通过 CMake 原生的 TOOLCHAIN 机制 Hook 了 CMake 执行前的阶段，以配置好 CMake 随后 find_package 的环境从而能够正确的找到依赖。conan 则在 CMake 对构建系统的一层抽象的基础上再做一层抽象，支持生成 CMake 生成构建系统所需要的文件，加一层套娃，在生成 CMake Binary 路径的内容的时候把依赖库的内容也拷贝过去支持 CMake 索引到。</p>
<p>可惜由于 C++ 的跨平台构建太过复杂，并且一直以来的习惯都是 vendor + 魔改三方库，因此这两种已经是最流行的专门的依赖管理系统并没有大范围的获得采用。</p>
<p>顺带一提，CMake 本身还提供了 ExternalProject 和 FetchContent 等内容来支持 vendor 以外的模式，在生成构建系统期间拉取或者根据配置寻找三方库依赖并复制到构建路径下，最终以相对路径生成构建系统文件。不过这两个方案非常难用，而且没有类似于 <code>.m2</code> 或 <code>.ivy</code> 这样全局的依赖管理目录，其实每次构建的时候还是要每项目的重新拉依赖，比起 vendor 来说并不少多少力气，反而失去了 vendor 魔改的灵活性。实际采用的人少之又少。</p>
<h2 id="CMake-新时代的最佳实践"><a href="#CMake-新时代的最佳实践" class="headerlink" title="CMake 新时代的最佳实践"></a>CMake 新时代的最佳实践</h2><p>上面只讨论了 CMake 的两个最为关键且值得的内容，其他诸如指定 CMake 版本、指定 C++ 标准兼容、设置 CMake Policy 开关、添加变量和定义宏及函数等等内容，要么非常显而易见，要么比较少见，需要的时候自然可以弄懂，不做过多展开。</p>
<p>文字的讨论只是帮助厘清概念和建立感性认识，CMake 作为构建系统还有丰富的细节，熟悉实际系统也需要从实践出发。CMake 介绍的最后附上我在接触这个构建系统的过程中最受启发的几份最佳实践的材料。</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=bsXLMQ6WgIk">Effective CMake - a random seletion of best practices</a>(<a href="https://github.com/boostcon/cppnow_presentations_2017/blob/master/05-19-2017_friday/effective_cmake__daniel_pfeifer__cppnow_05-19-2017.pdf">slides</a>)</li>
<li><a href="https://www.youtube.com/watch?v=eC9-iRN2b04">Using Modern CMake Patterns to Enforce a Good Modular Design</a>(<a href="https://github.com/CppCon/CppCon2017/blob/master/Tutorials/Using%20Modern%20CMake%20Patterns%20to%20Enforce%20a%20Good%20Modular%20Design/Using%20Modern%20CMake%20Patterns%20to%20Enforce%20a%20Good%20Modular%20Design%20-%20Mathieu%20Ropert%20-%20CppCon%202017.pdf">slides</a>)</li>
</ul>
<p>这两个演讲和 Slides 是近年来比较有代表性的讲 Modern CMake 的材料。不多说，主要也是围绕构建目标和模块化项目来介绍的。</p>
<ul>
<li><a href="https://github.com/ttroy50/cmake-examples">CMake Examples</a></li>
</ul>
<p>简练又恰到好处的 CMake 实例，新手跟着实践一遍 01 和 02 就差不多了，其他的可以按需阅读。</p>
<ul>
<li><a href="http://www.aosabook.org/en/cmake.html">How CMake Is Implemented</a></li>
</ul>
<p>CMake 实现上的原理，包括解析声明和生成构建系统的步骤以及一些执行细节，富有黑客精神的同学可以看一看。</p>
]]></content>
      <categories>
        <category>天工开物</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>软件构建</tag>
      </tags>
  </entry>
  <entry>
    <title>企业实践开源的动机</title>
    <url>/2022/05/26/motivation-of-enterprise-open-source/</url>
    <content><![CDATA[<p>随着开源软件全面占据软件供应链的各个阶段，商业公司开发基础软件或业务逻辑的时候，已经避不开对软件的使用了。经过一段时间对开源软件的使用，以及开源吞噬软件的趋势影响，研发能力突出的公司或团队，也会加入到开发开源软件的行列中来。</p>
<p>商业模型当中开源软件位置的不同，体现出企业实践开源动机的不同，并且会很大程度影响企业实践开源的行为。本文将讨论不同商业模型下，企业实践开源的动机和行为的差异。</p>
<span id="more"></span>

<h2 id="商业模型是销售开源软件"><a href="#商业模型是销售开源软件" class="headerlink" title="商业模型是销售开源软件"></a>商业模型是销售开源软件</h2><p>第一类商业模型是直接销售开源软件。这种类型的企业以 <a href="https://www.mongodb.com/">MongoDB Inc.</a> 和 <a href="https://www.elastic.co/">Elastic</a> 为代表，是在 2010 年以后逐渐兴起的企业类型。</p>
<p>不过，说它们是“销售开源软件”也不准确。虽然在早期它们的商业产品是直接提供当时还是开源软件的 <a href="https://github.com/mongodb/mongo">MongoDB</a> 和 <a href="https://github.com/elastic/elasticsearch">ElasticSearch</a> 本身，但是随后由于源代码免费可得，包括 AWS 在内的云厂商直接利用免费的源代码在平台上提供同类的服务，这样的新形势使得这两家公司前后把软件协议改成 <a href="https://www.mongodb.com/licensing/server-side-public-license">Server Side Public License (SSPLv1)</a> 和 <a href="https://www.elastic.co/licensing/elastic-license">Elastic License (ELv2)</a> 来对抗商业竞争。</p>
<p>其中 ELv2 是明确的专有软件协议，禁止其他人提供同类的服务，也不允许破解付费密钥锁定的高级功能。SSPLv1 是对 GPL 系列许可的发展，但是要求与 MongoDB 一同构成服务的所有软件都需要按照 SSPLv1 协议发布，即包括开放源代码，这一点超出了 OSI 推出的<a href="https://opensource.org/osd">开源定义</a>第九条“协议不应该限制其他软件”的原则。实际执行过程中值得注意的是，MongoDB Inc. 采用 SSPLv1 的动机是对抗商业竞争，它同时鼓励用户购买企业提供的以专有软件协议发布的 MongoDB 以避免 SSPLv1 的要求。这种行为的动机与自由软件基金会制造的软件纯粹是为了让所有人能够自由地使用高质量的软件的初衷非常不同。因此，我并不将这样重新许可后的软件认为是开源软件，而是源码公开的专有软件。关于不同开源协议的讨论，我在<a href="https://mp.weixin.qq.com/s/6a5MsWcTn9PUAT4WJPhVcg">《选择开源许可证》</a>一文里有详细地展开。</p>
<p>无独有偶，曾经试图通过销售开源软件的公司，最终都走上了重新许可成源码公开的专有软件的路。</p>
<ul>
<li><a href="https://www.mongodb.com/licensing/server-side-public-license/faq">Why are we changing the license for MongoDB?</a></li>
<li><a href="https://www.elastic.co/blog/licensing-change">Upcoming licensing changes to Elasticsearch and Kibana</a></li>
<li><a href="https://www.cockroachlabs.com/blog/oss-relicensing-cockroachdb/">Why We’re Relicensing CockroachDB</a></li>
<li><a href="https://airbyte.com/blog/a-new-license-to-future-proof-the-commoditization-of-data-integration">A New License to Future Proof the Commoditization of Data Integration</a></li>
</ul>
<p>另一方面，越来越多的技术创业公司难以抵挡“开放源代码”的潮流和用户与开发者心理预期的转变，又清晰地理解了自己的商业模式就是销售将要开放源代码的这个软件本身，因此它们一开始就选择了源码公开的专有软件协议来禁止其他厂商直接利用公开的源代码销售同类服务开展竞争。</p>
<ul>
<li><a href="https://mariadb.com/bsl11/">Business Source License 1.1</a></li>
<li><a href="https://mariadb.com/projects-using-bsl-11/">MariaDB Projects using BSL 1.1</a></li>
<li><a href="https://github.com/MaterializeInc/materialize/blob/main/LICENSE">Materialize is licensed under the Business Source License agreement</a></li>
</ul>
<p>这种商业模式，本质上是 MongoDB Inc. 前任 CEO 所宣称的“免费增值”策略，即在不产生商业竞争的情况下，或者说对于用户，可以免费地使用该软件。等到用户深度参与之后，产生运维支持的需求，或者定制开发尤其是商业软件集成的需求，再转向唯一的供应商 MongoDB Inc. 付费获得支持。</p>
<p>我认为这种模式是说得通的，是一个好的市场营销手段。但是它与自由软件运动和开源运动的理念都是相违背的。</p>
<p>自由软件运动的理念是所有软件都应该能够被所有人自由地用于所有用途，显然用于提供托管服务就是其中一种用途，而上述软件协议不允许任何形式地提供同类托管服务。另一方面，自由软件运动的起源之一是 <a href="https://stallman.org/">Richard Stallman</a> 在打印机软件出现故障时无法取得源代码修复并重新编译和使用的痛苦。ElasticSearch 以付费密钥锁定的功能，是不是用户也需要的功能呢？如果我开发了同样的功能并且发布了，这里是否会产生破解的嫌疑呢？</p>
<p>开源定义（OSD）下的开源运动也包括了不限制用途和不限制其他软件的要求。进一步的，以 Apache 软件基金会为代表的开源世界，努力生产开源软件的基础是为了让所有潜在的参与者和用户平等地使用开源软件和参与开发。上述源码公开的专有软件，几乎只有相应商业公司的成员才能开发核心代码，并且解决的需求也是其客户提交的需求，随后进行商业交付。如前所述，如果有一个开发者完成了商业公司提供的付费功能并且期望合并到上游发布，上游会接受吗？</p>
<p>不过，抛开以专有协议许可的核心部分不谈，这些企业共同选择了在生态连接所需要的接口和模块方面，采用宽容的开源协议例如 Apache 2.0 或者 MIT 来许可。尤其是 Airbyte 提出的核心以 ELv2 许可的软件及其相应协议的模型，对于 CLI 和 Connector 等部分，都是开源软件。</p>
<img src="/2022/05/26/motivation-of-enterprise-open-source/airbyte-components-license-model.png" class="" title="Airbyte 的软件协议模型">

<p>如果把源码公开的专有协议部分视作商业软件而非传统意义上的开源软件，那么这种形式与接下来要讨论的依托于开源软件的商业模型就有很大的相似性了。只不过，当下的市场没能很好地区分开开源软件和源码可得的专有软件。如果一个企业的商业模型就是销售“开源”软件本身的功能，例如前面提到的 MongoDB Inc. 和 Elastic 还有 CockroachLabs 这样的，那么他们的核心功能转向专有软件只不过是时间问题，或者说只要面临商业竞争，就是经不起挑战的。</p>
<p>对于这样的企业来说，它的核心软件只能依靠自己开发，是不可能大范围地借助开源协同的力量完善和覆盖尽可能多的场景的。而且由于商业上的排他性，其他得到资本支持的研发团队也很难直接参与到开发中来。这样的软件与过去的专有软件，都会在开源吞噬软件的浪潮下最终被取代。关于开源吞噬软件在工程上的论证，<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>一书当中的 2.12 节《管理与马奇诺防线》有详细地论证。</p>
<p>这类商业模型的企业制造的软件生态当中可能出现的协同，也局限于用户在没有其他开源软件选择的时候，根据自己的需要和上游以开源软件开发的组件的情况，相应的做一些补充。例如 Airbyte 支持其他数据源的导入，例如 GitHub 其实是个专有软件，但是在 <a href="https://github.com/octokit/">toolkit</a> 和 <a href="https://github.com/actions/">actions runner</a> 以及 <a href="https://github.com/cli">gh cli</a> 等方面公开了相应的开源组件，这些组件也能得到开源社群的助力。</p>
<h2 id="商业模型依托于开源软件"><a href="#商业模型依托于开源软件" class="headerlink" title="商业模型依托于开源软件"></a>商业模型依托于开源软件</h2><p>第二类商业模型是依托于开源软件构建商业产品。其实，在开源软件占据软件供应链各个环节的背景下，任何商业模型的依赖路径上存在计算机软件的，基本都会部分依赖于开源软件。当然，我们这里主要讨论的情形，是依赖深度较短的订阅咨询和解决方案的模型。这两者不是互斥的，往往一个企业会同时发展这两方面的商业产品和技术支持。</p>
<p>侧重订阅咨询的商业公司里，有名的包括<a href="https://www.redhat.com/en">红帽</a>、收购红帽的 <a href="https://www.ibm.com/services/technology-support/open-source">IBM</a> 和收购了 Pivotal 的 <a href="https://tanzu.vmware.com/open-source">VMware Tanzu</a> 实验室。</p>
<p>这三家公司都是 Kubernetes 的重要参与者，提供类似于 Kubernetes 发行版的云平台 PaaS 订阅服务。红帽还以提供 Linux 发行版和技术支持闻名，VMware 则有 Spring 这个 Java 生态的杀手级开发框架背书。在 IBM 的开源软件技术支持列表里，涵盖了从应用开发栈、数据平台、云平台到 DevSecOps 等领域的一系列知名开源软件。</p>
<p>开源软件的源代码是公开且免费可得的，任何用户都能够自由编译、演绎和使用在任何场景下。但是，经过几十年软件行业的发展，以及社会生活数字化的浪潮，现在广泛被使用的开源软件已经复杂到没有经过专门的训练和经验积累，很难应对形形色色的业务需求。21 世纪最难得的真的是人才，上面提到的这些企业通过建立起开源社群当中属于自己的品牌，以及提供良好的工作环境吸引到高水平的软件开发人员，从而能够提供这些广泛存在于其他商业公司软件供应链上的核心开源软件的支持和订阅服务。</p>
<p>例如，红帽工程师耗费两年的时间打造了 <a href="https://vertx.io/">Vert.x</a> 反应式应用开发框架，并捐赠到 Eclipse 软件基金会共同创造出一个新的应用开发生态。厚积薄发，经过两年的设计开发和红帽客户资源增益的打磨，一个全新的开源软件和基于这个开源软件提供技术支持和订阅服务的商业模型正式成功上线。又例如，Pivotal 早在 2003 年就开始基于 PostgreSQL 开发 <a href="https://greenplum.org/">Greenplum</a> 大规模并行处理系统，这个系统在经受 Impala 和 ClickHouse 等等后起之秀在十年之后的挑战之前一直代表相关领域的先进生产力。IBM 和 VMware 则是以收购见长，将这些已经成功走出订阅咨询路线的商业公司并入自己的企业服务版图，从而提供像上面 IBM 的开源技术支持那样全方位的服务。</p>
<p>阿里云、腾讯云和 AWS 等云厂商在其公有云平台上提供的开源软件托管服务，则是介于订阅和解决方案之间的商业模型。它们既有利用自己公有云平台和机器资源的优势，提供分毫未改的与开源软件相同的 API 的托管服务，例如 RDS 和 Redis 服务，也有发挥基础软件团队研发能力进行二次开发，产品能力升级或场景化定制的商业软件，例如 Ververica Platform 和 Tair 等等。</p>
<p>当然，售卖开源软件托管服务不是大型云厂商一家的专利。<a href="https://upstash.com/">Upstash</a> 和 <a href="https://www.datastax.com/">Datastax</a> 都捕捉到了关系型数据库以外，数据平台对 NoSQL 数据库在 KV 类型和消息系统类型的需求，分别基于 Redis + Apache Kafka 和 Apache Cassandra + Apache Pulsar 搭建了自己的托管服务。由于依赖的软件属于 Apache 软件基金会或其他第三方组织，即使这些企业接近于直接销售开源软件，但是也无法重新以专有协议许可，因此这些企业被迫会转向上面提到的订阅模型，或者这两家企业选择提供上述开源软件全球可用和高效治理的服务，以此来产生自己的附加值。</p>
<p>这种附加值可以认为是一个企业级的解决方案，选择了 Upstash 的 Redis 服务，就可以获得在欧洲、北美、南美和东南亚都符合当地合规要求的开箱即用的 Redis 接口。另一方面，可以认为是企业基于自己对企业软件生态的理解，提供的一套方法论。例如上一段提到这两家公司是组合了 KV + Messaging 的接口提供服务，认为这两者合作就能解决业务在边缘场景下的数据存储和上报消费的需求。</p>
<p>基于 <a href="https://github.com/trinodb/trino">Trino</a> 分布式 SQL 查询引擎的公司 Starbrust Data, Inc. 全力推广 <a href="https://www.starburst.io/learn/data-fundamentals/what-is-data-mesh/">Data Mesh</a> 的概念，基于 <a href="https://shardingsphere.apache.org/">Apache ShardingSphere</a> 的公司 SphereEx 则全力推广 Database Plus 和 Database Mesh 的概念。这都是商业公司以开源软件为核心，打造出的一套有商业差异化的企业软件生态最佳实践或者叫方法论。只要你信了这套方法论，以同样的架构，同样的开源软件为核心搭建企业的软件生态，那么进一步产生付费，支持这一生态的顺利和高效运转，就是顺理成章的了。</p>
<p>彻底以产品化的解决方案来封装开源软件提供商业价值的模式，典型的企业包括 <a href="https://databricks.com/">Databricks</a> 和 <a href="https://www.tetrate.io/">Tetrate</a> 以及 <a href="https://www.firebolt.io/">Firebolt</a> 等等。</p>
<p>说起 Databricks 这家公司，很容易想到的是他们的早期核心团队制造的 Apache Spark 开源软件。不过，Spark 早在核心团队还在大学实验室的时候就捐赠给了 Apache 软件基金会，因此同样改变软件协议来排他的销售软件是行不通的。Databricks 首先提供了具有明显性能优势的 Databricks Runtimes 产品，为对性能有极致追求的客户提供一个商业选择。然而，这样的用户毕竟是少的。于是 Databricks 开始了场景化的尝试，包括面向机器学习场景的 MLlib 和一系列的商业产品，包括面向一站式数据处理的 Delta Live Table 等组件，以及类似于上面提到的 Data Mesh 这样方法论的 LakeHouse 方法论与它的 <a href="https://delta.io/">DeltaLake</a> 核心软件。</p>
<p>今天打开 Databricks 的官网，可以看到它早已在 Apache Spark 的基础上，长出了丰富的面向不同领域场景，面向不同用户案例和面向不同客户画像提供的一系列丰富的解决方案。构成这些解决方案的基础是 Apache Spark 丰富的生态，以及与开源的 DeltaLake 一脉相承的数据湖系统。在 Apache Spark 的名义下，在捐赠给 Linux Foundation 的 DeltaLake 的名义下，在 Databricks 官方 GitHub 组织的名义下，有着上百个连接数据平台开源共同体的开源软件。Databricks 在此之上又开发了面向不同场景不同解决方案需求的专有软件和商用代码，从而支撑起了自己的商业模型。</p>
<p>同样的，Tetrate 旨在提供云原生应用的网络治理方案。<a href="https://www.tetrate.io/open-source-contributions/">Tetrate 重度参与</a>了 Istio 和 Envoy 以及 Apache SkyWalking 等开源项目的开发，雇员当中不乏相应社群的维护者乃至创始人。然而这家公司从未以相关开源社群所谓“背后的商业公司”自居，而是清晰地认识到自己的商业模式是依托于这些开源软件，提供自己定位在云原生应用的网络治理方案上所需的专有软件和企业级解决方案。Tetrate 有自己的 Istio 发行版，以在上游激进的发布模型之外为商业用户提供稳定、经过测试、高度兼容且 Tetrate 提供技术支持的 Istio 版本。此外，Tetrate 提供了 Tetrate Service Bridge 一揽子解决方案，在 Service Mesh 的方法论体系下支持客户将应用部署起来并完整监控和高效治理。</p>
<p>上面两个例子当中，Databricks 的工程师还有相当部分投入到 Apache Spark 和 DeltaLake 以及其他公司发布的开源软件的开发迭代，Tetrate 更是鼓励乃至促使重度参与提到的三个开源社群当中。Firebolt 的例子会有所不同，它很大程度上是作为 ClickHouse 的下游存在，极少参与上游开发。</p>
<p>Firebolt 仅将 ClickHouse 作为自己的计算执行引擎，在这一选型之外，完全专有化的实现了前台管控、集群管理和元数据管理、查询优化、数据索引和面向云存储的访问层。这样的商业模型也是依托于开源软件的，但是其依赖深度已经处于临界值。例如某些完全闭源的 Java 开发的专有软件，其中的网络模块也有可能使用开源软件 Netty 来实现，但是这种情形下，恐怕就不是我们这里所想讨论的企业实践开源的商业模式了。</p>
<img src="/2022/05/26/motivation-of-enterprise-open-source/firebolt-architecture.png" class="" title="Query Engine 起初完全就是 ClickHouse">

<p>Firebolt 这样的选型也算是自然的。如果你回顾 Databricks 的发展历程，它实际上可以被认为是选择了 Apache Spark 作为自己的计算执行引擎，逐渐发展出场景化的解决方案和 LakeHouse 一站式数据处理平台。不过，Databricks 的方向是逐渐走向开源。利用自己的先发优势，赚到行业内唯一提供商的收益以后，逐渐将自己的能力开源出来，以形成强凝聚力和活力的生态。这在下一节“开源标准以保护现有软件”会展开讨论。</p>
<p>反过来看 Firebolt 的做法，ClickHouse 在 fork 以后已经经历过闭源魔改，我相信时至今日它还是不是 ClickHouse 已经不好说了。Firebolt 也没有任何参与开源社群的征兆。因此我认为它会成为一个传统的商业软件公司，并在数据处理领域的开源浪潮下被吞噬。或许另一个世界当中的 Firebolt 走的是积极与上游协同的路线，共同发展 ClickHouse 的计算模块，并且在逐渐扩大自己商业版图的过程中把访问云存储的技术开源，查询优化和集群管理也开源，成为另一个行业标准的制定者。</p>
<p>回顾上一节当中我提到如果把源码公开的专有软件这一部分就明确认知成专有软件，上一节当中提到的商业公司也有形如 Databricks 和 Firebolt 这样不同的倾向性。虽然我相信开源运动持续下去，开源理念深入人心，因为高校研究突破也好，因为面向消费者的企业开源基础架构组件也好，因为下一节中要讨论的保护现有软件因此开源抢占标准也好，目前存在的所有专有软件，都会被开源软件所替代。</p>
<p>但是到那个时候，又会有新的商业需求产生，这些需求被开源运动的创造力满足的时间差，是存在提供解决方案的窗口的。世界之大，无奇不有，各种定制化的需求可以是非常特殊或小众的，而开源软件往往只解决主要问题和部分场景。另一方面，数字化进程大跨步前进，哪怕开源软件理论上能够解决好一个问题，但是实际实施的时候，仍然需要专家技术支持，并且维护后续迭代当中可能出现的问题。订阅咨询和解决方案这样依托于开源软件的商业模式，是能够长期存在的。</p>
<h2 id="开源标准以保护现存业务"><a href="#开源标准以保护现存业务" class="headerlink" title="开源标准以保护现存业务"></a>开源标准以保护现存业务</h2><p>这种动机只有当企业成长到一定规模的时候才会产生，到这个时候，企业的商业模型往往已经非常复杂，甚至并不只是依靠软件服务来盈利。这种情形可以认为是上一节“商业模型依托于开源软件”的变体，即企业软件生态当中错综复杂地依赖了一系列开源软件，继而主要出于保护现存业务，顺带扩大技术影响力，来以开源软件协议公开企业内部的关键软件，以夺取开源世界对应业务领域的标准。</p>
<p>出于这一动机实践开源的典型企业就是谷歌。无论是 Kubernetes 还是 Istio 的开源，谷歌从中获得的直接商业利润都是不足以促成它做这样的动作的。然而，谷歌通过对自己内部业务应用的分析，看出容器技术和云原生应用是未来业务发展的方向。为了保护公司内部所有基于 Kubernetes 同类云平台的业务能够持续得到新生代工程师的认同和维护，谷歌需要占领云原生标准的话语权。</p>
<p>这里有段逸闻想必同行也耳熟能详，说当初谷歌找上 Docker 希望合作开发容器调度平台，但是 Docker 认为自己单独开发 Docker Swarm 也能赢下容器战争。结局大家也都知道了，Kubernetes 赢下了容器战争，Docker Swarm &#x2F; Apache Mesos &#x2F; Open Stack &#x2F; Cloud Foundry 等等当初的对手则黯然退场乃至彻底死亡。</p>
<p>相关技术被潮流所抛弃对采用这些技术的企业和团队带来的打击是非常严重的。不仅仅是押宝相应技术的团队被市场所否定，就业前景黯淡，对于公司来说，这意味着可能几十万行、上百万行乃至更多的业务代码都成了技术债务。站在今天的角度能够看到的例子，就是欧美国家银行当中海量的 COBOL 语言写成的业务系统，如今能找到的有维护能力的工程师最年轻的也有六十岁以上。如果这个世界上能够维护这些系统的工程师已经绝迹，那么企业的业务就暴露在巨大的风险之下。显然，当初选择了 Docker Swarm 和 Apache Mesos 的企业也将面临越来越招不到人维护的处境。在这种情况下，唯一能做的就是及时将遗留系统迁移到上游标准，但是这样的工作往往需要更加精通被淘汰的技术的工程师才能牵头完成，并且相应的时间精力成本不可估量。如果迁移这么简单，那些 COBOL 代码又是怎么历经几十年都无人能够“迁移”的呢？</p>
<p>不仅仅是容器战争这样出圈的开源标准之争，Yahoo! 开源 Apache ZooKeeper 和 Apache Pulsar 等软件，阿里开源 Apache RocketMQ 和全面投入 Apache Flink 的开发，Netflix 开源 Apache Curator 和 Apache Iceberg 以及 Uber 开源 Apache Hudi 等等，都有保护自己线上业务的动机在里面。当然，如果能够借此机会树立公司的技术品牌，吸纳高水平的技术人才，乃至主导行业未来的发展方向，那就是意外之喜了。</p>
<p>不完全是软件行业为了保护现存业务，在开源技术以争夺行业标准的方向上，还有三个值得一提的案例。</p>
<p>第一个是启发我从这个方向看待企业实践开源的动机的例子。Bjarne Stroustrup 在 2020 年总结 C++ 发展历程的论文 <a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf">Thriving in a Crowded and Changing World: C++ 2006–2020</a> 当中提到了 C++ 标准委员会当中有许多耳熟能详的大公司的参与，包括苹果、谷歌、英特尔、微软、摩根士丹利、英伟达、高通、红帽和 IBM 等等。每个提案提出的时候，往往代表了某个公司或科研机构经年的努力、实践和生产检验。论文当中回顾了若干提案导致不同硬件厂商的标准之争、大学科研机构的方向之争和软件公司保护现存业务不受完全不同的标准的影响的争论。</p>
<p>例如，各家都有自己的协程实现和用例，如果标准库的实现与自家实现的关键设计和接口不同，那么就意味着以上游的分叉，这将导致上面提到的实现被开源社群所抛弃或者巨大的迁移成本的问题。对于硬件厂商来说，类似于 C&#x2F;C++ 这样的系统编程语言是硬件接口接入软件层面第一个要打交道的层次。如果在并发语义、时钟接口或者硬件访问标准上采取了一家硬件厂商的方案，那么其他硬件厂商的众多生产流水线就面临立即被市场淘汰的风险，以及成为相应细分领域追随者而不是领导者或公平竞争者的劣势。</p>
<p>第二个是谷歌开源 Android 操作系统的例子。开发和开源 Android 操作系统之前，谷歌内部并没有大量的现存业务。但是众所周知，为了避免移动互联网时代的基础设施移动设备的操作系统被 iOS 全面统治，从而在谷歌和苹果的全面软件技术竞争上处于劣势，后发的谷歌选择开源的方式来开发自己的移动设备操作系统。谷歌在浏览器市场上也采用了类似的模式，谷歌浏览器的内核是开源的 <a href="https://www.chromium.org/chromium-projects/">Chromium</a> 项目，这一选择或许受到了世纪初 Firefox 在与 IE 的竞争下赢得巨大成功的启示。不可否认的是，开源的 Android 操作系统形成的庞大生态，开源的 Chromium 内核衍生的一系列浏览器软件，成为了谷歌在这两个方向上核心技术极深的护城河，同时也极大地扩张了这两个领域的市场规模。</p>
<p>第三个例子是跨领域的特斯拉的例子。特斯拉进军新能源汽车领域时，这个领域的市场规模还很有限。即使特斯拉是行业当中无可争议的老大，新能源汽车在行业成熟度，全球化分工的可行性和社会认可度都是极其有限的。通过开源核心基础技术，不追究使用基础专利侵权，使得全球所有看到机会的人才投入到这个行业当中来。行业成熟度决定特斯拉能够持续地招聘到什么水平的人才。如果市场上只有特斯拉一家公司，那么选择这个方向的人心里就要打鼓，现在即使投身这个行业进不去特斯拉，或者特斯拉出现问题要调整或者裁员，也能找到其他岗位继续自己的职业生涯。如此，加上行业热情高涨，社会认可度高，人才投入到这一领域的概率和比例就大大增加了。另一个方面，社会认可度还可以增加大众购买新能源汽车的动力和信心，全球化分工则使得特斯拉的生产制造流水线能够放置到人力成本最经济的国家或地区完成。</p>
<h2 id="企业实践开源的其他收益"><a href="#企业实践开源的其他收益" class="headerlink" title="企业实践开源的其他收益"></a>企业实践开源的其他收益</h2><p>前面三段分类讨论了不同商业模型下的企业实践开源的动机和形式的不同，这一段从企业实践开源的收益的角度出发，讨论上面没有专门点出的动机。</p>
<h3 id="内容生产的原材料"><a href="#内容生产的原材料" class="headerlink" title="内容生产的原材料"></a>内容生产的原材料</h3><p>定位自己为技术公司的企业，需要解决的一个问题就是如何建立和持续强化技术品牌。技术品牌打造的一个关键支柱是技术内容运营，内容运营最大的挑战是没有内容。巧妇难为无米之炊，如果企业的技术人才、研发部门的日常工作当中没有生产出有利于打造品牌的技术内容原材料，期待运营部门自己凭空创造出内容是非常困难的。</p>
<p>企业以开源文化或者开源办公室为支点，系统地采集员工在上游开源社群或者企业开源的软件社群当中的活动，就能为内容生产提供优质的原材料。例如许多开源社群都会有自己的 Weekly 新闻，记录最近一周开发团队和周边生态发生的要闻，包括实现了什么新功能，修复了什么问题，有哪些新成员加入，软件生态有什么新组件或者老组件的重大变更，社交媒体上有什么与本社群相关的热点。企业鼓励员工积极参与上游开源社群，积极地以开源协同的方式运行企业开源的软件社群，在这个从业者都有旺盛的求知欲和参与热情的行业当中，不难积累出值得宣传的内容。</p>
<ul>
<li><a href="https://this-week-in-rust.org/">This Week in Rust</a></li>
<li><a href="https://weekly.databend.rs/">This week in Databend</a></li>
<li><a href="https://www.pythonweekly.com/">Python Weekly</a></li>
</ul>
<p>这些内容都是 WORKING IN PUBLIC 的行为，因此也就不存在是企业“内部”的动作，从而出现茫茫多内容审核的问题。此外，内容运营最能激发参与热情和建立技术品牌的点，在于其他人也能方便地加入进来，验证你发布的内容当中提到的事情是真的，参与到发布的招募事项里面来，亲力亲为与其他社群成员形成联系。</p>
<h3 id="实践软件工程理论"><a href="#实践软件工程理论" class="headerlink" title="实践软件工程理论"></a>实践软件工程理论</h3><p>要想从 Apache 软件基金会的孵化器中毕业，成为 Apache 顶级项目，需要在 <a href="https://tisonkun.org/open-source-guides/apache-maturity-model/">Apache 成熟度模型</a>的指导下实践一系列软件工程的理论。</p>
<p>对于其他开源社群的建设来说，要想发挥开源协同的最大价值，同样需要在这个远远超出一个公司员工总数量级的开放式环境当中高效地协同不同的参与者。从代码到文档，从开发到测试再到发布，从协议合规到软件安全，从技术社群到开源生态，每一个方面都是对一个新生的开源社群的考验。</p>
<p>尤其是国内短于软件工程理论的交流和实践的环境下，企业鼓励员工参与开源社群，将自己所依赖的不构成明显商业竞争优势的专有软件开源并尝试建设一个开源社群，是一个很好的与全球同行切磋“高质量软件应该怎么制造”的路线。企业需要懂得软件工程的员工来做好自己需要的业务软件和基础软件，而缺乏现成可参考的案例和可以试手的对象，不仅对于学生是个问题，对于不像谷歌那样有一套完整的软件工程体系和大量可供参考和参与的软件的公司的员工来说，也是个巨大的问题。</p>
<p>许多程序员不知道文档应该怎么写，许多程序员没见过复杂的并发问题，许多程序员不了解软件构建的过程，对软件整体的交付流水线知之甚少，更有许多程序员不知道如何与其他成员沟通协作、合作开发。对这些全局视角和具体细节把握的不足，软实力的缺失，就是程序员能力的短板，虽然不是每个人都要是全面的人才，但是这应该是每一个从业者追求的目标。这些问题，只要你深入参与到开源社群当中去，或者自己运行一个开源社群，其实就有机会积累到宝贵的经验。</p>
<ul>
<li><a href="https://cwiki.apache.org/confluence/display/FLINK/Development+Process">Flink Development Process</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/FLINK/Flink+Improvement+Proposals">Flink Improvement Proposals</a></li>
<li><a href="https://pingcap.github.io/tidb-dev-guide/contribute-to-tidb/introduction.html">Contribute to TiDB</a></li>
</ul>
<p>至于前文已经提过的建立技术品牌以后，带来的招聘上和客户取信上的收益，赢得开源标准带来的一系列价值，这里就不再赘述。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据企业商业模式与开源软件之间的关系，其实践开源的动机与具体实施的行为会有不小的差别。</p>
<p>我认为，直接销售开源软件终将被证明是不可行的。基于开源软件，提供订阅服务或技术支持，构建企业级的解决方案，是能够长久存续的商业模式，也因此提供了企业长期实践开源的源动力。当企业逐渐发展以形成复杂的商业模式以后，开源就不仅仅是技术影响力或者协同开发这么纯粹了。主动参与自己所依赖的开源软件的上游社群，或者以各种方式支持上游社群的发展，争夺开源标准，保证自己的现存业务在激烈的市场和技术竞争下能够长期存在，直到领域的终局，也是这一阶段的企业需要考量的动机。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>企业开源</tag>
      </tags>
  </entry>
  <entry>
    <title>《信号》影评</title>
    <url>/2022/04/23/movie-review-signal/</url>
    <content><![CDATA[<p>晚上跟我家妹子一起又一次看完了<a href="https://movie.douban.com/subject/26310143/">《信号》</a>。回想起来上次看的时候京畿南部事件还没侦破，这次再去搜索的时候，已经有结论了。这部剧让我联想到同样在同一个时空里改变过去的<a href="https://movie.douban.com/subject/4925398/">《命运石之门》</a>，还有同样讲述公检法黑幕的<a href="https://movie.douban.com/subject/33447642/">《沉默的真相》</a>。</p>
<span id="more"></span>

<img src="/2022/04/23/movie-review-signal/steins-gate.jpeg" class="" title="尤其是 DMAIL 和 SIGNAL 的相似性">

<p>《沉默的真相》原著《长夜难明》里我印象最深刻的就是直到最后也没有把整个黑恶势力集团连根拔起，只是象征性的给了一句“大老虎落马”应付。《信号》当中，张议员集团最后也没有被掀翻，李材韩刑警仍然处于危险当中。剧里鹰犬科长两次都说“这世道就是这样的啦”，实在是让人气不打一处来。</p>
<img src="/2022/04/23/movie-review-signal/signal-000.png" class="">

<p>《信号》核心传达的理念，应该是李材韩刑警在无线通讯中的这两段话。</p>
<img src="/2022/04/23/movie-review-signal/signal-001.png" class="" title="你那边也一样吗？只要有钱有背景，就算做了混账的事情，也能吃香喝辣生活得很好吗？">

<img src="/2022/04/23/movie-review-signal/signal-002.png" class="" title="既然犯了罪，不管是有钱还是有后台，都要得到相应的惩罚。这才是我们警察该做的事。">

<p>这样直击社会问题的影片和水到渠成的价值观塑造，又有谁呢不喜欢呢？</p>
<p>最近还看了同类的剧集<a href="https://movie.douban.com/subject/30425928/">《自白》</a>和<a href="https://movie.douban.com/subject/35248792/">《少年法庭》</a>，我只觉得国内近年来虽然有《沉默的真相》和<a href="https://movie.douban.com/subject/30228394/">《觉醒年代》</a>这样高质量的探讨社会问题的影视作品，但是还是太少了。</p>
<p>我们需要更多优秀的影视作品，影响社会上的每一个人积极的思考我们所生活的环境，为什么会到现在这样的地步，正在发生的事情是对的吗。</p>
]]></content>
      <categories>
        <category>小放映厅</category>
      </categories>
      <tags>
        <tag>韩剧</tag>
      </tags>
  </entry>
  <entry>
    <title>NoSQL Revolution</title>
    <url>/2022/06/13/nosql-revolution/</url>
    <content><![CDATA[<p>从本世纪初谷歌的三篇论文发布以来，数据处理领域在大数据的方向上探索了将近二十年的时间。从三篇论文的开源实现 <a href="https://hadoop.apache.org/">Apache Hadoop</a> 和 <a href="https://hbase.apache.org/">Apache HBase</a> 开始，到打破传统关系型数据库的分布式数据处理系统如雨后春笋般接连诞生，NoSQL 系统回应了移动互联时代的数据爆发式增长的挑战。</p>
<p>诚然，传统的数据库专家对 NoSQL 也有像 <a href="https://homes.cs.washington.edu/~billhowe/mapreduce_a_major_step_backwards.html">MapReduce: A major step backwards</a> 这样的批评，不过 NoSQL 系统本身也在向传统数据处理领域当中被证明有效的特性靠拢，向 Not Only SQL 系统转变。</p>
<p>本文首先从移动互联时代数据增长和数据模型演进带来的实际问题出发，讨论 NoSQL 系统在现在企业数据处理生态当中的定位和价值，然后介绍 NoSQL 系统靠近 Not Only SQL 定位的过程中遇到的硬核诉求，最后分析新时代 NoSQL 的发展方向。</p>
<span id="more"></span>

<h2 id="数据量的增长带来的挑战"><a href="#数据量的增长带来的挑战" class="headerlink" title="数据量的增长带来的挑战"></a>数据量的增长带来的挑战</h2><p>NoSQL 系统崛起的主要原因就是移动互联时代数据的爆发式增长。</p>
<p>起初，企业经营过程中产生且需要运维的数据并不多，单机数据库应对就绰绰有余。尤其是在摩尔定律尚未失效的硬件主导技术升级的年代，数据量级增长的速度未曾超过硬件升级的速度。关系数据库赢下单机数据库战争以后，几乎每家企业的数据处理生态都被 Oracle 数据库、IBM 的 DB2 数据库和微软的 SQL Server 数据库所占据。</p>
<p>随着移动互联时代的到来，计算机全面进入到民用阶段。几乎人人手持一部甚至多部终端设备，这些设备逐渐占领了每个人生活的绝大部分时间。全域搜索、社交媒体、在线游戏、电商购物、网络直播……提供此类服务的企业所要处理的数据的量级，不再是商业场景下的 B2B 订单、客户关系管理和运维的量级，而是全民参与的 B2C 或 C2C 的用户行为的量级。换句话说，这时企业所要处理的数据，从一部分企业及其行为的量级增长到了全体民众及其行为的量级。</p>
<p>另一方面，硬件的升级也遇到了摩尔定律的瓶颈，硬件的升级不再能够满足用户数量增长的需求。阿里巴巴在 2008 年前后开始的“去 IOE 运动”就是这一趋势的一个注脚。原本，阿里巴巴在应对用户数据快速增长的时候，采取的也是传统的硬件技术升级的手段，采购商业级 Oracle 数据库、特殊定制硬件的 IBM 小型机和 EMC 高级存储设备来支持。然而，一方面受到技术自主可控的驱动，另一方面也是出于企业经营成本控制的要求，阿里巴巴转向了 MySQL 数据库以及后续一系列开源或自研的分布式数据处理系统的解决方案。</p>
<p>当然，单机 MySQL 也无法抗住全网用户每天源源不断产生的行为数据。因此，在阿里巴巴等互联网公司当中就诞生了以分库分表技术为核心的数据库中间件解决方案，即通过分拆业务到不同数据库实例中，同一业务选择分片键分拆到不同数据库实例中，再于业务和数据库实例集群之间设置一个解析查询和转发查询的中间件，来实现以多台廉价计算机和运行其上的 MySQL 数据库，抗下用户行为数据的解决方案。</p>
<p>严格来说，这一方案产生的软件不是 NoSQL 系统。NoSQL 系统的一个重要特征是用户能够像对待单一系统那样与整个 NoSQL 分布式系统交互，而分库分表的数据库中间件往往要求用户知悉底下数据分片的模型，从而针对性的写出不会导致全表扫描的查询。另一方面，即使采用了分库分表的解决方案，系统所能处理的数据量仍然是有限的。目前主流的分库分表方案，最多能够应对 TB 级别的数据。这对于用户账户数据、商户和商品概要数据以及最近一段时间的订单数据或许是足够的，但是对于历史订单数据、商品详情数据、用户历史足迹和社交网络活动记录来说，则远远不够。或者说，即使能够扩容分库分表的数量来支撑更大的数据量级，底下运行的 MySQL 实例产生的开销，也不如 NoSQL 系统底下只是需要一个普通的数据节点更有性价比。</p>
<p>NoSQL 系统当中，除去主打内存缓存的 <a href="https://redis.io/">Redis</a> 以外，诸如 HBase 和支持 Redis 协议的数据持久化 NoSQL 系统 <a href="github.com/apache/incubator-kvrocks">Apache Kvrocks (Incubating)</a> 都能支持 PB 级别甚至以上的数据存储和访问。这得益于从谷歌三篇论文一脉相承的 scale out 策略，藉由简化系统复杂度，以硬件技术的新增长点网络性能抵消单机处理的延时优势。这样，企业当中的数据处理系统可以用增加成本可控的节点数，而非对抗摩尔定律购买价格不支持商用的高端硬件的方式，在延时可接收的范围内应对更大的数据量。</p>
<p>前面提到，NoSQL 系统对于用户来说是一个整体，而分库分表在扩缩容时却未必能够像传统数据库使用体验那样流畅。由于分片键与实例数相关，分库分表分出来多少个库表，这个知识会成为整个系统的一个固有限制。如果想要增加数据库实例，这个过程并非简单地上线新实例就可以开始服务，而是需要整个逻辑数据库在新的库表数下重新分片。我在某司操作过 32 库乘以 128 表到 128 库乘以 128 表的迁移过程，这个迁移的数据同步阶段总共花了两天半的时间，在线上几乎没有感知的情况下以深夜一分钟左右的闪断为代价切换成功。然而，这还是建立在公司有足够强的研发实力支持从头开发一套数据中间件以及数据迁移系统的前提下的开销。而无论是哪种典型的 NoSQL 系统，几乎都支持用户无感知的扩容和缩容动作。</p>
<p>分库分表的数据库中间件实质上操作的是底下不同的数据库实例，传统数据库支持的事务一致性、多表联合操作和存储过程等功能，几乎都受限于实际上数据存在于多个数据库实例的物理限制而无法支持。NoSQL 系统可以认为是在这样的 baseline 上，基于整体考虑设计出一个能够最大化数据处理吞吐和尽可能降低数据延迟，并且尽可能使得用户像对待一个统一系统那样操作的解决方案。</p>
<p>对于定位在支持传统数据库的语义和功能，同时又要满足数据增长需求的 <a href="https://www.cs.cmu.edu/~pavlo/slides/hydra-newsql2021.pdf">NewSQL</a> 系统，这些系统能够处理的数据量级上限，实际上也没有超过分库分表方案 TB 级别的水平。同时，在数据量超过一定水平时，这些系统会面临严重的功能挑战，例如大事务延迟不可接受，选择 TSO 作为中央授时的系统中心节点不堪重负，或者 Aurora 会提示用户关闭 Binary Log 以保证用户读写的时延。相比起 NoSQL 系统所能处理的数据量级，这些 NewSQL 系统还是不太够看。从它们支持的数据库功能来看，往往与传统数据库也有明显的差别，比如存在微妙差异的事务一致性，不支持存储过程，不支持外键，等等。</p>
<h2 id="数据模型贴近业务的价值"><a href="#数据模型贴近业务的价值" class="headerlink" title="数据模型贴近业务的价值"></a>数据模型贴近业务的价值</h2><p>NoSQL 系统崛起的另一个主要原因是打破了关系模型对数据处理领域的垄断。</p>
<p>严格来说，在业务逻辑开发这一块，关系模型并没有统治开发者的心智。虽然不少业务逻辑是写在存储过程或者触发器当中的，这些代码自然深深地被搭上了关系模型的印记，但是尤其在互联网业务开发的领域当中，开发人员并非直接面向数据库编程。在开发人员编写的业务代码到底下的数据库系统中间，经常有一层对象关系映射框架（ORM）的存在。</p>
<p>这就是关系数据库始终绕不过的“<a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch">对象关系阻抗失配</a>”问题。</p>
<p>现代程序设计语言的主流是面向对象的程序设计，即使并非“一切都是对象”的信徒，大部分语言也都支持数据结构的嵌套。而在关系模型当中，所有的数据都以元组的形式存储，想要表达列表或者嵌套数据结构，要么需要冗余数据，要么需要设置多张表并藉由外键关联来查询。</p>
<p>前者不仅会造成空间的浪费，还会在数据结构趋于复杂，尤其是存在 option 和 either 这样的结构的时候，列的碾平生出非常难以查询和写入的表结构。后者更不必说，原本是同一个逻辑对象的数据，如今散落在多张表上，无论是更新时需要注意的级联变更和完整性约束，还是查询时需要依靠 JOIN 来聚合数据，都是非常麻烦的事情。</p>
<p>反观 Redis 的主要特点之一就是支持丰富的数据结构，例如开发者熟悉的 List&#x2F;Hash&#x2F;Set&#x2F;ZSet 以及方便的 HyperLogLog&#x2F;GeoHash&#x2F;Bitmap 等等。对于接受经典数据结构培养的研发人员来说，Redis 这种丰富数据结构上手成本很低，开发者对于基本的数据结构都会使用。反观关系数据库的模型，要在其中实现 List Push&#x2F;Pop 这样的操作还是有些麻烦。</p>
<p><a href="https://www.mongodb.com/docs/manual/core/data-modeling-introduction">MongoDB 的数据模型文档</a>将支持灵活的数据模型放在了第一位，<a href="https://cassandra.apache.org/doc/latest/cassandra/data_modeling/intro.html">Apache Cassandra 的数据模型文档</a>则进一步点明了这种数据模型价值观与关系数据库的不同——如果说关系数据库的数据模型是表驱动的，那么 NoSQL 系统的数据模型就是查询驱动的。</p>
<p>传统的数据库开发流程，往往是由 DBA 或架构师定义出一系列的表及表的模式，藉由关系数据库系统支持的特性和约束来保证数据的完整性和一致性，以这些表及表的模式为基础，上线数据处理系统支持业务需求。如果业务迭代需要引入新的字段或者添加新表支持嵌套数据结构，这些改动都需要送交 DBA 和架构师审批，甚至对于核心数据表的改动，还需要送交研发高管审批。这一过程和认识直到今天仍然没有什么大的改变。基本上，关系数据库在企业当中的定位就是持久化数据资产。</p>
<p>然而，移动互联时代业务的需求有着很强的时效性，需求经常变化，为了应对某个活动需要临时增加某个字段，过后即可废弃。这样的使用场景遇上层层审批的变更流程，必然激发出剧烈的矛盾。NoSQL 系统此时就扮演了一个在企业关键数据资产和业务经常变化且时效性强的需求之间的润滑剂。</p>
<p>一方面，核心数据资产例如用户账户数据、用户信息数据、订单交易数据等等，仍然由关系数据库来支撑运转，保证数据的完整性、一致性和足以应对容灾的持久化，并且借助几十年来发展得相当成熟的数据平台生态进行冷数据归档，以及数据订阅、数据同步等等，作为业务系统的核心数据来源支撑。另一方面，NoSQL 系统存储非核心的经营数据或者衍生、冗余数据，用以支持业务高速迭代的需求。查询驱动的含义就在于此：业务查询是什么样的，底下的数据模式就可以是什么样的。例如使用 Redis 存储用户账户与手机号的对应关系，使用 HBase 存储全国地图上的兴趣点以支持基于位置的用户服务，将业务数据导入 <a href="https://github.com/elastic/elasticsearch">ElasticSearch</a> 当中提供搜索功能，使用 <a href="https://pulsar.apache.org/">Apache Pulsar</a> 接受采点上报数据。</p>
<p>这种职责分层实践在过去十几年当中不断地被传播和应用，证明了 NoSQL 在企业当中足以赢得自己生存的空间。从数据模型的角度看，贴近业务的数据模型天然适合应对业务的经常性迭代。灵活的数据模式能够快速适应数据模型变更的需求；丰富的数据结构符合开发者的心智模型，能够更快的完成业务代码开发；而对于消息队列、倒排索引系统和图数据库，则是各自领域当中最贴合的建模方式。例如 XLab 分析 GitHub 全域开源协同数据的时候，就自然选择了图数据库来分析人与人、人与项目、项目与项目之间形如社交网络的关系和行为数据。</p>
<p>随着 NoSQL 系统逐渐成熟，尤其是在数据一致性和存储可靠性上面的突破，越来越多的企业也结合自身业务的特性，尝试把核心业务及其数据也假设在 NoSQL 系统上。国外基于 MongoDB 发展出一套 <a href="https://en.wikipedia.org/wiki/MEAN_(solution_stack)">MEAN</a> 应用开发栈，就是这一实践的注脚。虽然业务稳定以后，数据模型变更减少，表驱动的关系数据库能够带来多年积累的软件成熟度和生态繁荣度的优势，但是对于创业公司或者新团队新业务来说，采用 NoSQL 来快速启动自己的业务，并且能够灵活地调整数据模型，或许是个更好的选择。</p>
<h2 id="Not-Only-SQL-的诉求"><a href="#Not-Only-SQL-的诉求" class="headerlink" title="Not Only SQL 的诉求"></a>Not Only SQL 的诉求</h2><p>NoSQL 系统一开始得名就是因为它的设计理念和数据模型都是反（NO）关系数据库（SQL）的。</p>
<p>这种反叛的极致体现在谷歌的三篇论文当中完全无视数据库领域二三十年的积累，以一种非常土味的方式用廉价机器拼凑起来一个分布式存储系统 <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf">GFS</a> 和仅仅支持 <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf">MapReduce</a> 这样简单算子的计算引擎。<a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">Bigtable</a> 作为初代 NoSQL 引擎，不支持跨行跨表事务，不支持严格的表模式，没有关联查询，没有索引，没有存储过程。</p>
<p>这些“离经叛道”的创举自然引来了数据库大佬们的批评，比如本文开篇引用的 MapReduce: A major step backwards 博客文章。这些批评主要就集中在上面提到的这些“不支持”和“没有”上，以及与数据库生态的不兼容。</p>
<p>一开始，尝到了堆砌大量廉价机器就能解决业务问题甜头的开发者和公司对这些批评自然是不屑一顾的。只是随着业务越长越大，复杂性越来越高，人们面临着数据杂乱无章的失序的风险，以及缺乏传统数据库约束和索引带来的性能退化的痛点，逐渐开始认真考虑数据库领域一直以来的研究的价值。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>第一个被提出的议题就是事务，或者说其所代表的数据一致性问题。单机数据库能够保证简写为 ACID 的事务一致性，而分布式系统受到 CAP 理论的限制，往往无法实现单机关系数据库能达到的数据一致性。</p>
<p>关于 CAP 理论的理解，在实际业务取舍的过程中，并不是简单的一致性、可用性和分区容忍性三选二，而是在分布式系统本来就需要能够做到分区容忍，以及业务必须保证服务可用的前提下，看看能够做到多少一致性。当然，有些一致性是以服务短暂不可用或者时延升高为代价的，但是业务绝对不会接受服务一直不可用。</p>
<p>这种情况下首先被提出的解决方案是所谓的 BASE 性质，即基本可用、柔性状态和最终一致，或者我喜欢借用一个说法，叫做啥也不保证。BASE 性质基本已经被扫进历史的垃圾堆里了，不会再有系统标榜自己符合所谓的 BASE 性质。但是它确实提供了数据一致性上的一条基线，即最终一致性。也就是说，对于给定的有限的输入集合，NoSQL 系统当中的数据最终会收敛一个稳定状态，但是这个稳定状态下数据的值是否还有业务意义，不保证。</p>
<p>一般来说，NoSQL 系统在此之上能够做到对自己数据模型下单个数据单元的基本操作是原子性的。比如说，KV NoSQL 系统当中 Put 一个字符串是原子的，不会出现两个 Put 操作的结果是值一部分由第一个操作提供，一部分由第二个操作提供的情况。不过，业务要求显然远远不止这点。对于业务来说，常见的一致性或者叫事务需求，是保证对一行数据的多个操作的原子性，乃至多行数据多个操作的原子性。例如单行数据的 CAS 操作，或者多行数据原子写乃至事务性的读后写的支持。</p>
<p>HBase 和 Bigtable 都支持单行事务，这是因为它们的数据模型里单行数据一定存在单台机器上，保证同一台机器上操作的原子性是比较简单的。大部分系统根据自己物理数据分布的特性，也会向用户保证这类数据存储在同一台机器上的情况下事务能力的支持。</p>
<p>对于跨多台机器的事务支持，则要牵扯到分布式事务的话题。对于 Pulsar 这样数据仅追加的消息系统来说，可以通过批量提交及该操作的幂等性来实现生产消息的事务支持。对于存在删改的系统来说，要么选择放弃隔离性，实现复杂的数据补偿逻辑来支持 Sagas 式的分布式“事务”，要么是采用 <a href="https://raft.github.io/">Raft</a> 这样的共识算法加上某种形式的两阶段提交算法来支持分布式事务。例如 <a href="https://tikv.org/">TiKV</a> 采用了 Raft + <a href="https://tikv.org/deep-dive/distributed-transaction/percolator/">Percolator</a> 算法来实现分布式事务，Percolator 本质上还是两阶段提交，但是在生产上会有一系列的优化，并且在某些特定条件满足的情况下可以简化成一阶段提交。</p>
<p>一般来说，启用分布式事务会导致数据吞吐的下降和其他性能影响，因此大部分 NoSQL 系统都提供了用户自己调节数据一致性的选项，来保证只在需要对应级别的数据一致性的情况下，才付出相应的开销。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>前文提到，NoSQL 的一个优势是灵活的数据模式能够响应业务的高速迭代。不过，随着业务日渐复杂，开发团队人员更迭，维护 NoSQL 系统上存储的数据的质量就成为了一个难题。</p>
<p>如果所有的数据都是无模式的，或者数据模式没有被良好的记录和检验，那么杂乱无章的数据就可能带来极大的存储空间浪费并阻碍业务开发。</p>
<p>关系数据库和 SQL 当中有专门的数据定义语言（DDL）来描述表模式，通过定义清楚字段的类型和约束来保证数据是结构化的。虽然一旦这种约束过于繁琐和严格，且由于企业流程难于变更时，会影响业务开发的效率，但是清晰的类型约束和唯一性约束是有助于开发人员理解字段的属性和检验业务逻辑正确性的。</p>
<p>这种思路体现在 NoSQL 的演进之路上就是渐进式模式定义。</p>
<p>例如，MongoDB 就支持<a href="https://www.mongodb.com/docs/manual/core/schema-validation/">数据模式校验</a>，Pulsar 也支持<a href="https://pulsar.apache.org/docs/schema-get-started">定义消息的模式</a>。</p>
<p>再以 Cassandra 为例，虽然一开始它对外暴露的是稀疏列簇式大宽表的接口，但是也逐渐地转向建议用户以 CQL 和 Cassandra 交互，同时也保留直接操作底下稀疏列簇式大宽表的手段。</p>
<p>对于现有系统本身不支持数据模式定义的，也有其他系统来支持。例如 <a href="https://hive.apache.org/">Apache Hive</a> 支持为 Hadoop 上的数据定义模式，<a href="https://phoenix.apache.org/">Apache Phoenix</a> 支持为 HBase 定义数据模式。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>对于直截了当的查询来说，NoSQL 的性能优势是明显的。例如 HBase 上已知 rowkey 查询值，这样的操作是系统设计之初就考虑到的情况，属于舒适区。</p>
<p>然而，随着业务发展逐渐复杂，各种新的查询维度也纷至沓来。例如，不再是以 rowkey 查询值，而是以某一列的值为筛选条件来查询匹配的所有行。比如一个用户表，一开始将用户 ID 作为主键存储，现在要根据用户所在地筛选出所有在某地的用户。由于 HBase 没有索引，这种查询只能扫全表后过滤。可想而知，每次查询都需要遍历全表数据，查询的性能肯定好不到哪去。</p>
<p>关系数据库当中也有一样的问题，MySQL 每一行的主键是固定的，要么是创建表模式时指定，要么由插入行时自动生成的 rowid 取代。关系数据库当中可以针对某张表创建索引。一方面，唯一键索引可以施加键值唯一的约束；另一方面，创建索引通常会在存储系统当中额外创建出一个从索引列到主键的映射。实际以索引列为过滤条件查询的时候，会先从索引映射当中找到对应主键的集合，然后直接挑选出小部分相关行做后续操作。</p>
<p>基本上现在的 NoSQL 系统都会实现一定的索引机制。例如业内前沿的数据湖存储 <a href="https://hudi.apache.org/">Apache Hudi</a> 系统，一开始只是一个按照直觉写出的读取 Hadoop 上的文件，应用对给定记录的变更并写回 Hadoop 的 Apache Spark 程序。但是在后来投入生产之后，越来越多的开发人力加入和生产环境对性能无止境的追求，为 Hudi 添加了基于元数据文件的、基于 HBase 外存的，以及在选择 Apache Flink 处理引擎的情况下基于 Flink 内置 State 存储的多种索引方案。</p>
<p>上一节提到的能为 HBase 定义数据模式的 Phoenix 项目，也支持为 HBase 创建索引。</p>
<p>从这一系列 NoSQL 系统的转变来看，索引确实是其走向 Not Only SQL 的一个性能上的硬核需求。</p>
<h2 id="新时代-NoSQL-的发展方向"><a href="#新时代-NoSQL-的发展方向" class="headerlink" title="新时代 NoSQL 的发展方向"></a>新时代 NoSQL 的发展方向</h2><p>NoSQL 系统的范畴非常广，具体到每个细分领域面临的业务环境演化和技术需求都不尽相同。</p>
<p>对于整个 NoSQL 生态发展的角度来说，未来的发展方向是发挥在应对大数据量上无需全面兼容传统数据库约束的优势，直面海量数据和全球分布式系统的挑战，并且结合具体业务领域对数据模型的要求，根据对应假设设计出在不同业务场景下最优化的数据处理系统。</p>
<p>对于具体的 NoSQL 系统来说，我想 KV NoSQL 这个细分领域值得关注。字典映射是构建复杂数据结构的基础构建块，无论是应对什么场景特化的 NoSQL 系统，最终映射到持久化存储的数据结构，几乎都是某种 KV 的形式。如果 KV 引擎能够从现在 RocksDB 占据单机引擎半壁江山的状况，发展到有一个分布式 KV NoSQL 系统能够支持其他特化的 NoSQL 系统基础的存储需求，那么这或许会是分布式数据处理系统下一次革命的开端。</p>
<p>对于有望成为这个方向解决方案的系统，它至少能够可选地支持上面提到的 Not Only SQL 所需要的硬核特性，也就是事务、模式和索引。在此基础上，如果能够在低延迟、可扩展性和稳定性上实现突破，比如引擎的创新带来的性能提升，利用云原生时代的基础设施和硬件的迭代支持全球规模的集群管理，工程打磨实现生产可靠的稳定且方便运维的系统，那么这样的一个软件将是有价值的。</p>
<p>对于现有系统来说，实现这样的转型并不容易，但也绝非不可能。例如 Datastax 公司全力投入支持以 Cassandra 为基础的 Astra DB 在云上的应用，HBase 社群也在投入存储上云的开发。对于新系统来说，历史包袱会轻松一些，能够基于现在的情况做针对性的设计。但是在增量市场逐渐萎缩的环境下，做好现有系统 API 的兼容让就是生产系统采用的一个关键考量了。例如，<a href="https://github.com/scylladb/scylla">ScyllaDB</a> 采用了 thread-per-code 的线程模型来试图革新 KV NoSQL 的性能，但是在面向用户的接口上选择兼容 Cassandra 的 API 以帮助存量用户平滑过渡。</p>
<p>进一步地，如果某个 KV NoSQL 系统在 KV 领域打开了局面，那么它就可以借助协议层抽象来支持不同场景的数据存储需求。</p>
<p>例如，TiKV 是一个支持分布式事务的 KV NoSQL 系统，<a href="https://github.com/distributedio/titan">Titan</a> 通过实现 Redis 协议层来支持 redis-cli 对 TiKV 系统的访问；<a href="https://github.com/pingcap/tidb">TiDB</a> 可以认为是在 TiKV 之上实现了一个支持 SQL 访问的协议层。</p>
<p>总结一下，新时代 KV NoSQL 的发展方向，一方面是需要支持前面提到的 Not Only SQL 的硬核诉求，并且需要和现存的数据处理生态保持良好的兼容性。另一方面，这些系统可以在低延迟、可扩展性和稳定性等方向上寻求突破。最后，如果某个 KV NoSQL 系统足够成熟，那么它可以借助协议层了解 KV 之上具体场景下的数据结构信息，知道用户想要存的是什么数据，从而在复杂场景下允许用户直观的表达自己的业务数据，同时让数据处理系统理解相应场景的的语义，帮用户做场景优化。</p>
]]></content>
      <categories>
        <category>天工开物</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《开放式组织》书评</title>
    <url>/2021/12/05/open-organization/</url>
    <content><![CDATA[<p>本文部分启发自在 <a href="https://alc-beijing.github.io/alc-site/">ALC Beijing</a> 录制播客时讨论的内容，仅引用我个人的观点。播客内容应该近期会在前面链接的网站上发布。</p>
<p><a href="https://book.douban.com/subject/26894636">《开放式组织》</a>这本书单看它本身，讲的是红帽公司的组织管理经验。这是一个将商业价值建立在开源项目之上的公司审视公司内部的组织形式的著作，并且主要关注在红帽这个案例上。这样，不管是在经验的普遍性上，还是在开放式组织这种形式跨越组织，尤其是建立商业公司和开源社区之间的联系这方面的讨论上，都有所欠缺。</p>
<span id="more"></span>

<p>从理论到实践，从企业审视内部到跨越组织边界，连接商业公司和开源社区，这样一个广义上的“开放式组织”阅读主题，我推荐以下几本书共读。</p>
<ul>
<li><a href="https://book.douban.com/subject/27125968/">《企业的人性面》</a></li>
<li><a href="https://book.douban.com/subject/34834429/">《协同》</a></li>
<li><a href="https://book.douban.com/subject/26976995/">《社区运营的艺术》</a></li>
<li><a href="https://book.douban.com/subject/35531548/">《用户共创》</a></li>
</ul>
<p>《企业的人性面》我认为是《开放式组织》背后的理论基础，成书于 1960 年，历久弥新。《协同》是国内学者关注“内破部门墙，外拓企业边界”的研究跨越组织边界合作的当代著作。《社区运营的艺术》和《用户共创》均出自 Ubuntu 社区经理 Jono Bacon 之手，讨论了开源社区这一开放式组织的运行方式与最佳实践。这几本书都是阅读《开放式组织》的有益补充。</p>
<h2 id="为什么要理解开放式组织这种形式？"><a href="#为什么要理解开放式组织这种形式？" class="headerlink" title="为什么要理解开放式组织这种形式？"></a>为什么要理解开放式组织这种形式？</h2><p>这个问题也是计划中的“开源协同”系列文章里会展开讨论的问题，这里做简略的回答。这个问题在《开放式组织》里没有直接讨论，而是作为已知假设。然而，这个问题却是想在国内推行开放式组织这种管理模式首先要回答的问题。</p>
<p>本书涉及这个问题的一句话</p>
<blockquote>
<p>我们发现，开发开源软件的最佳方法同样也非常适用于管理整个公司。</p>
</blockquote>
<p>也就是说，开放式组织就是开发开源软件时协调开发团队或者说开源社区的组织管理手段。我喜欢将开放式组织这种组织管理手段简称为“开源协同”。开源软件在开源协同的生产力加持下，在不同领域攻城略地，击溃了专有软件的统治。如果企业想要基于开源软件打造商业价值，那么它就必须了解开源软件。在这种情况下，传统的控制管理模型会导致企业和开源社区激烈的摩擦。要想获得生产力的提升，企业必须成为开放式组织。</p>
<p>这种摩擦来自于时代发展带来的对于组织管理的颠覆。《协同》当中提到的“强个体的价值崛起”，以及《用户共创》当中提到的“社区成员为社区工作，而不是为商业公司工作”都是这一点的佐证。如今，开源社区有能力依靠其同侪社区当中强大的个体打造高价值的软件，其力量足以支持 Linux 赢下服务端操作系统，支持 Rust 成为富有竞争力的系统级编程语言，支持 PostgreSQL 成为世界前列的数据库软件。开源社区及其成员无需依赖于企业尤其是单一企业的控制而生存。因此，他们可以坚持为社区工作，而不是为商业公司工作。</p>
<p>在这种情况下，如果坚持传统的控制管理模型，试图将社区成员驯化成免费劳动力，必将破坏可能的跨越组织边界的合作的信任基石，回退到商业公司雇佣一批员工实现一个本身即是产品的软件。前文说到，开源软件得益于开源协同的生产力加持，正在不同领域中击溃专有软件的统治。在这一背景下，仍然希望聚集起一批员工写出足以媲美开源软件的专有软件，是不太现实的。绝大部分情况下，你无法聚拢起比拟开源社区的专家团队。<a href="https://book.douban.com/subject/2265341/">《维基经济学》</a>当中提到，“唯一有资质做出新发现的人可能在他的组织范围之外”，这将是越来越常见的情况。</p>
<p>《开放式组织》并没有过多的讲这部分内容，因为红帽已经走过了这个阶段。要想跟 Linux 社区达成最好的协同，乃至形成某种意义上的“原厂”品牌，必须以开放式组织的形式运作。本书更多的是讲在已经要运行一个开放式组织的前提下，如何发挥这一组织形式最大的生产力。其实作者 Jim 已经在第一章中提到过，他一开始也试图以传统的控制管理模型来管理红帽公司，但是开放式组织的力量已经不可阻挡，正如开源社区这一开放式组织的力量也不会以商业公司的意志为转移一样。于是他开始学习、理解并运用开放式组织的形式来释放红帽公司员工的生产力。</p>
<h2 id="如何点燃工作热情？"><a href="#如何点燃工作热情？" class="headerlink" title="如何点燃工作热情？"></a>如何点燃工作热情？</h2><p>开放式组织具体的管理策略和<a href="https://book.douban.com/subject/30356081/">《奈飞文化手册》</a>所介绍的准则多有共通之处，其理论基础则都很可能来自《企业的人性面》当中提到的企业管理的 Y 理论。</p>
<p>点燃工作热情是这类组织要面临的第一个挑战。《奈飞文化手册》写到，“成年人最渴望的奖励，就是成功”。《开放式组织》在本章中也提到</p>
<blockquote>
<p>你需要一个能让大家时刻铭记在心的目标，而不只是停留在追求利润这个层面上，这是吸引顶尖人才的唯一方法。</p>
</blockquote>
<p>如果利用马斯洛的需求层次理论来分析，这是要求激发员工对尊重和自我实现的需要的追求。传统的控制管理模型压抑员工的安全需要乃至生理需要的满足，主要使用金钱和职位来激励员工，但是这种激励不能持续。不仅仅是因为员工得到满足后激励作用就会消失，更因为商业公司无法持续用金钱和职位激励每一位员工。与之相反，开放式组织不会压迫员工的生理需要和安全需要，而是激发新时代高价值的强个体的热忱和渴望，也即点燃工作热情来发掘被压抑而无法释放的生产力。</p>
<p>值得注意的是，本章名为“构建充满热情的工作环境”，对于如何做到上面提到的激发热忱和渴望，书中的论调也是</p>
<blockquote>
<p>对于管理者而言，如今最重要的任务就是建立一个启发思考、培育积极的投入精神，并且推崇无限热情、想象力和主动性的工作环境。</p>
</blockquote>
<p>也就是说，组织管理要做的是构建环境。虽然需要关注个体在环境中的发挥来校正对环境状况的认识，但也不用过分纠结某一个人的热情是否点燃。一个人没有热情，是很难点燃出热情的，根本就不可燃。管理者能做的是破除环境当中压抑了人原本的热情的限制条件，释放原本就存在的工作热情。</p>
<p>这一思路也出现在《企业的人性面》当中，书中对比纠结个体，试图利用一致的模式创造标准化人才的“制造”手段，提出了人才的“栽培”方法。</p>
<blockquote>
<p>个人将成长为他可以成为的样子，只要为他们创造适当的成长环境。</p>
</blockquote>
<p>也就是说，开放式组织基于对个人价值的认可和个人能力的信任，致力于创造出能点燃员工工作热情，积极投入工作的环境。</p>
<h2 id="如何提高员工的参与度？"><a href="#如何提高员工的参与度？" class="headerlink" title="如何提高员工的参与度？"></a>如何提高员工的参与度？</h2><p>首先自己要参与，而不是作为一个局外人去提升其他员工的参与度。《开放式组织》当中写到，“想要得到，就先要付出”，就是对每个希望提高员工参与的成员提出的建议。</p>
<p>《企业的人性面》当中花了一整章的篇幅讨论何为参与以及如何参与。根本是要树立诚信，员工能够真正地参与到事务活动和决策中来，整个旅程没有破坏安全感和信任的坏例子。</p>
<p>假模假样的号召参与，实际并不采纳意见等仍然遵循控制管理模型的做法，并不能够瞒天过海，反而是失掉员工的信任，进而整个提高参与度的努力都会失败。</p>
<h2 id="何为精英领导制？"><a href="#何为精英领导制？" class="headerlink" title="何为精英领导制？"></a>何为精英领导制？</h2><p>本书的第四章、第五章和第六章都聚焦在如何做决策这个议题上，而开放式组织从开源社区当中借鉴到的决策方式，自然是精英领导制。</p>
<p>《开放式组织》很有价值的一点在于对比了精英制度和民主制度，并明确地指出了精英制度不同于民主制度的要点。</p>
<blockquote>
<p>精英制度是指根据提出的最佳方案做决定的方式；才能是选择的唯一标准，而非地位、偏见或特权。在一个公民公司里，最优的行动方案是在公开、充分、信息量足够的辩论之后胜出的方案。精英就是每一个有思想、有知识的人，每一个在真正理解之后得出的好想法都会得到重视。毫无才华的吹牛皮之人不会得到尊重。实施了精英制度之后，参与性民主必然将权利转移至最低一级人群的说法也将不攻自破。</p>
</blockquote>
<p>许多开源社区做得不好的一点，就是太强调平等乃至于变成平均主义。其实社区成员积累社会资本，应该是一个 earn authority 的过程，积极主动的 contribution 获得别人的尊重，而不是凑人头投票决策。</p>
<p>Linus 多次表示自己他只以技术论高低，PostgreSQL 社区和 Apache 社区推选新的 Committer 时是核心成员闭门会决议后公示，都是反对民粹的体现。开源社区的公平是基于 contribution 赢得权威的精英领导制，遵守 earn authority by contribution, not by position 的原则。近年来不少开源社区的维护者不堪民粹道德绑架的压力频频爆出“开源世界的暗面”，就是没有形成健康的精英领导制的认知。</p>
<p><a href="https://www.bilibili.com/video/BV1454y1E7xp">Linus Torvalds: 我不在乎政治正确，我只在乎技术本身</a></p>
<p><a href="https://www.bilibili.com/video/BV19f4y1F7QQ">荣耀还是负担？开源大神们居然这么累</a></p>
<h2 id="开放式组织是不是未来唯一的或者最高级的组织形式？"><a href="#开放式组织是不是未来唯一的或者最高级的组织形式？" class="headerlink" title="开放式组织是不是未来唯一的或者最高级的组织形式？"></a>开放式组织是不是未来唯一的或者最高级的组织形式？</h2><p>最后，我想讨论一下这个问题。因为在我讨论开源项目和开放式组织的话题的时候，经常会有人举单一反例，以开源项目和开放式组织如果不是普适的那么就是错的这种无厘头逻辑，来搅乱讨论的氛围。</p>
<p>对于这个问题的答案，我只能说不是。开放式组织是一种选择。控制管理模型也有适合它的军队或教会等组织，前面已经讨论过需要理解开放式组织的原因。现在仍然有专有软件领跑某个领域，仍然有技术领先的源码可得的专有软件开放 API 或允许带有限制的修改，如果你的商业模式适用于这些形式，大可不必采用开放式组织的形式。</p>
<p>但是，软件复杂度将不断提高，基础软件乃至其部分再也无法仅凭一个人或一个公司的全体员工来编写。开源社区这种跨越组织边界，凝聚不同背景专家共同开发的形式，将会生产出高质量的软件，成为事实标准并击溃专有软件。这样的事情正在持续不断的发生。所以至少这个领域的企业，应当理解和采取开放式组织的形式。这种形式也是当前开源社区唯一成功的组织形式。</p>
<h2 id="红帽公司的管理原则"><a href="#红帽公司的管理原则" class="headerlink" title="红帽公司的管理原则"></a>红帽公司的管理原则</h2><ol>
<li>因为想来，所以加入我们。</li>
<li>贡献是决定性因素，但不是交换条件。</li>
<li>不论由谁提出，只要是最好的想法就能胜出。</li>
<li>我们鼓励并且期待开放、坦诚、充满热情的辩论。</li>
<li>我们欢迎反馈意见，本着“早发行，勤发行”的精神做出改变。</li>
</ol>
]]></content>
      <categories>
        <category>大图书馆</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>企业如何实践开源协同</title>
    <url>/2021/12/05/open-source-collaboration-enterprise-perspective/</url>
    <content><![CDATA[<p>随着开源概念的红火，越来越多的企业将内部项目公开托管到 GitHub 等平台，也有越来越多依托开源项目建立起来的企业。对于这些企业来说，它们的目标不只是开放项目源代码，更希望能够形成开源共同体，打造围绕项目的软件生态。</p>
<p>然而，其中大部分项目由于成员背景的单一性，最终都终结于仅源码可得的形态。对于这些新兴项目来说，初始成员从属于同一企业是既定事实。在这样的前提下，企业应该如何实践开源协同，形成开源共同体呢？</p>
<span id="more"></span>

<h2 id="共享工作流"><a href="#共享工作流" class="headerlink" title="共享工作流"></a>共享工作流</h2><p>从开发者的角度出发，根本问题是要共享工作流。共享工作流，即项目开发的核心流程只有一套，所有 contributor 无论背景都基于这套核心流程工作。</p>
<p>对于企业内部项目开放源代码的情况，要做到这一点并不容易。项目往往在企业内部已经有一套成熟的工作流。如果在设计开源方案的时候，没有把共享工作流考虑在内，即使代码公开，大部分开发流程也会保持在企业内部。如果 contributor 不是企业员工，则根本无法参与。</p>
<h3 id="Case-Study-OceanBase"><a href="#Case-Study-OceanBase" class="headerlink" title="Case Study: OceanBase"></a>Case Study: OceanBase</h3><p>这个问题的典型案例是 <a href="https://github.com/oceanbase/oceanbase">OceanBase</a> 项目。</p>
<p>OceanBase 项目的源代码托管在 GitHub 和 Gitee 两个平台上，同时接受问题报告和补丁提交。通常来说，一个项目只会有唯一的问题报告和补丁提交方式。例如，Linux 采用 Bugzilla 记录问题，邮件列表提交和评审补丁。GitHub 上有 Linux 的镜像，但是是只读的。其他的例子包括 GCC 和 PostgreSQL 等，都会有唯一的工作流，其他代码仓库只是镜像。OceanBase 两边都接受问题报告和补丁提交，反而是对两边的反馈都不重视。</p>
<p>可以猜测，它的核心流程既不是 GitHub 上的工作流，也不是 Gitee 上的，而是企业内部的工作流。这种情况下，能从开放可参与的平台上提交的大概率就只有简单的拼写错误或者代码重构补丁。因为即使是资深的开发者，缺少必要的信息和充分的讨论，也无法更进一步参与。实际情况也是如此，内部的活动别说讨论和设计文档，就连提交都不是实时同步的。此外，项目在两个平台上的活动，基本只有一名维护者出面在处理。</p>
<p>企业开放内部项目源代码，允许任何人学习和使用，是有社会价值的。但是内外两套工作流，甚至开放可参与的工作流只是个添头，那就不可能形成开源共同体。如果这就是预期的目标，那倒也没事。只是对于辛苦应付这些留下来的缺口进来的简单补丁的维护者来说，他是否会觉得这只是另一种值班呢？无论如何，工作流的统一都有助于减少损耗。不管是干脆只保留内部工作流，托管平台上的所有活动都没有回应保证，还是尝试融合到开放工作流，真正做到开源协同，都比牺牲一部分人，做一些创造出来的边缘工作要好。</p>
<h3 id="Case-Study-Apache-InLong-incubating"><a href="#Case-Study-Apache-InLong-incubating" class="headerlink" title="Case Study: Apache InLong (incubating)"></a>Case Study: Apache InLong (incubating)</h3><p>致力于融合到开放工作流的典型案例是 <a href="https://github.com/apache/incubator-inlong">Apache InLong (incubating)</a> 项目。这个项目是由腾讯捐赠给 Apache 软件基金会的数据流处理平台。</p>
<p>在项目开放初期，也存在只有内部工作流的情形。不过得益于主要维护者的软件工程经验，在明确项目要以开源协同的方式运作以后，经过对维护两套开发流程弊端的分析，得出了要融合工作流的结论。既然是开源协同，那么融合的工作流就是共享工作流了。</p>
<p>一段时间的改造后，原先内部工作流的核心流程被迁移到共享工作流当中，包括问题报告、补丁提交和版本发布。原先内部工作流服务于企业需求的部分则基于共享工作流构建。</p>
<p>企业内部仍然有用户问题报告，但是归结到项目本身缺陷的问题，会脱敏之后报告到 GitHub Issue 上。为了解决紧急问题，企业内部的 fork 版本仍然会打临时补丁快速上线，但是救火之后正式修复的补丁会以 contributing back 的形式提交到开源项目上。最后是版本发布。一开始，只有内部项目在发版。开放源代码之后，就有两个同类项目要分开发版。经过一系列的改进，主要是问题报告和补丁提交的及时同步，最终两个项目能够以较小的同步开销同时发版。换句话说，GitHub 上托管的版本，就是企业内部使用的版本。企业内部可能有一些临时补丁，但是并不构成一个差异化内部版本，并且这些补丁是积极地被推进 contributing back 上游的。</p>
<p>可以看到，确定开源协同开发项目的方向后，共享工作流不是形式主义，而是能切实提高软件工程效率和减少摩擦的方案。</p>
<p>对于企业本身依托开源项目建立的情况，要维持共享工作流也存在很多挑战。这些挑战大多出自一个原因，那就是最佳实践的匮乏导致节外生枝的私下讨论。</p>
<h3 id="Case-Study-TiDB"><a href="#Case-Study-TiDB" class="headerlink" title="Case Study: TiDB"></a>Case Study: TiDB</h3><p><a href="https://github.com/pingcap/tidb/tree/master/docs/design">TiDB</a> 的代码仓库中有专门存放设计文档的目录。理论上，新功能，行为变更，以及其他重要改动，都需要一个设计文档。</p>
<p>我们可以从设计文档的时间线看出这一工作流的变迁。</p>
<ul>
<li>2018 年下半年，共 17 份设计文档。</li>
<li>2019 年全年，共 6 份设计文档。</li>
<li>2020 年全年，共 13 份设计文档。</li>
<li>2021 年至今，共 19 份设计文档。</li>
</ul>
<p>从另一个维度看，2019 年 5 月到 10 月，2020 年 10 月到次年 2 月，一共将近一年的时间里，项目没有提出过任何设计文档。</p>
<p>那么，TiDB 项目在此期间是停止开发了吗？没有。它一直以每个工作日合并 10 个 PR 以上的开发速度在前进。在此期间关于功能设计的讨论，其实是转进了企业的即时通讯工具或内部文档当中了。我们可以看几个例子。</p>
<ul>
<li><a href="https://github.com/tikv/tikv/issues/10540">Raft Async IO</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/25970">SPM Enhancement</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/26085">Cardinality Estimation Enhancement</a></li>
</ul>
<p>这几个功能并不是没有设计，而是只在小范围内通过中文文档做出设计，就开始实现。甚至在 Cardinality Estimation Enhancement 的例子当中，以为 contributor 想了解功能设计和背景，被 assignee 以时间紧迫为由回绝。虽然 assignee 承诺会在完成后进一步披露消息，但是却没了下文。</p>
<ul>
<li><a href="https://internals.tidb.io/t/topic/372/7">Announcing remove required integration test check when merge pr</a></li>
</ul>
<p>另一个例子是 pull request 上的检查项变更。不仅整个过程是在企业内部决策后直接在开源项目上上线，共同体内的其他成员一无所知，而且对于 bad case 的处理依赖于企业内部的群聊，让人摸不着头脑。</p>
<p>其实这些案例，我相信相关成员并不是刻意要伤害开源共同体。设计和开发的需求是天然存在的，持续集成的改动也不是不能做，但是实际推动落实的成员，缺乏开源共同体当中工作的经验，难以站在一家企业之上的视角，以合理的方式开展工作，才导致了这些实际伤害了开源共同体的做法。</p>
<p>我在这两个方向都做过一些改良的工作。对于设计文档，我发起了一个 Public Design 的讨论，并且推动了几个重大改动的公开设计。在此过程中和复数的开发者沟通了公开设计的技巧，以及在此前提下如何高效地推进重要改动的落实。实际上，公开设计并不会损失效率。因为并不是内部讨论完成后拿出来公示，而是从一开始就放在公开渠道讨论。既然是开源协同，补丁提交本身也是公开的，这些材料有什么好隐藏的呢？相反，因为得到了潜在的更多反馈，能够在设计等早期阶段避免缺陷，反而公开设计是更加高效的手段。</p>
<ul>
<li><a href="https://internals.tidb.io/t/topic/399">Discuss: Public Design</a></li>
<li><a href="https://github.com/tikv/pd/issues/3839">Tracking issue for Region Label Feature</a></li>
<li><a href="https://github.com/tikv/rfcs/pull/67">RFC: Substitute RocksDB write stall</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/26020">Tracking issue for heuristic rules enhancement for index selection</a></li>
</ul>
<p>对于持续集成，企业内部把研发和工程效能分成两个竖井，又把开源共同体仅关联到研发的工作上去，是这个问题的根源。组织结构问题不好解，只能先改变工程效能团队的员工的认知。当他以开源共同体成员的身份变更项目基础设施的时候，也通过提交议题，达成共识后实施的工作流来推进。实际上，这样改变以后，关注到项目功能开发的成员与维护基础设施的成员更能坦诚的交换意见，避免意料之外的改变激发矛盾。</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/issues/28947">Integrate UT coverage with CI pipeline</a></li>
</ul>
<h3 id="Case-Study-Taichi"><a href="#Case-Study-Taichi" class="headerlink" title="Case Study: Taichi"></a>Case Study: Taichi</h3><p><a href="https://github.com/taichi-dev/taichi">Taichi</a> 是一个主要面向计算机图形学的并行编程框架，由胡渊鸣博士发明。去年，他作为联合创始人创立了太极图形公司来支持项目的发展。</p>
<p>项目早期基本是胡老师一个人的工作。开放源代码并有 contributor 加入后，画风是这样的。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/1836">[async] Implement basic StateFlowGraph</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/479">Allow ti test_python to take in individual test files</a></li>
</ul>
<p>这两个 pull request 的三位参与者，彼时分别在美国波士顿、日本东京和中国上海。当时也没有成立公司，更不谈有企业内部的即时通讯工具或文档空间。所以你可以看到所有必要的讨论都发生在 GitHub 平台上。</p>
<p>时间拉回到现在，部分项目的开发仍然是有迹可循的。比如有个置顶的 <a href="https://github.com/taichi-dev/taichi/issues/2398">RoadMap</a> 作为当前正在投入的工作的地图，比如 <a href="https://github.com/taichi-dev/taichi/issues/3301">Taichi 编译器前端类型检查</a>有个 tracking issue 来记录工作。</p>
<p>不过，也会出现我在昨天看到的无描述 4000 行改动无评论合并的案例。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/3567">[Mesh] The ti.Mesh class &amp; mesh-for loop implementation</a></li>
</ul>
<p>经过社交媒体的传播，目前这个 pull request 更新了部分描述。其实是一个学术研究相关的功能，在发出论文后希望 contributing back 到上游。由于变更较为复杂，早期设计出于研究原因不便公开，加上持续集成流水线的效率问题，所以采用了一步到位的合并方案。代码 review 私下发生在提交之前。</p>
<p>那么，这些信息昨天凌晨看到的我能够知道吗？答案是不能。</p>
<p>其实这种提交一个大改动的案例并不少见。Apache Flink 项目曾经多次发生过这样的事情，包括 2014 年 7 月合并 streaming 的原型，2019 年合并阿里巴巴内部版本 BLINK 等等。项目接受来自企业或学术团体的 contribution 是很正常的，其他开源项目也有研究室基于项目做出优化策略后 contributing back 的案例。</p>
<ul>
<li><a href="https://lists.apache.org/thread/mc4622swvv1y4dbty5x20rlh3whdjst5">[DISCUSS] A strategy for merging the Blink enhancements</a></li>
<li><a href="https://lists.apache.org/thread/mn1nf4p11t054zmhdglorjt40xoyz7wv">[ANNOUNCE] Contributing Alibaba’s Blink</a></li>
</ul>
<p>开源共同体接受 contribution 的标准做法仍然是公开讨论。只需要说明这件事情，解答潜在的疑问之后决定接受或拒绝 contribution 即可。如果 ti.Mesh 的研究结果是以这样的形式合并到代码仓库的，我想在一开始我就不会有疑惑和疑惑导致的误会。另一方面，公开讨论和 contribute 对开源项目也是一种保护。Apache 项目在接收重要 contribution 时都会考虑引入一个<a href="http://incubator.apache.org/ip-clearance/">知识产权清理</a>流程，确保接收 contribution 不会引入知识产权相关的争端。</p>
<p>Taichi 项目当中缺乏背景信息的还有这些例子。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/3538">[bug] Remove fallback in C++ code</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/3433">[gui] Show f16 image as f32.</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/3279">[Lang] Support more SNode trees for LLVM backends</a></li>
</ul>
<p>当然，必须说明的是 Taichi 项目的大部分 pull request 是有背景信息的。上面这些案例的参与者，我想也不是刻意隐藏信息，而是成立公司之后，自然地在线下或者内部平台讨论。既然已经通过私下讨论得出结论，再刻意搬到 GitHub 上反而就是低效的。对于具备项目假设 contributor 应该有的知识就能理解的补丁，也不需要做作的讨论。</p>
<p>要想避免因为已经私下讨论得出结论，从而把共同工作流的一部分切换成内部工作流的情况，应该从两个方面入手。</p>
<p>第一个是在确定开源协同开发项目的方向后，所有技术讨论都以 GitHub 平台的内容为唯一信源。私下讨论是无法禁止的，只能从技术领袖开始以身作则，推动公开讨论。其实对于大部分企业员工来说，在哪讨论并不重要。真正让他们转向私下讨论的原因，是在 GitHub 上的评论得不到回复，而钉一下或者内部文档 at 有奇效。值得一提的是，Taichi 也有我曾经到的 TiDB 的问题，那就是没有一个活跃的开放式讨论渠道，即没有邮件列表的替代品。有个 Discourse 论坛，但是是面向中文用户而不是全球开发者的。开通了 GitHub Discussion 功能，但是只有唯一一个版本发布的公告。</p>
<p>第二个是作为共同体的领袖，应当积极寻找不同背景的参与者。如果已经形成了私下讨论的习惯，仅仅要求员工改变习惯是很难有效的。因为公开讨论的主要原因，是为了和企业以外的 contributor 交流，以获得有意义的输入和提高生产力。如果员工发现换个地方发言，得到的回应还是同事的回应，并且 GitHub 上的评论还是得不到即时的回复，这件事就推不下去。</p>
<p>前面的例子提到过，当 Taichi 的主要开发者天各一方，没有成立公司之前，这种沟通是自然而然的。实际上，Linux 和 Apache Httpd 也是这样的。除了邮件列表，Linus 很难找到另一个渠道收获他所需要的反馈。Apache Httpd 的早期成员一开始就是在邮件列表上沟通的。只有实际存在组织以外的高水平参与者，开源协同的最佳实践才有意义。对于企业员工来说，也才有直接合理的理由不在内部讨论。毕竟就某个特定的问题，他更希望听一听那个不同背景的共同体成员的意见。</p>
<h2 id="招募新成员"><a href="#招募新成员" class="headerlink" title="招募新成员"></a>招募新成员</h2><p>寻找不同背景的参与者，其实就是作为共同体的领袖为共同体招募新成员。这是企业实践开源协同的另一个难题。除了为企业招募以外，应该如何为共同体招募呢？</p>
<h3 id="End-user"><a href="#End-user" class="headerlink" title="End user"></a>End user</h3><p>第一个要讨论的是用户。不过，用户是开源协同之外的内容。商业产品同样需要自己的用户。大部分用户也不会关心软件是如何实现的。</p>
<p>所以，要讨论用户，其实是要驳斥一些错误的观念。用户能够为你提供使用反馈，能够通过付费或捐赠支持项目开发人员持续投入，但是期待从用户群体中大规模地发现核心 contributor 则是不切实际的。</p>
<p>我听到过很多项目领袖跟我说，他的项目是独特的，因为不像大数据项目那样，用户本身也是开发者。它可能是一个数据库。哎呀，用户都是 DBA 或者数据分析师，根本不知道数据库怎么实现的嘛。它可能是一个机器学习框架。哎呀，用户都只会操作 Python 接口，根本搞不来核心 C++ 代码。</p>
<p>那我就想问了，你咋不去找那些就做数据库的人，就搞机器学习框架的人呢？你给团队招聘的时候知道找这些人，怎么到了给共同体招募新成员，眼里就只看到用户了。</p>
<p>其实我也可以理解。因为开源协同不够普及，大部分人提到 open-source 这个概念，第一印象还是一个市场营销的手段。或者提到“运营开源社区”，就把用户社区那些已有经验都搬过来。在这样的认识下 open-source community 就是开源社区，而不是开源共同体。其中“我们”是唯一的开发者，是懂行的。其他人是只会小修小补的爱好者，或者干脆啥也不懂的用户。</p>
<p>这个误区有点像思维定式。你现在要找的是有能力开发项目的参与者，那就去对应的群体里找就可以了。</p>
<p>当然，如果你就想做用户社区，就没打算搞开源协同，也是一种选择。对于这类需求，我建议研究 MongoDB 的做法。它们搞得挺好，这里就不展开了。</p>
<h3 id="Ecosystem"><a href="#Ecosystem" class="headerlink" title="Ecosystem"></a>Ecosystem</h3><p>抛开用户不谈，开源共同体当中的 contributor 还可以进一步细分。其中有一类 contributor 关注生态互连，另一类关注项目的核心逻辑。</p>
<p>如果项目提供了足够多的扩展点，或者策略替换机制，那么关注生态互连的 contributor 就能够快速参与进来。</p>
<p>例如，Flink&#x2F;Spark&#x2F;Presto 等项目都设计了 connector 机制，连来连去就能创造出大量的工作。例如，几乎所有项目都可以搞多语言 SDK 玩玩。TiKV 就有不少于五种编程语言的客户端实现。例如，PostgreSQL 提供 FDW 机制，不仅支持连接外部数据源，更暴露了参与 planning 阶段的计算下推接口。例如，Linux 其实也有丰富的扩展机制，支持多种架构和驱动就是一个例子。</p>
<p>上面这些都是项目本身的机制，更广泛的生态还包括解决方案的整合。例如，从 Netty 的角度看，Flink 就是它的生态的一部分。从 Flink 的角度看，serverless 技术栈 StateFun 又是它的生态的一部分。经常听 database 的开发者说自己的软件直面终端用户，但是其实就互联网业务开发者来说，中间是隔了一层 ORM 框架的。哪怕是数据分析师，大概率也隔了一层可视化框架。另外，数据的同步和搬迁也是应用设计不可缺少的一部分，这就是各种中间件能发挥作用的地方了。</p>
<p>总之，这类 contributor 还可以再细分。一类是关注项目提供的机制替换实现的，大部分可以从有可能提供实现的项目开发者当中寻找。例如项目的部署机制希望支持 Kubernetes 环境，那找一个热衷于写 Kubernetes Operator 或者刚学会跃跃欲试的开发者参与，就很有可能产生正面效果。另一类是关注项目整合形成用户解决方案的。实际上，项目开发者最终基于项目实现盈利，往往就是以某种解决方案出现。只要你发挥想象力，生态整合的可能性就是个乘法，不愁找不到参与者。即使是核心逻辑被单一企业掌控的 MongoDB 项目，其生态也是非常繁荣的。</p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>当然，项目的核心逻辑也是非常重要的。如果项目本身不够坚挺，那么就不会有用户使用，也无法激起 contributor 连接生态的动力。</p>
<p>项目的核心逻辑是一个项目的主要价值。这些逻辑通常由项目的初始成员定义。在企业主导项目的情况下，这些初始成员往往背景单一。同时，出于传统组织观念的影响，初始成员往往以企业当中的项目团队作为自我认同，团队等同于项目，也因此将核心逻辑的开发层层“保护”在看不见的高墙之内。</p>
<p>以项目团队作为自我认同，无怪乎招募新成员的时候，自我认知自动翻译成团队招聘，而想不到还有其他可能性。</p>
<p>反观成功的开源项目，数据湖项目 <a href="http://hudi.apache.org/">Apache Hudi</a> 由 Uber 捐赠给 Apache 软件基金会，在项目快速发展过程中吸引到了阿里巴巴和 T3 出行等企业的员工的参与，并吸纳了上述企业背景的开发者作为项目 PMC 成员。对于后续参与的企业的员工来说，他们在企业当中虽然也有项目团队，但是显然不会觉得项目归企业内的项目团队所有。对于 Uber 来说，来自其他企业的核心 contributor 的声音也不可忽视。这样，Apache Hudi 成功建立了一个开源共同体。</p>
<p>要想为项目招募开发核心逻辑的参与者，我觉得应该做到以下三点。</p>
<p><strong>第一点是改变认知</strong>。上面已经介绍了错误认知的危害和避免错误认知的最终形态。我把这种正确的认知称为“开发者的两顶帽子”。同一个开发者，既是开源共同体的参与者，也是企业的员工。这两个身份虽然从属于同一个人，但是却有着不同的诉求。只有区分开这些不同的诉求，一部分是开源共同体的目标，一部分是企业基于开源项目创造商业价值的目标，才能避免认知混乱导致人为制造出参与的高墙。</p>
<p><strong>第二点是公开讨论</strong>。前面讨论的很详细了，这里再补充一个点。当你真的身处一个开源共同体当中，不做公开讨论才是奇怪的。例如 Apache Hudi 的例子，如果 T3 出行的开发者想要实现某个功能，除了公开讨论寻求共识，别无他法。</p>
<p>公开讨论还有一个额外的好处，那就是方便引用。不少基于开源项目建立起来的企业，运营人员整天发愁哪里有技术内容可以发布，写技术文章好像变成了一个苦差事。其实技术话题公开讨论，天然的就有高质量的内容可以推送，其中悬而未决的议题，也是 contributor 参与的绝佳切入点。例如 <a href="https://twitter.com/engulaio">Engula</a> 项目在社交媒体的输出，基本就是设计文档或者开放式讨论里值得发布的内容。</p>
<p><strong>最后一点是积极招募</strong>。前面分析 Taichi 的例子也提到过，认知改变的假设需要多样化的开源共同体成员来验证，保持公开讨论的做法也需要不同背景的 contributor 参与。除了公开讨论能够吸引到潜在的参与者，积极招募更意味着共同体的领袖要主动思考谁是你要找的人。</p>
<p>对于每个项目来说，这个问题的答案都不一样。但是认为这个问题没有答案，或者说人才都在企业当中了，则是一种傲慢。</p>
<p>同样举数据库的例子，哪怕你有 Oracle 那么大，世界上也还有相当一批人在开发 PostgreSQL 等项目。这些人并不是一辈子就做这一件事的。只要你的项目足够有趣，他们就有可能投入。</p>
<p>另一方面，泛泛而谈数据库这样一个复杂的领域其实是一种懒惰。既然复杂的项目本身会分模块开发，为什么在招募新成员的时候就只想着完全理解整个领域的人呢？如果项目的并发设计不佳，只要是精通该语言并发编程的专家，愿意 contribute 做改进，你管他懂不懂数据库的专业概念。醉心于编译器前端的开发者，也许能解决 SQL Parser 当中经年的性能问题。进入 Apache 孵化器的项目的导师，往往也不是项目所在领域的专家，甚至不是开发者，但是他们能够帮助项目以 Apache 的方式建立起开源共同体。</p>
<p>以这样的方式去寻找潜在的开发核心逻辑的成员，相信你的视野会更加广阔。</p>
<p>其实，这才是“开源共同体”的含义。不止于项目，也不是社区居委会，而是围绕开源项目的发展，基于对项目的认同，形成的多层次合作共同体。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
        <tag>企业开源</tag>
      </tags>
  </entry>
  <entry>
    <title>开源共同体的治理模型</title>
    <url>/2022/01/06/open-source-governance/</url>
    <content><![CDATA[<p>随着越来越多新的要素进入开源领域，如何建立一个高效的开源共同体，如何维护一个富有价值的开源共同体，逐渐成为每个参与者或多或少关注的问题。</p>
<p>Apache 软件基金会为每个项目提供了基础的治理原则，并在项目孵化到顶级项目的过程中通过孵化器导师的帮助建立起开源项目的治理模型，但是这一模型对每个具体项目在特定时期未必是最优的。同时，其他不在 Apache 软件基金会治理的项目，虽然拥有灵活设计治理模型的自由，却也时常陷入不知道该如何开始的窘境。</p>
<p>本文从开源治理的目的出发，介绍一个开源共同体什么时候需要考虑设计治理模型，然后讨论开源治理的原则，结合实例分析如何设计开源共同体的治理模型。这里所说的开源共同体，主要指的是围绕单一项目或单一主题项目群形成的开源共同体。</p>
<span id="more"></span>

<h2 id="开源治理的目的"><a href="#开源治理的目的" class="headerlink" title="开源治理的目的"></a>开源治理的目的</h2><p>讨论开源治理的首要问题是，对于特定的开源共同体，当前阶段下是否需要治理。这个问题的解答可以从<a href="https://book.douban.com/subject/26976995/">《社区运营的艺术》</a>一书中对相同问题的讨论得到。书中认为，需要开源治理的主要原因包括</p>
<ul>
<li>社区规模激增</li>
<li>冲突越来越多</li>
<li>资源多</li>
<li>商业利益</li>
</ul>
<p>总的来看是两个问题。其之一是参与者和资源增加以后，维持开源共同体高效运转的挑战；其之二是不同背景的成员加入，不同要素进入之后，维护开源共同体的核心价值，也就是生产满足目标用户的高质量软件。</p>
<h3 id="建立高效的开源共同体"><a href="#建立高效的开源共同体" class="headerlink" title="建立高效的开源共同体"></a>建立高效的开源共同体</h3><p>开源共同体围绕开源软件而建立，其主要目的就是制造高质量软件，以满足目标用户的需要。这意味着生产代码、撰写文档、解答问题和市场营销都是开源共同体工作内涵的一部分。</p>
<p>项目启动阶段，尤其是功能尚未丰富的时候，交付核心功能是第一要务。这个阶段，往往项目参与者不过几个人甚至就是一个人的工作，也不会有太多的关注者和用户。这个阶段是不需要引入复杂的治理模型的，简单的项目创始人掌握所有权力并决策所有事务即可。没有核心开源软件创造价值而沉迷于设计治理模型，只不过是空中楼阁。唯一跟治理模型沾得上边的，就是留心并记录这个阶段当中软件开发的流程和决策惯例及案例。</p>
<p>随着项目核心功能的实现和迭代，产生的价值能够吸引到目标用户使用，更多的参与者被项目吸引或用户需求所推动着了解项目。同时，开源项目的成长也带来了对资源的需求，例如持续集成的基础设施，沟通渠道的维护，直接支持项目开发的资金捐赠的处理，围绕开源软件的活动和宣传的运营和开销，等等。新成员的加入带来沟通成本的提高，丰富的资源需要一定的流程和负责人维护才能合理得到使用。这个时候，设计一个治理模型以维持开发效率和决策效率，就是有必要的了。</p>
<p>治理模型通常体现为一个或几个治理机构及其职责和沟通方式。在维持高效的开源共同体的话题上，这些治理机构主要解决以下问题。</p>
<ul>
<li>批准或拒绝新成员加入。特别地，你可能为成员定义不同的身份，例如一般成员、开发者或其他贡献者，等等。</li>
<li>解决冲突。</li>
<li>明确项目价值，落实开源共同体的核心价值观。</li>
<li>修改流程。</li>
<li>如果开源共同体日渐复杂化，治理机构可能需要派生出新的治理机构。</li>
<li>决定方向。</li>
</ul>
<h3 id="维护开源共同体的核心价值"><a href="#维护开源共同体的核心价值" class="headerlink" title="维护开源共同体的核心价值"></a>维护开源共同体的核心价值</h3><p>如同前文所述，开源运动热火朝天引得越来越多新的要素进入这个领域，政治要素和资本要素就是其中不可忽视的两个。许多开源共同体都有商业赞助商和投资者。这些赞助商的员工当中往往有不少是开源共同体的参与者，通过参与做出对赞助商有利的贡献。有时候开源共同体只有一个赞助商，它可能就是一开始创立项目的企业。这种情况下，赞助商和投资者会主动寻求建立某种治理模型，以明确自己为开源共同体做出的投资所能得到的回报的预期。</p>
<p>例如，《社区运营的艺术》提到，Linux 发行版 Fedora 和 OpenSuSE 对应的赞助商 RedHat 和 Novell 在各自的开源共同体当中都通过制度保证了足够多的席位以推行任何他们想要推行的主张，而 Ubuntu 对应的赞助商 Canonical 仅在所有七名成员中保留一个席位且其他成员多数不是为该公司工作的。国内首个开源基金会开放原子开源基金会，其技术指导委员会的席位为主要捐赠人每家预留一位。TiDB 设计的技术委员会成员，必须是 PingCAP 员工、PingCAP 社区伙伴员工或社区项目代表。</p>
<ul>
<li><a href="https://www.oschina.net/news/119227/openatom-foundation-technical-oversight-committee">揭秘开放原子开源基金会 TOC 设计</a></li>
<li><a href="https://github.com/pingcap/community/blob/06051f58b4e448a6d73ff63423c8adeb8f47f7ab/toc/README.md">TiDB Community Technical Oversight Committee</a></li>
</ul>
<p>反之，Apache 软件基金会则强调 Community of Peers 即共同体由个人组成，而非组织。Kubernetes 虽然会展示成员的组织关系，但是治理模型当中也不体现赞助商或投资者的特权。</p>
<ul>
<li><a href="https://www.apache.org/theapacheway/index.html">BRIEFING: THE APACHE WAY</a></li>
<li><a href="https://www.apache.org/foundation/how-it-works.html#hats">INDIVIDUALS COMPOSE THE ASF</a></li>
<li><a href="https://www.kubernetes.dev/community/values/#community-over-product-or-company">Community over product or company</a></li>
</ul>
<p>《社区运营的艺术》提到，一般的志愿者社区，比如开源项目，赞助和投资方应该不参与治理机构。</p>
<blockquote>
<p>我这样说并不是因为商业赞助是不可信的，而是因为与志愿者关联的社区往往是建立在所有成员的贡献之上的，而这些成员积极贡献的目的，就是保证他们的辛勤工作有助于同侪和社区的未来。</p>
</blockquote>
<p><a href="https://book.douban.com/subject/35531548/">《People Powered》</a>当中进一步解释了这个论点。</p>
<blockquote>
<p>你的社区受到两个因素的驱动，一个是成员自身的利益，另一个支持社区获得更大的成功。除组织内部社区等极少数外，你的社区成员为社区工作，而不是为你工作。这常常使那些坚持“如果公司成功，社区也将从中受益”的公司受挫。这句话没错，但不重要。这不是大多数社区成员的想法，也不是社会经济运作的方式。</p>
</blockquote>
<p>为了应对赞助和投资方的提案，协调开源共同体当中各方的需求以达到共同体利益最大化，避免分化，需要设计一个相应的治理模型。</p>
<h2 id="开源治理的原则"><a href="#开源治理的原则" class="headerlink" title="开源治理的原则"></a>开源治理的原则</h2><p>不同开源软件的特点，开源共同体的成员组成和所处阶段的差异，都会影响治理模型的设计。我在 <a href="https://mp.weixin.qq.com/s/POhfL4zrrmUHZUWGNWQbpw">夜天之书 #18 Evolving Governance</a> 和 <a href="https://mp.weixin.qq.com/s/QokLLyPMPpa7cVW-54DwCA">夜天之书 #25 Evolving TiDB Governance</a> 里已经讨论了特定开源共同体的治理模型设计权衡。</p>
<p>本文尝试从开源治理的原则出发，讨论根本的设计思路。开源治理的原则总的来说是以下两条。</p>
<ul>
<li>开源共同体利益至上</li>
<li>摈除丑陋的形式主义</li>
</ul>
<h3 id="责任感"><a href="#责任感" class="headerlink" title="责任感"></a>责任感</h3><p>要想落实“开源共同体利益至上”的原则，必须保证治理机构的成员对开源共同体有一种真正切身的责任感。</p>
<p>与其说开源治理是制定一系列规则并任其自动运行，不如说是找到具备领导能力且愿意为共同体发展承担责任的优秀人才。开源共同体当中常见的角色 Committer 抛开其提交代码的权限，词源本意即“做出承诺的人”。</p>
<p>开源软件由志愿者开发，在志愿者环境中是无法强制一个人参与的。有些志愿者能够每天都投入到共同体工作中，而其他志愿者仅在情绪不错时参与工作。后者的贡献值得感谢，但是他们通常不能承担治理责任，也不具备领导能力。对于围绕开源共同体做出的重大决策以及合并补丁和发布版本等核心活动，掌握权限的核心成员必须维护开源共同体利益，必须显示出强烈的责任感和使命感。换句话说，核心成员要对自己的行为负责，当开源共同体为了完成某些任务而全力以赴时，核心成员必须腾出时间来为之工作。</p>
<p>《社区治理的艺术》提到，责任感是宝贵财富，它相当于你在社区得到的承诺宣言。一些成员会有这样的责任感，而另一些则没有。有责任感的人是宝贵的资源，你可以委以重任，但是不可以利用他们的责任感。</p>
<p>例如，我在多次和 Apache Flink 的 PMC Chair Stephan Ewen 沟通的过程中，都能感受到他对项目的热忱。这种热忱支持着他十多年来投入到项目的开发、发布和宣传当中。即使自己所创办的基于 Apache Flink 提供服务的公司已经被收购从而财富自由，即使面对诸多邀约有不少早期成员开始投入新的项目，他却始终坚持发展 Apache Flink 以满足用户的需求。例如，Linus 在 2022 年伊始就在<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=278218f6778bc7d6f8b67199446c56cec7ebb841">合并提交到 Linux 项目的补丁</a>。例如，Apache SkyWalking 的创始人吴晟和 ClickHouse 的创始人 Alexey Milovidov 都以快速处理开源项目当中的评论、议题和补丁著名。</p>
<p>项目的创始人通常是对项目抱有最高责任感的人。因此，在设计治理模型的时候，直接把创始人排除在外是不可接受的。《大教堂与集市》当中讨论“Locke 及土地所有权”的时候也提到过这个模型。然而，不少形式化开源的项目，指派了一个或几个所谓的“社区运营专员”来架设治理模型，往往就把创始人反而排除在外。这是彻底的形式主义，也是错误分工带来的恶果。</p>
<p>Zoom.Quiet 对此有过评论，</p>
<blockquote>
<p>这其实才是最大的天劫。项目开始时，大家的目标是不言而明的，因为是小团队多年的相同愿望。但是，有新人进来时，才发现没有之前多年的共事根本无法简单说清。所以，有所谓专家或布道师来接替创始团队来解释时，核心成员如果不认同，嘴又笨，直接表现就是不活跃了。看起来，是更加专业的专家替代了土领导，可其实，社区已经空心化了。毕竟不是谁都有 Linus 的嘴炮能力。</p>
</blockquote>
<p>不得不感慨，Linux 能成功，Linus 功不可没。《时代周刊》做过一个有些极端的评论，但不无道理。</p>
<blockquote>
<p>有些人生来就注定能领导几百万人，有些人生来就注定能写出翻天覆地的软件。但是只有一个人两样都能做到，这就是林纳斯。</p>
</blockquote>
<p>创始人的缺位会给开源治理留下很深的阴影。例如，Rust 项目的创始人 Graydon Hoare 并没有坚持做 Rust 项目，核心成员 Brian Anderson 和 Niko Matsakis 还有 Alex Crichton 等等都不在最高治理机构 Core Team 里。同时，Core Team 的人员更替并不谨慎，导致部分成员难以服众。这是前不久 <a href="https://github.com/rust-lang/team/pull/671">Moderation Team 和 Core Team 矛盾</a>的深层原因之一。</p>
<p>核心成员的传承也要基于责任感。例如 Apache 软件基金会现任董事会成员 Justin Mclean 和吴晟，都非常关注孵化器当中新项目的加入和成长，关注 ASF 项目面临的法务挑战，关注 Apache License 的采用情况，等等。例如 2020 年新加入 PostgreSQL 的 Core Team 的成员都是经年参与 PostgreSQL 共同体的志愿者。</p>
<p>可以说，只有核心成员对开源共同体有切身的责任感，才能践行“开源共同体利益至上”的原则，其他成员也才能信任这样的治理机构能够领导和鼓励共同体向前发展。</p>
<h3 id="精英领导制"><a href="#精英领导制" class="headerlink" title="精英领导制"></a>精英领导制</h3><p>这里提到的精英领导制是一种组织管理体系，成员在共同体当中受到的尊敬和能够承担的职责，取决于他所做的贡献，而不是金钱、社会阶层和家庭关系。换句话说，就是“唯才是举”的理念。</p>
<p>要想落实“开源共同体利益至上”的原则，强调精英领导制是有益的。当然，对于这个词感到陌生的人，可以多谈论一些平等性，多提供一些成员如何通过自身的努力，去建立声望的例子。</p>
<p>精英领导制强调了对开源共同体的贡献是赢得权威的唯一方式。这种贡献的衡量与个人所绑定，与其所属的组织无关。避开资本要素的影响，使得开源共同体能够最大限度的接纳新的参与者，并通过对参与者贡献的衡量和他们与其他核心成员共同工作的方式来选拔新的核心成员。</p>
<p>不同于彻底的独裁治理模型，精英领导制实际上暗示着项目由多人共同治理，而加入治理机构的核心成员必须通过其贡献和工作方式赢得其他核心成员的认同。这种方式在 Linux 项目当中也被部分采用。虽然 Linus 仍然是名义上的独裁者，但是 <a href="https://www.kernel.org/doc/html/latest/process/maintainers.html">Linux 的维护者列表</a>早就突破了一千人。当然，他们并不享有和 Linus 一样的权利，但是他们获得对应职责的基础，也是对相应模块的贡献。</p>
<p>这样，我们就确定了项目所有权的分配方式，即完全通过贡献来衡量。衡量者是现有的核心成员。建立项目自然是最大的贡献之一，持续参与，软件重大改进，催化参与热情与质量，完善文档，代表共同体或项目发声，都是值得考虑的因素。</p>
<p>例如，PostgreSQL Core Team 现在和过去的成员做出的贡献在其 <a href="https://www.postgresql.org/community/contributors/">Contributor 页面</a>上展示。</p>
<table>
<thead>
<tr>
<th align="left">核心成员</th>
<th align="left">主要贡献</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Peter Eisentraut</td>
<td align="left">构建系统，软件移植，文档及其国际化，持续的代码贡献。</td>
</tr>
<tr>
<td align="left">Andres Freund</td>
<td align="left">JIT 机制，逻辑解码，数据复制，性能和可扩展性，修复 bug 和 review 补丁。</td>
</tr>
<tr>
<td align="left">Magnus Hagander</td>
<td align="left">完成向 Win32 系统的移植，鉴权机制，维护项目网站和基础设施。</td>
</tr>
<tr>
<td align="left">Jonathan Katz</td>
<td align="left">项目推广，版本发布新闻稿，维护网站，作为其他 PG 相关委员会成员的贡献。</td>
</tr>
<tr>
<td align="left">Tom Lane</td>
<td align="left">所有方面。其中包括评估缺陷和修复，性能改进，新功能落地。同时是优化器模块的责任人。</td>
</tr>
<tr>
<td align="left">Bruce Momjian</td>
<td align="left">维护项目 TODO 列表，处理补丁，代表项目在会议上发言。</td>
</tr>
<tr>
<td align="left">Dave Page</td>
<td align="left">pgAdmin 的作者，维护项目网站和基础设施，以及安装包。</td>
</tr>
<tr>
<td align="left">Josh Berkus</td>
<td align="left">项目推广，用户群组推广，性能测试，调优和文档撰写。</td>
</tr>
<tr>
<td align="left">Marc G. Fournier</td>
<td align="left">协调员，管理项目网站，邮件列表，文件服务器和代码仓库，等等。</td>
</tr>
<tr>
<td align="left">Thomas G. Lockhart</td>
<td align="left">文档撰写，实现数据类型尤其是时间类型和几何类型，SQL 标准适配。</td>
</tr>
<tr>
<td align="left">Vadim B. Mikheev</td>
<td align="left">重大功能实现，包括 WAL 和 MVCC 等功能。</td>
</tr>
<tr>
<td align="left">Jan Wieck</td>
<td align="left">数据复制系统 Slony 的作者，实现了一系列重大功能。</td>
</tr>
</tbody></table>
<p>可以看到，代码贡献是主轴，但也包括了维持项目运转和扩张的其他多层面的贡献。</p>
<p>精英领导制还有另一层含义，就是任何人都可以参与到技术讨论，技术实现和共同体决策当中来。虽然核心成员承担决策的职责，但是他们并不形成寡头政治。也就是说，核心成员的身份及其承担的职责是一种权力，而非特殊的权利。在一个健康的开源共同体当中，任何成员都可以做技术讨论，提交补丁，也可以就共同体发展话题提出自己的观点。技术最优的方案应当获胜，共同体利益最大化的决策应当通过。</p>
<p>精英领导制也并非是完美的。<a href="https://book.douban.com/subject/35586814/">《精英的傲慢》</a>一书当中提到，无论怎样强调“唯才是举”，精英的成功与天赋和运气等因素都是有关的。过分强调精英领导制，会助长赢得权威的人认为一切都是自己所应得的，对于没有赢得权威的人，则会感到屈辱和被排除在外。</p>
<p>《精英的傲慢》主要讨论的是社会问题，但是对于开源共同体这样一个特殊的群体，也是有启示的。我们前面强调了权力而非权利，即从根本上结构了共同体当中赢家与输家的关系。不过，不同身份的存在仍然有潜在的冲突风险，因此在选拔核心成员的时候，也要注重他对于权威的认知和个人的品质。</p>
<p>例如，<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>一书当中提到了谦逊的价值。</p>
<blockquote>
<p>谈吐柔和也是有用的，如果某人希望成为一个成功项目的维护者，他必须让社区信服他良好的判断力，因为维护者的主要工作是判断他人的代码。谁愿意将代码贡献给一个明显不能正确判断自己代码质量的人？或者一个试图从项目中沽名钓誉的人？潜在的贡献者希望项目领导人在客观采用他人代码时，能够谦逊而有风度地说：“是的，这个的确比我的代码好，就用这个了。”然后将荣誉给予应得之人。</p>
</blockquote>
<p>最后，由精英领导制建立起来的治理机构应当能够自省，以永远保持质量，代表开源共同体的前进方向。这不意味着要对每个成员限制任期，如果有人能把开源共同体治理得很好，应该允许他们一直干下去。但是，根据核心成员参与共同体各项活动的程度，工作情况的综合评价来判断是否应该取消某位成员的资格。</p>
<p>例如，PostgreSQL 共同体将在每年的 pgCon 峰会上发布新一年的 Committer 名单，不再活跃的成员将被移出。</p>
<h3 id="坦诚沟通"><a href="#坦诚沟通" class="headerlink" title="坦诚沟通"></a>坦诚沟通</h3><p>开源共同体要想高效运转，坦诚的沟通是必不可少的。</p>
<p>例如，前文提到的取消核心成员资格这样的决策，如果没有事前沟通，不仅当事人基本不可接受，而且其他成员将笼罩在无形监视的阴影下。例如，前文提到的 Rust 共同体 Moderation Team 和 Core Team 的冲突，没有任何关于细节内容的披露，每个人都在说那里有一些问题，是什么问题不方便说，谁牵扯其中不方便说，后续要如何处理不方便说。这样的表现只会让人对这两个治理机构都丧失信心，无法信任他们做出的决定是公平的。</p>
<p>坦诚沟通依赖相应的渠道。Apache 软件基金会要求所有讨论都发生在邮件列表上，因而是公开可追溯的。我在设计 Engula 共同体的沟通渠道时，根据项目的特点，把 Single Source of Truth 设置成 GitHub 平台，包括 issue 和 pull request 以及 discussion 论坛。所有其他渠道沟通的结果，都必须回到唯一的渠道上再次确认。通过这样的设计，能够支持全球性开源共同体的异步协作，并且保证所有信息都是公开的，也就消除了关于决策缘由的顾虑。</p>
<p>实行坦诚沟通的好处不必多说，绝大部分人都希望得到真实的信息，收获真实的反馈。真实的信息帮助共同体成员为最大化共同体利益努力，真实的反馈帮助共同体成员正确地行事。不过在设计治理模型的时候，关于沟通有两个点需要强调。</p>
<p>第一个是坦诚不代表攻击性。<a href="https://book.douban.com/subject/35102294/">《不拘一格》</a>一书中强调坦诚沟通的重要性，但也提示组织管理者需要警惕“有才华的混蛋”。</p>
<blockquote>
<p>如果周围全是聪明人，你可能就有危险了。有时候，有才华的人听到的赞美之词太多，就会觉得自己真的比其他人更优秀。如果有他们认为不明智的想法，他们可能会报以嘲笑；如果有人发言不够清晰，他们可能会翻白眼；他们还会侮辱那些他们认为天赋不如自己的人。换句话说，这些人就是浑蛋。</p>
<p>如果你在团队中倡导坦诚的文化氛围，就必须把这样的人剔除出去。许多人可能会认为“这个人确实很聪明，没有他不行”，但是，不管这样的人有多么出色，如果让他留在团队里，你营造坦诚氛围所付出的努力就不会有太好的效果。浑蛋对整个团队的效率有很大的影响，他们可能会将你的组织从内部撕裂。因为他们老是喜欢中伤同事，然后丢下一句：“我这是坦诚。”</p>
</blockquote>
<p>对于开源共同体而言，这就意味着需要切实践行行为准则（Code of Conduct），对这类攻击性行为说“不”。</p>
<p>额外多说一句，不少共同体从 GitHub 或者推崇的其他项目当中拷贝了行为准则，但是核心成员可能都不知道行为准则当中写了什么。这是不可接受的。我在撰写 Engula 共同体的参与者文档的时候强调了行为准则的重要性，并认为如果一个人想要成为核心成员，必须了解和实践行为准则。否则任何的文档不过是一纸空文。</p>
<p>第二个是必要的隐私渠道，包括安全问题报告、违反行为准则报告以及选拔成员讨论等等。安全问题不必多说。后面两者涉及到对人的评判，在得到合适的结论之前不应该全部披露。</p>
<p>这是因为，根据精英领导制的精神，唯才是举的评判应该来自于现有的核心成员团队，而不是民粹主义式的公投。一个开源项目会发展成什么样子，取决于核心成员是什么样的。他们是最有话语权的一群人，应该对项目抱有切身的责任感。如果核心成员团队被腐化了，或者他们本来就抱持着其他目的，那么这个项目就完蛋了。核心成员承担项目所有权，为项目的发展负责。如果其他成员认为核心成员违背了开源共同体的核心利益，标准做法是发起分支。</p>
<p>不过，决议的内容应该公示并向共同体成员解释原因。这就意味着秘密推举新的核心成员是不可接受的，同样，以莫须有的罪名惩罚共同体成员也是不可接受的。</p>
<h3 id="适应性"><a href="#适应性" class="headerlink" title="适应性"></a>适应性</h3><p>适应性体现的是“摈除丑陋的形式主义”的原则。也就是说，治理模型的设计应该倾向于适应开源共同体的发展，而不是做空中楼阁的设计。</p>
<p>大多数开源共同体需要应对三类问题，即综合治理，确定方向以及专业化治理。综合治理指的是围绕共同体的综合性话题做出决策，例如如何加入共同体，资源和基础设施的维护，工作流程，治理的改变等等。确定方向指的是围绕共同体的目标、愿景和当前焦点做出决策，例如开发软件所要解决的问题，目标用户，以及当前所要关注的特性集等等。专业化治理适用于开源共同体成长到一定规模以后，针对特定的专业知识领域需要专业的治理。例如，用户文档体积膨胀，而恰好有技术写作人才的参与。例如，Rust 的 Reddit 频道有自己的组织体系。例如，针对代码补丁的评审和缺陷的评估解决，也是专业化治理的一类。</p>
<p>对于一个刚起步的开源共同体来说，所有方向上的问题只需要一个治理机构来处理就够了。因为此时并没有太多的事情要处理，同时你也没有太多的成员能够参与到治理当中来。</p>
<p>不少设计开源共同体治理模型的人，盲目参考 Apache 软件基金会，或者 Kubernetes 等项目的玩法，货物崇拜式的对其治理模型进行像素级拷贝，最终发现并不适合自己项目的情况，而饱尝苦果。这其中最典型的就是引入多余的设计。预设具体的参与路径或治理细则，往往会导致无端的“运营成本”。随着项目的演进，参与情景的改变，预设前提不再生效，需要频繁修改，而并没有人实际践行。也就是说，所有设计和修改的付出都白费了。</p>
<p>《社区运营的艺术》提到，在理想的世界里我们不需要把治理放在首位，更不用说设置附加的分委会。每增加一层治理，你的社区就会丧失一些让大家易于理解的简单灵活性。只有在绝对必要时，你的社区才应设置附加的治理。</p>
<blockquote>
<p>只有当现有的治理机构不能扩展或满足社区需求时，附加的治理才是必须的。然而，有些社区不太明白这个道理，决意设计空洞的委员会：无非就是使新委员会的成员感到很特别。</p>
<p>…他们希望有一个治理委员会。在他们眼中，治理委员会能带来各种有趣的东西：对项目的控制感、权利和权力。不仅如此，他们认为一个社区之为社区，真正的社区委员会是必不可少的。</p>
<p>胡说。</p>
<p>此类委员会的成立根本没有理由。社区委员会的存在是为了解决问题，但是如果整个社区相对比较小，就没那么多问题需要解决。创建这个委员会，你实际上增加了官僚主义的风险。</p>
</blockquote>
<p>一个典型的例子就是单一项目阶段切分出许多模块团队，并为之建立起复杂的治理层级。我在此前讨论 TiDB 和 TiKV 的治理经验和教训的时候已经提到过，这种方式不过是割裂开源共同体而已。这种分割主要的缺点是很难切得恰到好处，出现问题讨论和修复带来的治理开销太大。如果不修订，实际情况一般是团队成员权限不足，核心团队不停兜底。</p>
<p>例如，早期 TiDB 将代码分成 DDL 和 Planner 还有 Execution 三个部分，那么数据库权限的问题谁来处理呢？一般性的并发实用函数，数据格式等等问题，谁来解呢？后来又把 DDL 团队泛化成 SQL Infra 团队以期兜底，但是实际上他们还是只处理部分问题。例如，TiDB 的 telemetry 模块目前就是无人负责的。</p>
<p>实际上，代码的关联是普遍存在的。哪怕是 Apache Flink 这样可以区分成 Runtime 和 DataStream API 以及 Flink SQL 的项目，也不需要单独区分出若干个团队来分散治理。Apache Hadoop 200 多名 Committer 完全依靠工作流程和负责任的态度，以相同的权力推进代码的演进。PostgreSQL 的 28 名 Committer 也没有再细分。</p>
<p>区分团队的项目，往往与不同的资源和关注点关联。例如，Apache 软件基金会下的每个项目都有自己的项目管理委员会，这其实就是某种意义上的团队区分，但是没人会觉得这增加了形式主义，因为不同的项目之前确实是不同的。</p>
<p>例如，Rust 共同体区分了若干个团队。虽然我对其中的 Release Team 保持怀疑，因为 PostgreSQL 可以很简单地由核心成员担任，ASF 项目通常也由志愿者根据发布手册担任特定版本的发布负责人，但是其他的团队区分是很清晰的。例如对于一门语言，编译器和标准库分开是没有问题的。中央资源库有独立的维护人员也是合理的，他们完全不需要关心编译器和标准库的问题。不过，我相信在真正出现这些团队独立的志愿者之前，也不需要分化出特定的团队。换句话说，因人设岗在开源共同体当中非常常见。同时，一个志愿者负责多项工作也是正常的，比如 Nick Cameron 就同时是编译器团队和开发工具团队的成员。</p>
<p>不要在没有人的时候首先架设出复杂的治理机构，因为没有人实际担任这些角色，空洞的治理体系是可笑的。同样，复杂的治理机构无法拯救空心化的开源共同体。比如，TiDB 有 60 余名 Committer 或 Maintainer 成员，但是真正处理 community 事务的人是不足的。前面提到的 Execution 团队的活跃成员全是 PingCAP 公司同一部门的员工，经过公司组织调整后工作重点改变，也就导致对应模块的治理立即缺失。空心化的开源共同体无法响应参与者，因为实质的有价值的回应来自于人与人的沟通，而非机械化的流程。</p>
<p>出于关注点不同的团队划分，还有一个值得考虑的问题是应当采用虚拟组织或者实际组织。Kubernetes 设计的 SIG 和 WG 就区分了这一点。SIG 作为实际与权限相关的团队，前面已经讨论过了。我在分析 TiDB 的治理模型的时候讨论过 WG 模型在 Kubernetes 共同体当中的采用情况。</p>
<blockquote>
<p>Kubernetes 社区的影响力和专注于社区运营的人数保证你的 WG 有人关注，有人推送，有人宣传，再不济任务结束或者生命终结可以回收。另外，Kubernetes 的 WG 都是非常 General 的，例如可靠性工作组，命名工作组，策略工作组，等等。TiDB 和 TiKV 对 WG 的理解基本停留在功能特性小组的层面。这种需求通过项目内的功能设计提案和 tracking issue 等形式发起和追踪即可。</p>
</blockquote>
<p>Rust 共同体当中也有同样的设计，例如最近 Nick Cameron 大力推进的异步编程工作组，这一工作需要协同编译器和标准库以及三方库等多方努力才能在 Rust 生态当中提供一个统一且高效的异步编程抽象和灵活适应不同负载的多种实现。</p>
<p><a href="https://github.com/engula/engula/discussions/245">Engula 共同体考虑未来发展</a>的时候，讨论了区分不同团队的思路。我在主题下回复的建议就是针对不同的模块关注点，可以尝试组织起不与权限挂钩的兴趣小组，针对特定的主题，可以组织起工作组。对于权限本身的区分，由于共同体规模并不大，适当扩充核心成员即 Maintainer 的人数达到复数即可。否则，在接口不稳定的情况下，跨越当下设定的模块的变更非常可能发生。另外，对于讨论中区分出来的日志、存储和计算引擎三个模块之外，部署逻辑、异步实用工具等等实际存在的功能又该归属到哪个团队呢？还是前面提到的，“切分主要的缺点是很难切得恰到好处，出现问题讨论和修复带来的治理开销太大。如果不修订，实际情况一般是团队成员权限不足，核心团队不停兜底”。</p>
<p>那么，什么时候应该考虑扩大治理机构的规模呢？这里提供几个方向性指标。</p>
<p>第一个是遇到瓶颈。</p>
<p>如果开源共同体当中的事务变多或变复杂，导致当前的核心成员团队无法处理，那么就有可能要考虑扩大治理机构规模。例如，Linux 的 1000 多名拥有部分提交权限的维护者，为 Linus 分担了大量与具体驱动或架构相关的模块的补丁审查。例如，C++ 委员会面临方向统合上的问题，于是成立方向委员会来应对。</p>
<p>不过，并非遇到的所有瓶颈都需要通过扩大治理机构来解决。比如，流程事务繁多可能是流程文档不足或者流程本身有形式主义的问题，通过改进流程或取消流程即可解决瓶颈。另外，PostgreSQL 绝大部分工作是由 7 名 Core Team 成员和 28 名 Committer 处理的，如果你的核心成员有同样的能力，那么可能也不需要刻意扩大规模。</p>
<p>我在参与 Engula 共同体的过程中也不断重复这一观点，即“如无必要，勿增实体”。如果当前项目创始人足以处理所有事务，那么就不需要形式主义地扩充成员，更不需要设计复杂的治理机构。大多数人认为治理既不酷也不有趣。我们的目的是，在保持想要达到的质量和客观性的同时，将治理的基础设施和文件的数量保持尽可能少。</p>
<p>第二个是关注点分离。</p>
<p>如果一个无关权限的兴趣小组或者工作组最终围绕特定领域形成了一个大的子共同体，这个子共同体可能需要一些特定的知识，而这些知识是核心成员所不知道的。这个时候，就可能需要把独立出这部分决策权。例如，Rust Team 有 Community 团队，Kubernetes 有 Community 团队，甚至你把整个 Linux 共同体视作一个整体，Linux Foundation 也是一个独立的团队。</p>
<p>关注点分离强调的是事后追认，也就是真的有分离的需求的时候，追认事实，而不是事先设计出空中楼阁式的团队，期待有人自告奋勇加入。这样做，最可能的结果是吸引到沽名钓誉的人工于心计地获得头衔。</p>
<p>另外，关注点分离也强调权限的独立。除非明确需要层级结构，例如 PostgreSQL 的 Core Team 对整个开源软件负责，因此它需要决策 Committer 团队的人员组成，否则你并不需要把所有的子共同体组织成一个层级结构，网络结构也是可行的。例如，Linux Foundation 实际上与 Linus 控制的开源软件共同体并没有层级关系。例如，StreamNative 公司建立的 Apache Pulsar 中文社区也不需要对 Apache Pulsar 的 PMC 负责。这种独立往往发生在分地区和语言成立的本地用户组上，或者围绕同一开源软件但是面向不同目标的群体之间。</p>
<p>总的来说，所有这些情况都超出了现有治理机构在时间、知识或技能方面的管理能力。事务的多少是判断是否扩大治理机构的正当理由。如果你只有少数几个特定领域的清楚，当前的核心成员努力一下就能处理完，那就不应该成立一个独立挂钩权限的团队。但是如果核心团队定期且重复地抽到一些请求，那么就有必要考虑成立新团队应对瓶颈了。当然，这不是唯一的解法。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>开源软件的技术写作</title>
    <url>/2022/05/08/open-source-tech-writing/</url>
    <content><![CDATA[<p>开源社群虽然是围绕开源软件建立起来的，但是建设繁荣的开源生态，依靠只读的源代码是不够的。建设繁荣的开源生态需要开源协同，而协同的基础是沟通。沟通不仅有论坛和聊天室的交互式形式，还有主动的内容生产和发布，包括不同受众的文档的撰写和翻译，以及技术文章的传播等等。这些内容创造都可以归类为技术写作，也就是说，围绕开源软件的技术写作，是建设繁荣的开源生态的重要一环。</p>
<p>本文尝试讨论这些不同类型的技术写作在现实当中被采纳和运用的情况，以及它们相应的价值。</p>
<span id="more"></span>

<h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><p>虽然大一统的低语总是想让我说“代码也是技术写作的一部分”，但是我还是克制了这个冲动。不过，软件开发的过程当中，为了提高软件的可理解性和可维护性而刻意写好的代码注释和提交信息，确实可算作是技术写作的一部分。毕竟，很有一些开源软件即使增长到一定的复杂度，也没有半行注释，提交信息里全是 <code>update</code>、<code>save</code> 或 <code>fix</code> 这样不明所以的单词信息。</p>
<h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>代码注释的重要性在许多软件开发的最佳实践当中都有提及，总结下来我认为不外乎三点。</p>
<ol>
<li>关键设计要有模块注释，接口和数据结构要有基本的说明注释。</li>
<li>实现上的 trick 要有行内注释。</li>
<li>清晰明白的代码不需要啰嗦的注释。</li>
</ol>
<p>第一点可以分成两个部分，第一个部分是通过模块注释提纲挈领地说明模块的设计动机和思路。一个软件往往由多个模块构成，每个模块又由多个小模块构成，这样层层拆分下去，每一层都有模块设计的注释，对于有志于投入到代码开发或使用的参与者来说，就是一个循序渐进且每次都能处理适量信息的过程。</p>
<p>这一方面做得尤为出色的是 <a href="https://doc.rust-lang.org/stable/std/">Rust 的标准库注释</a>。虽说是注释，但是在 rustdoc 渲染工具的加持下，这份注释其实直接就可以作为实现文档呈现出来。Rust 的标准库注释从最上层介绍了标准库的构成和各个模块的职能，到每个模块细分之后同样复刻最上层的介绍模式，直到每一个具体的数据结构和方法的接口定义。可以说，开发 Rust 标准库的程序员和使用 Rust 标准库的程序员，都反复多次阅读过这些注释文档。</p>
<img src="/2022/05/08/open-source-tech-writing/rustdoc-std.jpeg" class="" title="Rust 的标准库注释">

<p>广泛使用的编程语言的标准库注释似乎总能做得十分完善，<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/module-summary.html">Java 的标准库注释</a>也类似。尤其是我时常翻阅的 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/package-summary.html">Java 并发模块的注释</a>，由于并发的复杂性和设计上依赖约定的特性，详实的注释文档显得尤为重要。</p>
<img src="/2022/05/08/open-source-tech-writing/javadoc-concurrent.png" class="" title="Java 标准库并发模块的注释">

<p>由于标准库做出了好的示范，并且提供了好的注释文档化支持，Rust 生态的软件和 Java 生态的软件，大多能够考虑写好模块注释。语言对注释的支持是很重要的。</p>
<p>例如 Rust 按照模块拆分，支持了简单的模块注释手段和 Markdown 语法，程序员就很容易顺着这条预设路径写出好的注释。反观 Java 是以类来组织代码的，优秀的项目往往会在类注释内写好详实的注释，但是 <code>package-info.java</code> 的用例并不流行，甚至很多程序员都不知道有这么个东西，JavaDoc 生成出来的内容比起 rustdoc 更加难以阅读，尤其是因为缺乏模块的概要注释，以至于根本不知道应该看哪部分代码。所以 Java 程序员往往是直接阅读源码上的注释，而不是到对应的 JavaDoc 网站上阅读。</p>
<img src="/2022/05/08/open-source-tech-writing/javadoc-bookkeeper-lifecycle.png" class="" title="状态机经常需要注释定义">

<p>回过头看 Rust 的文档，虽然生成的页面非常精致，对模块文档的高度支持让 rustdoc 生成的内容几乎就是一份形式上优质的实现文档，但是在代码内链接的部分，如果直接读源码注释则很难像 Java 注释一样方便的跳转。当然这有可能是编辑器和集成开发套件对这类跳转支持还不足的原因，但是确实会影响注释产生的实际价值。</p>
<img src="/2022/05/08/open-source-tech-writing/rustdoc-tokio.png" class="" title="缺少工具支持，直接阅读注释不方便">

<p>第一点的第二部分是对第一部分的补充。除了大段的模块注释，组成软件对外契约的接口和公共数据结构，需要有基本的说明注释。也就是说，这个数据结构的用途和各个字段的定义，接口方法的用途和输入输出的约束等等。这些接口和数据结构往往被下游所引用和依赖，软件分层、抽象和封装的目的就在于使用者只需要阅读接口契约就够。</p>
<img src="/2022/05/08/open-source-tech-writing/javadoc-zookeeper-asynccallback.png" class="" title="典型的接口文档">

<p>第二点比较好理解。如同前几天我发出的<a href="https://twitter.com/tison1096/status/1521758171928223744">讨论技术债问题的推特</a>，很多时候实现上为了速度或者确实有客观复杂度难以理解，需要对实现做具体注释，例如经典地告诉别人不要乱动某几行代码。这样的注释是不可避免的。</p>
<img src="/2022/05/08/open-source-tech-writing/javadoc-flink-hack.png" class="" title="THIS IS A HACK">

<p>第三点某种意义上是对前两点的总结，也就是说除了公开定义的数据结构和接口和模块的注释，以及实现上必须澄清的细节，其他的注释能少则少。这也是<a href="https://book.douban.com/subject/30468597/">《重构》</a>当中颇为反直觉的一个论断，书中给出的解释如下</p>
<blockquote>
<p>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</p>
</blockquote>
<p>我同意这个观点。技术写作不必卷帙浩繁，内容不是越多越好，简练准确地传达出完整的信息，是注释要达到的效果。</p>
<h3 id="提交信息"><a href="#提交信息" class="headerlink" title="提交信息"></a>提交信息</h3><p>代码注释之外，与开发活动密切相关的另一个技术写作的实例，就是撰写提交信息了。</p>
<p>现代开源软件大多有源码控制系统版本化的管理，每次变更都会经过提交补丁和代码评审，通过后方可合并到代码仓库中。提交上来的补丁会包含提交信息，如果用 Git 管理，那就是所谓的 <a href="https://git-scm.com/docs/git-commit#_discussion">Git Commit Message</a> 的内容。</p>
<p>关于<a href="https://cbea.ms/git-commit/">如何写好提交信息</a>，相关讨论和材料不少。总结下来，我认为有以下几个关键点。</p>
<p>第一点，参考 <a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commits</a> 的分类，根据项目特点突出每个提交的目的。同时，Conventional Commits 标准还给出了提交信息的基本格式指南。</p>
<p>第二点，为了突出提交的目的，标题采用祈使句而非陈述句，也就是说提交信息标题读起来形如“（应用这个补丁，将会）实现某个功能&#x2F;修复某个缺陷”。</p>
<p>第三点，提交信息内容主要关注为什么要做变更和做了什么变更，而不是变更的细节或实现方式。如果项目使用 issue tracker 等工具记录需求和缺陷报告，通常可以简化为提供一个到 issue 的引用。如果实现细节 trick 是软件知识的一部分，也应该记录在案。这跟注释的分类方式是类似的，具体如何取舍详略，只能在实践当中根据直觉和同行评议交流积累经验了。</p>
<p>第四点，可能比较容易引起争议，我个人倾向于合入主分支的提交信息省略开发中间过程，保持主分支的线性提交历史，每个补丁提交的信息都是经过开发、评审、修改后的结论。Linus 设计 Git 的时候，其 git-merge 功能实际上会把开发分支的所有 commits 都合并到上游分支里，这就导致开发的中间过程被保留。往往多个分支互相反复 merge 以后，提交历史就变成一个复杂的有向无环图，难以阅读。当然，我认为开发的中间过程有其自身的价值所在，不过在 GitHub 式的平台接管开发流程的今天，这种在 pull request &#x2F; merge request 交互过程中产生的中间状态，可以由代码托管平台记录下来，作为提交历史的外挂扩展信息存在。通常，只需要在提交历史里提及对应的 request 链接，即可关联上相关信息。</p>
<p>代码注释和提交信息，是在一线开发环境里产生的一手技术写作内容。实际上，如果这部分相对上游的内容生产被主动管理起来，生产出高质量的内容原材料，下游无论是文档还是宣传内容，都将受益匪浅。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>前文提到注释的时候，我经常会下意识地写成注释文档或者文档，这是因为注释可以理解成与代码共同演进的文档。其实，<a href="https://book.douban.com/subject/35372829/">《活文档》</a>一书中就曾经提及，以开发过程中诞生的知识为源头活水，随软件开发不断进化的文档，或者叫“活文档”，才是可靠、高效、协同且有见地的文档。</p>
<p>虽然如此，为了编写描述实现细节、模块设计、开发流程和使用方式的文档，所需的技能集与代码开发还是有很多不同。尽管有不少开源项目的文档是由开发者顺便完成的，但是无论是在企业当中，还是组织复杂度达到一定程度的开源团队当中，都会形成专注文档内容输出的子团队。</p>
<p>如前所述，根据受众用途的差异，文档可以粗略地分成用户文档和开发文档；根据受众地域的差异和全球化的需求，文档团队又需要考虑国际化和本地化的问题。</p>
<p>讨论文档问题，可以从一个项目的 README 文件说起。这是开源运动伊始时就在开源项目的创作者中间传播开来的最佳实践。简单来说，无论你是一个开发者，获取到了开源软件的源码压缩包，还是一个用户，获取到了可供编译的源码压缩包或预编译的二进制文件发布包，解压缩以后的文件集合里，通常都会有一个 README 文件简要介绍该软件的名称、定位用途、使用方式、作者和著作权，以及其他联系方式或相关材料的信息。可以说，开源软件最初的专门文档，就是从 README 开始的。即使在今天，浏览托管在 GitHub 上的软件代码仓库，首页上最引人注目篇幅最大的，还是渲染 README 文件展示出来的页面。</p>
<img src="/2022/05/08/open-source-tech-writing/readme-cpython.png" class="" title="Python 解释器的 README 文件">

<p>对于国际化和本地化的问题，往往首先被考虑的也是 README 文件。例如 <a href="https://github.com/perl/perl5">Perl</a> 就完成了中日韩等语言的 README 文档翻译和本地化。</p>
<h3 id="用户文档"><a href="#用户文档" class="headerlink" title="用户文档"></a>用户文档</h3><p>用户文档，顾名思义就是写给用户看的文档。</p>
<p>这看似是一句废话，却是不少开源项目用户文档质量不佳的症结所在。因为如果完全从开发者的角度出发，很容易因为过于了解实现细节，深度参与了设计讨论考虑了太多极端情况，而在用户文档的行为上不能换位到目标用户的知识储备和热点路径，经常出现专有名词或内部知识堆砌，或者热点路径和极端情况篇幅详略不当的情况。</p>
<p>对于这些情况，本文不做过多展开。还是把重点讲回到好的用户文档实践当中。</p>
<p>文档的发布有多种形式。如今互联网发达，成本低廉，大部分用户阅读文档的手段是在线文档，这些文档不仅包含文字和图片，还可以连接到音频，甚至嵌入在线互动模块。当然，还有以 EPUB 或 PDF 格式发布的文档，常见于罗列所有命令、接口或规格的参考手册当中，典型的包括 Intel 各个类型芯片架构的指令集文档，硬件驱动的接口文档等等。</p>
<p>关注到开源软件主要采用的前一种形式，好的文档网站还是有许多的。</p>
<p>我最喜欢举例的是 <a href="https://spring.io/">Spring 框架生态的文档矩阵</a>。官网就是它的入口，顶端导航栏 Projects 按钮列出生态内 Spring Boot 和 Spring Framework 等一系列子项目的入口，Learn 按钮列出了半小时内快速搭建任何一项功能的样例项目的教程。</p>
<p>这里值得特别提出的就是 Spring 丰富的教程。从文档递进关系上 Learn 按钮下的 <a href="https://spring.io/quickstart">Quickstart</a> 展示的是 Spring 生态当前强推的 Spring Boot 一揽子框架。Spring Boot 项目的意义就在于快速启动一个包含多个 Spring 生态模块的项目，首先展示这项内容，抓住了绝大部分用户最热点的问题，可以说不只是二八定律，而是用 1% 的投入换取了 90% 问题的解决。</p>
<p>我曾经和不少开发人员或技术写作人员讨论过，一个共识是专业人士往往由于掌握了高级知识，对问题有全面的了解，在写作文档的时候，总希望把内容全面的介绍出去，或者有些卖弄的动机在里面；同时，容易对难题产生极大的兴趣，以攻破难题为首要目标。实际上，文档写作经年沉淀的经验当中，能够总结出 TL;DR 和 FAQ 这样的缩写词，就是因为这是大部分的天性。也就是说，太长的内容不会看，少数几个最常问的问题组成了所有问题人次中的绝大部分。</p>
<p>其实，从知识成长的曲线也不难看出，自然演进的结果下，入门材料永远是最多的，点击频率也是最高的。内容文档团队想要生存下来，做好入门材料是一个百试不厌的护身符。</p>
<p>Spring 文档矩阵在 Quickstart 之下，是针对大量细分用户场景的 <a href="https://spring.io/guides">Getting Started Guides</a> 文档。我在学习和使用 Spring 生态的过程中，大量参考了这些指南文档。无论是你想要连接数据库，提供 RESTful 接口，对接各种系统，部署上云，使用 Gradle 管理 Spring 项目构建，都可以在这里找到一个合适的入门点。</p>
<p>前面提到，入门材料是内容文档团队生存的护身符。不仅如此，做好入门材料也是挑战难点的前提条件。真正能够凭借一己之力或说动力，跨过入门阶段探索进阶用法的人少之又少，绝大部分潜在用户一试不成，也就放弃了。其实我也是如此，每次我遇到一个需求，想要寻求开源解决方案的时候，如果三两下试不出来解决好我的基本问题，那也就放弃了。如果基本问题被解决了，那么如何解好，发现软件的高级功能并从中受益，才会更加顺理成章。</p>
<p>高新科技派的代表是 <a href="https://kubernetes.io/docs/tutorials/hello-minikube/">Kubernetes 的交互式教程</a>。其实这种形式的“文档”，我在大学期间通过 Codecademy 学习 Ruby on Rails 的时候就接触过了。随着 <a href="https://www.katacoda.com/">Katacoda</a> 等构建交互式教程的工具的推出，相信以后这类“寓教于乐”的教程还会更多。</p>
<p>很多年前，有人提起前端的受众远多于后端的原因，就在于前端的教学反馈更加及时，所见即所得，用户可以直接视觉化的看到自己的“努力”的收获。反观后端的上手过程，大多是和终端打交道，越是深入进去，成功的喜悦就越是建立在一个正常的退出码，一段正确打印的内容，一个没有崩溃的程序，想要从这种体验中得到激励，本身就有一定的选择性。用户文档的受众是一般用户，顺应人性而非考验人性是一个基本要求。让用户快速地用起来，解决实际应用场景的问题，比软件本身的正常运行和底层接口返回了正确的结果，更能切中要害。</p>
<p>用户文档不仅仅是用来入门和指导搭建原型的，还有排查问题的作用。<a href="https://docs.pingcap.com/tidb/stable">TiDB 的文档</a>在设计的时候就考虑到了这一点，在每个容易出问题的地方附上对应的 Note 或 Troubleshooting 段落。不过，文档终究不是用户排查问题的第一顺位。一般来说，在故障发生的地方就地打印提示信息帮助排查，是最有效的。除此以外，用户通常会在 Stack Overflow 及其他典型问答网站或搜索引擎上寻找问题的解法，面对这个场景的内容运营我会在最后“写作之外”一段当中再次提及。尽管如此，文档还是一个记录常见问题官方认可的解法的好地方。例如，Flink 用户经常会碰到 <a href="https://nightlies.apache.org/flink/flink-docs-stable/docs/ops/debugging/debugging_classloading/">Class Loading 的问题</a>，这在官方文档中就有一个专门的页面介绍 Flink 解决 Class Loading 的整体思路和典型问题的可能解法。</p>
<h3 id="开发文档"><a href="#开发文档" class="headerlink" title="开发文档"></a>开发文档</h3><p>好的用户文档案例还有很多，数据库领域的卧龙凤雏 <a href="https://www.postgresql.org/docs/current/">PostgreSQL</a> 和 <a href="https://dev.mysql.com/doc/refman/8.0/en/">MySQL</a> 的文档就是经典之一。不过，这两份文档不仅仅是给用户看的，其中涉及了不少模块设计、数据结构和接口设计，以及设计哲学，不仅试图兼容这两大数据库软件的团队成员必须了解，所有数据库从业人员都能从中获益。</p>
<p>如果你去搜索 TiDB 代码当中以上面 MySQL 文档网站为引用的注释，能够从执行模块找到许多个匹配结果。可以说，要想兼容 MySQL 的语义，从文档和实现中复刻一套数据类型和表达式是不可避免的。同样还有试图对接或者复刻 PostgreSQL 的软件，例如现在想要支持让 psql 直接访问自研的数据库服务，那么了解 psql 的通信协议，实现对应的服务端编解码模块就是必须的。</p>
<p>开发文档主要受众是软件开发者。当然，前面用户文档一段里，Spring 的用户也是业务软件的开发者。开发文档的开发者，详细说来分成生态开发者和内核开发者，与直接生产业务软件乃至只是通过鼠标键盘和软件交互，不以编程方式交互的终端用户是有差别的。</p>
<p>生态开发者与终端用户有一定的相似之处。他们都不会关心软件的内部实现，主要关心对外暴露的接口。不同的是，终端用户直接生产不可复用的业务软件，或者不以编程的方式与软件打交道，而生态开发者往往围绕着软件暴露出来的接口或插件框架，实现自己的插件或者将这个开源软件与另一个生态连接起来。</p>
<p>插件开发，也就是对开源软件完成某项工作的功能模块做出抽象，允许加载第三方提供的实现。例如 Flink 读取数据源的模块，官方定义了接口，并提供了 Kafka 和 HBase 等一系列常见系统的对接。第三方开发者为了与企业内部系统对接，或者对接一个官方没有支持的开源软件，就可以根据开发文档实现 Flink 定义的接口，并根据文档装载和启动。</p>
<p>软件开发往往开始于解决一个特定问题。如果这个问题过于特殊或者简单，可能软件的开发周期就到此为止了。如果这个问题可以泛化，或者软件本身就定义了一种新的方法论，那么软件的复杂度就会随着时间日益增加。例如 Apache Flink 提出了一个有状态流处理的计算框架，那么与整个大数据生态的对接，就是其演进的必经之路。一个人或一个相同背景的团队，很难完成对世界上形形色色场景的覆盖，通过开源协同来丰富生态，是开源软件能够吞噬软件世界的一个基本前提。因此，强盛的开源软件往往会有丰富的扩展点，繁荣的开源社群会有大量的生态开发者将软件及其方法论传播到每一个有用户需求的地方。</p>
<p>例如，Flink 不仅通过 Connector 抽象了与其他数据源的对接，还通过 State Backend 的抽象和 High Availability Service 的抽象允许生态开发者对接其他能够提供相应能力的存储系统。例如，被某公司高管认为难以扩展生态的数据库领域，PostgreSQL 通过 Foreign Data Wrapper 和 Extension 等一系列插件化模块，激发了生态开发者极大的开发热情。又例如，Spring 这样一个提供了基础的控制反转和面向切面编程的方法论的软件，通过对接不同数据源，不同鉴权服务，不同部署环境，形成了庞大的 Java 开发生态。</p>
<img src="/2022/05/08/open-source-tech-writing/ecosystem-flink.png" class="" title="Apache Flink 的开源生态">

<p>开发文档要为生态开发者解决的问题，就是明确这些框架接口的定义和约定，让他们能够放心地依赖并创造出新的价值，构建出生态护城河。此外，开发文档网站可以罗列已有的生态开发项目，一方面能够激励生态开发者“名留青史”，另一方面对于新人来说，有一个天然的不用刻意编写的参考教程，即使是经验丰富的生态开发者，也有可能从其他人的作品当中汲取灵感。</p>
<img src="/2022/05/08/open-source-tech-writing/ecosystem-skywalking.png" class="" title="Apache SkyWalking 的开源生态">

<p>内核开发者指的是开发文档所属的开源软件的人。如果软件范畴小，那么它可能代指的是所谓的核心团队；如果软件足够复杂，那么内核开发者可能分成好几个团队。例如 Rust 的内核开发团队就分成编译器团队和标准库团队，而包管理器、资源网站开发和开发工具开发的团队，则介于内核开发者和生态开发者之间。</p>
<p>对于内核开发者来说，仅仅了解软件架构和公开的接口契约，就不太足够了。生态项目的开发者，只要了解开源软件的接口，开发的方式和风格很大程度上可以按照自己的喜好来决定，本质上是一个全新的开源项目。对于内核开发者来说，他们要开发的是一个已经存在的开源项目，因此项目的目标、设计哲学和风格，首先要入乡随俗，在经过深度的参与之后，才有可能提出合理的修改意见。</p>
<p>内核开发者核心的开发文档是介绍如何参与的 CONTRIBUTING.md 文件，或者进一步展开的 Dev Guide 文档。许多著名的开源项目都有类似的材料。</p>
<ul>
<li><a href="https://devguide.python.org/">Python Developer’s Guide</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/">Guide to Rustc Development</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Development_information">PostgreSQL Development information</a></li>
<li><a href="https://pingcap.github.io/tidb-dev-guide/">TiDB Development Guide</a></li>
</ul>
<p>其中 TiDB 的开发文档是我在参与 TiDB 社群运行的时候提出了推动撰写的。此前 TiDB 有的是一系列源码阅读文章和博客分享。这些材料固然是有价值的，也是 TiDB 社群在当时相对早期的国内开源环境当中脱颖而出的依仗，但是开源运动发展到今天，当社群不再局限于一地，而是参与全球化竞争的时候，将发布后即不可变的零散材料，按照主题整理成可操作性的文档，就显得更加迫切了。</p>
<p>开发文档需要覆盖的内容，以 TiDB Development Guide 为例，分成了以下四个章节。</p>
<ol>
<li>Get Started 搭建开发环境，介绍完成基本开发流程的必需知识。</li>
<li>Contribute to TiDB 开源社群欢迎哪些参与，这些参与方式分别如何进行。</li>
<li>Understand TiDB 深入了解软件架构设计、模块设计和关键实现细节。</li>
<li>Project Management 开源软件的项目管理和软件工程最佳实践。</li>
</ol>
<p>其他的开发文档大同小异。例如 Rustc 的开发文档主要讨论了前三个问题，把项目管理的部分放到整体讨论 Rust 社群运作方式的 <a href="https://forge.rust-lang.org/">Rust Forge</a> 文档里。例如 Python 的开发文档的顺序是 Getting Started 随后是各类参与形式的细节，最后以模块设计和开发 Tips 收尾。</p>
<p>构建并运行一个内核开发者社群，通常的知识流通方向就是从公开的官方交流渠道上积累，汇聚沉淀到开发文档上，再反哺到每日的沟通讨论当中，逐渐形成丰富的知识库财产，这是开源协同创造知识，并依托群体智慧制造高水平软件的秘密所在。</p>
<h3 id="国际化和本地化"><a href="#国际化和本地化" class="headerlink" title="国际化和本地化"></a>国际化和本地化</h3><p>很长一段时间里，美国代表了软件开发的前沿方向，开源运动盛行于欧美，并以英文为通用语言。这一状况至今没有太大的变化，但是中国和日本等国家的强势加入，法国、德国和意大利等国家的内容本地化需求成长，使得开源软件的内容创作必须要考虑国际化和本地化的问题。</p>
<p>一方面，技术写作者以本地语言创作，往往能够最为准确的表意，并且满足直接受众需求。但是为了扩大内容的影响力，融入全球化前沿的开源共同体当中，也为了在内容创作上坚持国际化和本地化两手都要硬的需求，需要将内容翻译成英语或关键受众所在地区的本地语言。另一方面，对于第一手材料是外语的情况，开源社群的技术布道师为了将内容国际化和本地化，也需要进行相应的翻译工作。</p>
<p>内容翻译是个复杂的话题，本文不会深究如何翻译的问题，仅从现有的案例出发，介绍开源软件内容国际化和本地化的成熟做法。</p>
<p>首先要考虑的是展示问题。如同上面讨论文档交付和展示方式时提到的，当今开源软件的文档，往往是以网站形式展示的。为了顺应国际化和本地化需求的潮流，新兴的文档网站框架往往内置支持了多语言切换和发布的功能。</p>
<p>例如 Facebook 某团队基于 React 框架提出的 Docusaurus 网站框架，就支持切换多语言的功能。Apache InLong (Incubating) 和 Apache APISIX 等采用这一框架来开发自己文档网站的开源项目，也就因此能够顺利的支持国际化和本地化的需求。</p>
<img src="/2022/05/08/open-source-tech-writing/i18n-docusaurus.png" class="" title="Docusaurus 的多语言功能">

<p>除去展示阶段的趋势，另一个问题是内容翻译的专家如何参与进来。上面提到的 Docusaurus 框架，或者许多手工完成国际化的文档页面，往往采用一个页面写两次的手段，依靠人来维持不同版本之间的同步。这样很容易导致文档之间及时性不足不说，对于内容翻译者来说，他们更想关注的是内容的翻译，而非页面方式用于描述如何渲染和其他网站相关的元素。</p>
<p><a href="https://www.gnu.org/software/gettext/">GNU gettext</a> 项目提供了一种方案，能够提取出文件中的片段，翻译者只需要翻译相关片段的内容，通过成熟的套件支持，能够把原来文件当中的内容部分替换成翻译后的内容。</p>
<p><a href="https://docs.python.org/3/">Python 的用户文档</a>多语言支持做得是公认的好，其背后就是这样一套体系在支撑。具体的内容可以参考 PyCon Taiwan 2016 的演讲<a href="https://blog.liang2.tw/2016Talk-PyDoc-TW/">《多语系 Sphinx 与 Python 官方文件中文化》</a>，这也是我最初接触文档国际化和本地化的重要材料之一。</p>
<img src="/2022/05/08/open-source-tech-writing/i18n-pydoctw-transifex.png" class="" title="Python 官方文件中文化">

<p>工具之外，开源共同体当中自发组成的内容翻译团队的力量也不容小觑。上面提到的 Python 官方文档的翻译，就是一个自发运行的小组。另一个颇有名气的翻译组，是 <a href="https://linux.cn/lctt">Linux 中国的翻译组</a>。他们翻译了大量 Linux 社群的高质量文章，并且推进了许多实用工具文档的中文化，是一个很有行动力的组织。</p>
<h2 id="书籍文章"><a href="#书籍文章" class="headerlink" title="书籍文章"></a>书籍文章</h2><p>按照距离开源软件生产中心的距离，文字内容创作依次分类成代码注释、提交信息和文档，再往下走就是本节要介绍的文章和书籍了。</p>
<p>例如，这篇文章就可以视作开源共同体当中讨论技术写作的重要性和必要性的内容输出。</p>
<p>我在“夜天之书”公众号上发布的系列文章，大部分都关注在如何认识开源社群的人和事，如何参与开源社群，以及如何建设开源社群上。这些文章与<a href="https://opensourceway.community/">“开源之道”</a>的系列文章，<a href="https://zhuangbiaowei.github.io/">庄表伟的 Blog</a>上讨论开源的文章，OpenTEKr 公众号的系列内容，以及广泛的关注开源、投入开源的参与者的文章一样，构成了开源共同体当中的每一个个体对开源的解读。</p>
<p>例如，前面提到的 TiDB 社群发布的每周速递、功能解读、源码阅读和路线展望等内容，就是具体到某个开源项目对自己的开发过程及结果的介绍和宣传。</p>
<p>这其中，自然也包括 TiDB 首席架构师 <a href="https://www.jianshu.com/u/1yJ3ge">@siddontang</a> 在简书上发布的博客，核心开发者 <a href="https://www.zenlife.tk/index">@tiancaiamao</a> 的个人博客等等。</p>
<p>技术博客文章的价值在哪？回答这个问题之前，我想先抛出一个论点。</p>
<p><strong>文章须言之有物。</strong></p>
<p>这个观点来自于胡适《文学改良刍议》的第一条。为什么讲这句话？因为技术博客及文章，其价值体现首先依赖于内容言之有物。</p>
<p>例如，上述个人博客的内容与社群的每周速递类似，大多抓住的当前开发过程当中遇到的问题，并针对问题提出务实且有建设性的议论。作者写下这些文字的时候，首先考虑的是对自己的思路整理有帮助，首先内容需要对自己有价值，进而才有可能让读者从中获益。只有言之有物的内容，才有可能引来同行的评论和碰撞。</p>
<p>例如，前不久登上 Hacker News 首页的 <a href="https://news.ycombinator.com/item?id=31084147">Retool 团队升级 4TB PostgreSQL 的经验</a>一贴，就引来了数十条评论。@tiancaiamao 在自己博客当中讨论到具体问题的时候，我自己和其他读者都曾经回复讨论过这些问题的解法和自己的经验。</p>
<p>技术博客文章的价值在哪？我认为第一点是自己想写，想记录，满足自己整理思路和外挂记忆的需求，再有第二点是内容言之有物，与同行切磋碰撞。</p>
<p>开源精神的重要内涵是分享的精神，写作文章就是向开源共同体分享自己的所见与所思。开源协同的本质是共同创造价值，通过文章输出自己的观点，把别人不知道的事情讲给人听，把别人隐隐约约知道的事情讲清楚，挑明问题，提出解法，为开源共同体创造价值，最后，自己和文章所依托的开源社群收获真知灼见与技术影响力，这是开源社群的内容创作的闭环。</p>
<p>为什么要强调言之有物呢？这是因为内容渠道一旦建立，推送内容的压力立刻就会来到运营者身上。如果运营者本身不是内容的创作者，为了保证内容推送的密度，很容易饥不择食降低标准推送一些无关的内容或者低质量的内容。</p>
<p>例如，我曾经多次和 Databend 团队的成员提过，他们在公众号上直接复制发布英文写成的 Weekly 是不能达到正向运营的效果的。因为微信公众号的受众天然是中文受众，由于人力紧张或者其他原因，直接将英文写成的 Weekly 原封不动地推送出来，除了制造垃圾以外，很难想象有什么价值。最近，Databend 公众号在推送此类消息时，就做了基本的翻译工作，以及除了无情报幕以外，增添了部分 Tips 内容。</p>
<p>不过，其实 Weekly 并不需要将所有内容都重复一遍，我在 TiDB 社群和 Flink 社群写 Weekly 的时候，主要参考的是 Perl 6 当时的 Weekly 和 Flink 的英文 Weekly 的选材方式，以一个开发者的角度看我自己会关心会感兴趣的内容，挑选出来以后略加评论并说明这个改动或者新功能、模块的发布，可以怎么用，还能怎么改进。否则，只是简单的说“主分支进了 X 个提交”，分别是什么提交号、标题是啥，真成了报幕的，信息价值就很低了。</p>
<p>要想改善内容输出的频率和质量，培训和引导是必要的。例如，PingCAP 为了提高员工的技术写作水平，优化 TiDB 社群内容的质量，在公司内举行了多个技术写作培训计划。例如，<a href="https://developers.google.com/tech-writing/one">Google 发布了自家关于技术写作的材料</a>，这份材料本身就是其内容影响力矩阵的一部分。</p>
<p>一个好的例子是 Bytebase 团队，他们围绕开源软件 Bytebase 关注的数据库运维领域，输出了一系列相关技术文章，同时也包括团队的文化和运行管理方式。这很大程度上是由于创始人重视内容创作，并且以身作则示范好的内容应该如何生产的缘故。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/Mg89XdV2vMzESLJRF-JZIw">Bytebase - 重新定义 DBA</a></li>
<li><a href="https://mp.weixin.qq.com/s/vP9r74-jj4KQTo0_P9aWaA">什么是数据库 Schema Drift</a></li>
<li><a href="https://mp.weixin.qq.com/s/FQxgow6lqHydagUm_QG6hA">解读 Retool 团队升级 4TB PostgreSQL 踩坑</a></li>
</ul>
<p>博客文章毕竟是一种比较口语化的内容输出形式，并且受限于文章篇幅，往往不能够完整地讨论一个问题。通常，博客文章的作用局限于对知识思路进行整理时的阶段性输出，或者即时地议论时事。如果相关内容在你的脑海中有比较完整的脉络，或者有具体的结论，首先可以写一篇文章再做一轮输出，然后就是把相关文章作为原材料，二次创作形成文档、论文或者书籍了。</p>
<p>前面提到，内核开发者社群的内容飞轮，是沟通渠道和开发文档共同支撑的。沟通渠道产生原始知识，总结沉淀形成开发文档，文档再作为可引用的对象参与沟通，相互促进。其实把博客文章认为是一种作者对读者有输出优势的沟通渠道，这个论断仍然是成立的。例如，TiDB Development Guide 的内核技术部分，很大程度上来源于此前发布的源码阅读系列。例如，我正在撰写的<a href="https://tisonkun.org/open-source-guides/">《开源指南》</a>文档，内容也会参考此前写作的与开源相关的博客。</p>
<p>论文的形式相对博客文章更加正式，并且经过同行评审后才会在相关期刊会议上发出。分布式系统的明星博主 <a href="https://martin.kleppmann.com/">Martin Kleppmann</a> 就实践过这种做法。</p>
<p>书籍相对于博客文章来说，容量更加宽裕。开源软件到达一定的流行程度以后，大多会发行相关的书籍来系统性的介绍自己的设计和使用场景，大幅度的提升自己的技术影响力。《Redis 使用手册》、《HBase 原理与实践》以及各种“权威指南”，均属于此类。</p>
<h2 id="写作之外"><a href="#写作之外" class="headerlink" title="写作之外"></a>写作之外</h2><p>写作之外的内容不是本文的重点，因此只做简单的介绍。</p>
<p>随着时代的发展，多媒体内容逐渐占据了内容市场的重要比例。除去撰写文章、书籍和文档，以及开发过程当中涉及的技术写作内容以外，在内容创作这个大门类下面，还有其他的重要形式。</p>
<p>例如，演讲是近年来线上线下社群活动的重要组成部分。通过 KOL 围绕主题并提供示例的演讲，往往能够在听众当中形成一个强有力的印象。KOL 本身很多时候也需要通过演讲来建立起自己的影响力。可以说，演讲能力是一个内容创作者必须掌握的关键能力。</p>
<p>例如，越来越多的开源社群在 Bilibili 和 Youtube 等视频网站上开设自己的账号并上传视频和短视频内容。这可以理解成线上演讲的一部分，也包括线上课程和功能展示等等。目前视觉化地学习 Flink 和 Pulsar 最好的资源，就是它们在 Bilibili 上发布的视频内容。</p>
<ul>
<li><a href="https://www.bilibili.com/video/av87830398">Pulsar: TGIP-CN 直播合集</a></li>
<li><a href="https://space.bilibili.com/33807709/channel/seriesdetail?sid=1378455">Apache Flink 系列教程入门篇</a></li>
</ul>
<p>例如，播客作为视频和文字之间的折衷，也越来越得到开源社群的青睐。<a href="http://xima.tv/1_mFtWul?_sonic=0">ALC Beijing</a> 和 <a href="http://xima.tv/1_OWWef3?_sonic=0">CHAOSS China</a> 这样的社群，会通过播客的方式邀请专业嘉宾访谈来输出自己的内容观点。</p>
<p>可以看到，开源软件的技术写作，到开源软件的内容创作，是一个内涵极其丰富的领域。即使最贴近软件开发的注释和提交信息的部分可以结合到软件工程实践当中由开发人员完成，但是针对受众群体特征的文档的写作，内容的国际化与本地化，文章与书籍的技术写作技巧，内容生产之后运营和推广的能力，与开发一个软件所需掌握的技术能力是有很大区别的。</p>
<p>当然，我不会说一个人只能同时掌握这些能力当中的一个，我也见过许多开发人员有动力、有能力并最终通过努力成为高水平的内容创作者。但是，作为关注开源项目发展的决策者，作为需要认识到开源社群如何建设的每一个人，将这一过程类比为一个新兴的创业项目，要好过想象成一个开发者团队能够覆盖方方面面的工程项目。</p>
<p>实际上，我们尚未看到有任何一个创业公司，能够达到 Linux 这样的成就。同时，Linux 的协同方式与传统的公司运作方式有着许多不同。清醒客观地认识到开源社群建设与发展的复杂性和创新性，评估和应对其中包括软件开发、项目管理、内容创作、市场营销乃至资金支持的风险和相应的收益，才是应有的审慎的态度。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>写作</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache 开源社群的“石头汤”</title>
    <url>/2022/06/15/stone-soup-apache/</url>
    <content><![CDATA[<p><a href="https://book.douban.com/subject/35006892/">《程序员修炼之道》</a>讲了一个有趣的“石头汤”寓言。这个寓言里，饿着肚子的外来人在村子里烧了一锅水，放了三块石头，开始煮“石头汤”。这样的行为引来好奇的村民围观，外来人顺势在“石头汤”的基础上引导村民们添加食材以改善这锅料理。最后，村民和外来人一起煮出了一锅靓汤，外来人于是把石头从汤里扔掉，所有人分享了这顿美餐。</p>
<p>开源协同的工作方式与制作“石头汤”的方式有些相似。开源社群的核心成员与寓言中的外来人一样，充当了催化剂的角色，将这些各自拥有不同背景的人群组织起来。这样，社群成员才能聚在一起做出他们单独无法做到的事情。最后，所有人都是赢家。</p>
<p>当然，在这个版本的“石头汤”寓言里，村民被外来人骗了，石头并没有为最终的美味产生直接价值。<a href="https://book.douban.com/subject/26894636">《开放式组织》</a>指出这种行为是一次性的，并且价值仅仅单向地从村民一方流向外来人一方，以至于它被冠以“汤姆·索亚合作模式”的恶名。</p>
<p>开源协同的模式保留了“石头汤”寓言当中催化剂的内核，但是这一次，外来人提供的不是水煮石头，而是初具规模的汤底和食材。<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>在揭示集市模式的必要条件时阐述了这一点，这个隐喻意味着一个能运行的软件，并且让潜在的合作开发者相信，这个软件在可以预见的未来，能够演变成一个非常棒的东西。</p>
<p>Apache 开源社群由三百多个项目组成，其中不乏开源版本“石头汤”的现实案例。</p>
<span id="more"></span>

<h2 id="Apache-Hudi"><a href="#Apache-Hudi" class="headerlink" title="Apache Hudi"></a>Apache Hudi</h2><p><a href="https://hudi.apache.org/">Apache Hudi</a> 就是这样的一个例子。实际上，就是近期几次引用 Hudi 的例子说明开源协同的工作机制的经历才促使我写这篇文章。</p>
<p>如果用一句话介绍 Hudi 的第一个版本做的事情，那就是写一个 Spark 程序，把数据从 HDFS 读出来，根据用户通过 upsert 接口传入的数据更新请求修改数据，然后写回到 HDFS 上。</p>
<p>就这么简单？</p>
<p>就这么简单。</p>
<p>众所周知，HDFS 的文件不支持随机读写，而数据分析的流水线上需要更新历史数据是个客观存在的需求，各个公司里同类型的 Spark 程序或者不用 Spark 实现相同功能的程序实现过许多遍了。这样的功能做一个平凡的实现，甚至有经验的工程师不出数日就可以写出来。</p>
<p>那么是什么让 Hudi 与众不同呢？答案就在“石头汤”的寓言里。</p>
<p>Hudi 的主要作者，也是现在项目的 PMC Chair Vinoth 敏锐地察觉到了这个需求的普遍性，并且相信跳出公司的局限，集合整个开源共同体的力量开发这样一个公共的需求对项目而言是最好的选择。因此，他推动 Hudi 项目从 Uber 公司的内部作品捐赠给 Apache 软件基金会，借助 Apache 的平台向每一个实现同类功能的开发者发出邀请参与协同。</p>
<p>虽然前面介绍 Hudi 的功能非常简单，但是其实从 <a href="https://cwiki.apache.org/confluence/display/INCUBATOR/HudiProposal">Hudi 进入孵化器的提案</a>当中可以看到，它在一个平凡的 Spark 程序以外，还实现了和当时的大数据生态的初步整合，可以通过 Hive 等现成方案和 Hudi 生产的数据进行交互，这就意味成熟的大数据生态和各种工具可以迁移到 Hudi 的用例上。</p>
<p>这两点对于一个新项目来说是至关重要的。如果没有可行的软件，只是一个想法，那么相比那么多公司内部实现的同类型程序，一个大家都能想到的想法毫无价值。如果作为一个大数据领域的解决方案，不能和大数据生态融合，那么没人会相信它能拥有光明的未来，大部分开发者会持观望态度而不是花费自己宝贵的时间参与协同，因为有这时间还不如改善自己已经实现的同类型程序。</p>
<p>然而 Hudi 做到了起步阶段这个小小的身位领先，并且紧紧围绕着用户需求开发功能、打磨产品和吸纳贡献。既然 Hudi 已经做好的工作我要花费数月才能追上，尤其是其中还包括了许多我不愿意做的“脏活”，那么我为什么不把自己想要实现而 Hudi 尚未支持的功能直接在上游实现呢？反正 Hudi 是 Apache 社群的项目，向上游做出的贡献我自己仍然能够随时用于任何目的。</p>
<p>这样的想法在 Hudi 项目孵化早期推动了诸如 <a href="https://github.com/yanghua">@vinoyang</a> 和 <a href="https://github.com/leesf">@leesf</a> 这样的开发者的参与。他们在 Hudi 的稳定性和可用性上做出了显著的贡献，而秉承开放和合作的理念的 Hudi 社群也很快吸纳他们成为项目 <a href="https://incubator.apache.org/guides/ppmc.html">PPMC</a> 的成员。</p>
<p>Hudi 相对于其他方案的小小优势，加上社群做出这样的表态，以实际行动实践开源社群 Meritocracy 的原则，很快聚拢起来一批有实力的开发者参与其中。这样的正向循环让一开始的小小优势逐渐扩展成今天数据湖领域相对于大部分其他解决方案明显的领先，这也进一步地让领域中潜在的用户和开发者被吸引到 Hudi 社群当中来。</p>
<img src="/2022/06/15/stone-soup-apache/hudi-commit-graph.png" class="" title="2019 年开始孵化以后，开发活动与日俱增，甚至原始作者都不是最活跃的提交者">

<img src="/2022/06/15/stone-soup-apache/hudi-star-history.png" class="" title="自然增长的 Star 代表的声量曲线近似二次函数">

<img src="/2022/06/15/stone-soup-apache/hudi-contributor-graph.svg" class="" title="参与开发的人数近似一次函数">

<p>来自 T3 出行的开发者写出了 Flink on Hudi 的方案与最初实现，来自阿里巴巴的开发者将其完善到生产可用并且具有竞争力。新的 RFC 正在路上，实现一个 Hudi Server 来以内存状态读写取代目前开销显著的元数据文件读写，实现 Record 级别的 CDC 服务等等。数百个将自己的聪明才智和宝贵的时间投入到让 Hudi 变成一个更好的开源软件的参与者，组成了 Hudi 3000 个提交里一点一滴的改善。这正是“石头汤”里村民们从家中带来各自的食材，最终做出一锅美味的翻版。</p>
<p>这样的案例在 Apache 当中并不是唯一的。</p>
<h2 id="Apache-BookKeeper"><a href="#Apache-BookKeeper" class="headerlink" title="Apache BookKeeper"></a>Apache BookKeeper</h2><p><a href="https://bookkeeper.apache.org/">Apache BookKeeper</a>(BK) 从代码角度最早可追溯到 2008 年，当时的它是 Yahoo! 巴萨罗那研究院的研究项目。起初，其首要目的是解决 HDFS NameNode 的可用性问题，后来成为 Apache ZooKeeper 的子项目。2014 年年底从 ZooKeeper 社群孵化成为顶级项目。</p>
<p>BK 完全对等节点的设计使得它被许多寻找分布式日志存储系统的团队所青睐，进而被广泛使用在多个公司的不同场景当中。</p>
<ul>
<li>Diennea 的工程师在开发 <a href="https://github.com/diennea/herddb">HerdDB</a> 时使用 BK 存储预写日志。</li>
<li>Twitter 的工程师基于 BK 创建了 <a href="https://bookkeeper.apache.org/docs/api/distributedlog-api">DistributedLog</a> 项目，后者在 BK 上层封装了面向终端用户的分布式日志接口。后来，这个项目被合并回 BK 社群成为一个子项目。</li>
<li>Dell EMC 的工程师基于 BK 创建了 <a href="https://github.com/pravega/pravega">Pravega</a> 项目，旨在提供流式数据的存储。目前是 CNCF 的沙箱项目。</li>
<li>Yahoo! 的工程师基于 BK 创建了 <a href="https://pulsar.apache.org/">Apache Pulsar</a> 项目，它是一个能够同时支持 RabbitMQ 式的消息队列语义和 Apache Kafka 式的消息流语义的云原生消息平台。<ul>
<li>后来，这个项目的创始成员成立了 StreamNative 公司来提供企业级的 Pulsar 服务。</li>
<li>另外一家企业服务公司 DataStax 使用 Pulsar 来补齐其商业产品 AstraDB 在数据同步和数据变更订阅上的短板。</li>
<li>StreamNative 围绕 Pulsar 发起的 Kafka on Pulsar 项目吸引了来自腾讯和 DataStax 等公司的开发者的参与。</li>
</ul>
</li>
</ul>
<p>围绕着 BK 形成的庞大生态持续反哺着 BK 社区，使其在十多年后仍然能够保持强大的生命力和迭代活力。同时，虽然社群当中存在着不同公司背景的参与者，但是 Apache 的开源之道将所有参与者都认为是个体参与者，并且强调社群独立于其他组织影响的中立性。BK 社群和 Pulsar 社群都坚持了这样的原则，因此社群成员无论是什么背景，大都能够和谐友好地相处。</p>
<p>“石头汤”的寓言不只有开始的石头与结尾的美味，重要的是如何促使这个变化发生的过程。BK 和 Hudi 相同的地方，在于社群维护者都在初始项目解决了一个特定问题的基础上，向社群抛出自己合理的请求，然后不断完善。无论是来自用户需求的反馈，还是工程师设计的方案，一旦有成果产出，社群维护者会及时发布新版本以鼓励做出贡献的参与者并向全体社群成员展示最新的进展。</p>
<p>在这之后，社群维护者引导或者社群成员自发地提出“这个软件还可以更好，只要我们再完成……”的想法，就能清晰地在开发者当中传达出下一步可以做什么的信息。具体的待办事项好过一个模糊的愿景，开源共同体的开发者几乎总是倾向于加入到一个推进中的成功项目，而不是一个刚有设计的项目。架构设计和第一个版本是项目创始团队的责任，这也是开源协同与原版“石头汤”寓言的重要不同：如果你只是丢出两块石头，不会有参与者能够从无到有开发出整个开源软件。</p>
<h2 id="Apache-Kvrocks"><a href="#Apache-Kvrocks" class="headerlink" title="Apache Kvrocks"></a>Apache Kvrocks</h2><p><a href="https://kvrocks.apache.org/">Apache Kvrocks</a> 是今年四月份进入 Apache 孵化器的项目，我是这个项目孵化期导师的一员。最后我想从这个项目出发，具体讲一个引导“村民”向“石头汤”当中添加“佐料”的例子。</p>
<p>Kvrocks 是一个 Redis 协议兼容的分布式 KV NoSQL 数据库，不同于 Redis 采用全内存存储，Kvrocks 的存储是基于磁盘的。不同于企业放弃维护后捐赠给开源社群的项目，2019 年发起自美图基础架构团队开发的 Kvrocks 早在 2020 年就开始以开源项目的形式运作，历经一年多的发展吸引到了来自百度和携程等公司的开发者的参与，并在国内外多家公司的生产环境上线部署。</p>
<p><a href="https://mp.weixin.qq.com/s/2UlajoLdA54scgWP8VS0lg">恭喜Kvrocks 加入 Apache 软件基金会孵化器</a></p>
<p>上面这篇 Kvrocks 发布的加入 Apache 孵化器的文章当中几次提到，社群维护团队选择加入 Apache 的核心原因是“建立更大和多样化的开发者社区”。事实上，Apache 开源之道的指导和 Apache 品牌的帮助确实为 Kvrocks 打开了一个新的大门。</p>
<p>我在成为 Kvrocks 项目的导师之后，自然而然地参与到项目社群当中。如同<a href="https://twitter.com/stephenzhang233/status/1541025802191765505">这条推文</a>提到的，接触一个新的开源项目，第一步就是克隆代码并尝试构建。我在构建过程 Kvrocks binary 当中发现了项目 CMake 脚本存在优化空间。这个时候，我想起来在<a href="how-cmake-works.md">《CMake 是怎样工作的》</a>文章评论区里 <a href="https://github.com/PragmaTwice">@PragmaTwice</a> 分享了他使用 CMake 的一些经验，正好跟我想做的改进相符合。因此，我邀请他把他的经验实践在 Kvrocks 项目上。</p>
<p>很快，Twice 在我和 Kvrocks 的主要作者 <a href="https://github.com/git-hulk">@git-hulk</a> 等人的帮助下系统地改造了基于 CMake 的构建逻辑，取代了此前 Git Submodule + Makefile 的方案。此外，Twice 出于自己对 C++ 编码实践的理解，在阅读源码的过程中发现了许多“这个软件还可以更好，只要我们再完成……”的点子。遵循开源社群一直以来的协同惯例，他把这些想法发布成若干个 issue 并自己开始实现。就在最近几周，他所发起的工作吸引到了更多开发者的参与。</p>
<ul>
<li><a href="https://github.com/apache/incubator-kvrocks/issues/575">Tracking issue for build system enhancements</a></li>
<li><a href="https://github.com/apache/incubator-kvrocks/issues/581">Proposal: Just return values instead of passing pointers if possible</a></li>
<li><a href="https://github.com/apache/incubator-kvrocks/issues/663">Use unique_ptr to eliminate some trivial manual deallocation</a></li>
</ul>
<p>Apache 孵化器的主席 Justin Mclean 总是建议孵化期项目在参与者做出具体贡献之后尽快授予他们 Committer 身份，以鼓励人们持续做出贡献。他所理解的 Apache 之道应该关注到绝大部分参与者的情况，出于时区、本职工作和陪伴家人等等原因，参与者并不总是全力为某个开源项目工作。</p>
<p>Kvrocks 的 PMC 成员基于这样的认识，结合 Twice 在六月上旬时已经完成的工作和表现出来的能力水平，经过 Apache 社群议事的标准流程投票通过邀请 Twice 成为 Kvrocks Committer 的一员。成为 Kvrocks Committer 之后至今的两周里，Twice 在保持原本的参与水准之外，更加积极地 review 其他社群成员的补丁，并协调不同 pull request 和合并参与者贡献的代码。</p>
<p>可以看到，Apache 开源社群激励参与者共同制作“石头汤”的具体方式，就是以参与程度和具体贡献回馈参与者相应的声誉和权威。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>软件行业的经典著作《程序员修炼之道》描述了一个“石头汤”的寓言，在开源社群当中也存在着类似“石头汤”的协作流程。不同于原始版本多少带点欺骗的味道，开源协同的模式强调最初的软件本身即是一个可用的软件。而与原始版本相同的是，开源协同与外来人制作“石头汤”时采取的策略重点都在于做推动变革的催化剂。</p>
<p>开源软件的维护者们也可以借鉴“石头汤”的魔法，在一个基本可用的软件的基础上，抛出可以做的更好的可能性，身体力行并团结潜在的开发者一起不断实现做出的预言，最终为行业制造出一个高质量的开源软件。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>《纳瓦尔宝典》书评</title>
    <url>/2022/06/09/the-almanack-of-naval-ravikant/</url>
    <content><![CDATA[<p>近日在《大教堂与集市》的译者卫剑钒的推荐下阅读了这本被评价为新时代《穷查理宝典》的《纳瓦尔宝典》，其中有部分观点确实很有启发。卫 Sir 给这本《纳瓦尔宝典》专门写了两篇书评，已经把书中的精华几乎都介绍完全了。我在这里出于自己的理解和感悟，做一点微小的补充。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/-OWTtpNzaxzVjQnyJT1sAw">神书《纳瓦尔宝典：财富和幸福指南》说了些什么</a></li>
<li><a href="https://mp.weixin.qq.com/s/s-PN70IHmltJTmTCn5gvFA">我从纳瓦尔那里学到的22条</a></li>
</ul>
<span id="more"></span>

<p>这本书大致分成四个部分：前言、关于财富、关于幸福，以及额外推荐。四个部分的内容大约是 1:3:3:1 的比例，核心内容很符合书的副标题“财富和幸福指南”。</p>
<p>本文会聊一聊我在阅读此书的过程中在关于财富方面的体悟。关于幸福的箴言我读下来比较笼统，大致是“活在当下”和“关爱自己”。卫 Sir 在第一篇文章当中的 17 个要点里有 5 个要点是关于幸福的，第二篇文章学到的 22 条当中几乎全是关于财富的。我想我不至于在人生感悟和什么是幸福上有超过卫 Sir 的见解，索性不谈。</p>
<h2 id="发挥杠杆，不靠运气致富"><a href="#发挥杠杆，不靠运气致富" class="headerlink" title="发挥杠杆，不靠运气致富"></a>发挥杠杆，不靠运气致富</h2><p><a href="https://twitter.com/naval">纳瓦尔</a>投资过推特，本人是重度推特用户。他最有名的系列推文是<a href="https://twitter.com/naval/status/1002103360646823936">“如何不靠运气致富”</a>，直到今天仍然是其推特置顶内容。</p>
<p>这系列推文的落脚点在于“把自己产品化”，也就是利用你的专长和对自己的责任心，发挥杠杆赢得财富。推文中定义“财富是指你在睡觉时仍能为你赚钱的资产”，也就是中文语境下常说的“被动收入”或者“睡后收入”。纳瓦尔认为，如果你的收入完全来自于出卖时间，那么随着年龄的增长，能够投入到这种交易当中的时间和精力都会锐减，从而你的收入不会像拥有优质资产那样随着时间的推移产生复利效应。</p>
<p>获得优质资产的方式就是发挥杠杆的力量。书中将可以致富的杠杆分为三类：</p>
<ol>
<li>劳动力杠杆，也就是让别人为你打工。这是一种最古老的杠杆，也是在现代社会发展出创造财富的正和游戏之前，长期的主基调争夺地位的零和游戏所依赖的杠杆。如今，劳动力杠杆对于个人而言可能是最落后的杠杆，因为管理他人是一件非常复杂、极具挑战的工作，需要高超的领导技巧，弄不好管理者会落得个众叛亲离，被手下生吞活剥的下场。</li>
<li>资本杠杆，也就是用钱来扩大决策的影响力。这是工业革命和资本阶级革命以来创造的新杠杆，也是上世纪创造财富的杠杆的主要形式。管理资本比管理人要容易，但是利用资本杠杆仍然有一定的难度，赢得资本青睐也需要相应的技能。</li>
<li>“复制边际成本为零的产品”产生的杠杆，其中包括书籍、媒体、电影、代码。这是随着信息技术跨越式发展带来的红利。即使是个人，也可以利用蓬勃发展的内容渠道来放大自己的影响力。毫无疑问，纳瓦尔本人就通过推特和本书至少数以百万倍地扩大了自己的影响力。</li>
</ol>
<p>纳瓦尔发现，第三种杠杆最重要的特点之一就是，使用它们以获得成功无须经过他人许可。劳动力杠杆依赖于其他人的信任和追随，资本杠杆依赖于有人提供资金。然而编程、写书、录播客、发推特、发视频这些事情不需要经过他人的许可。这几乎是一个人可以没有边际成本地成倍放大自己专长的手段。纳瓦尔对自媒体的发展和互联网及其上应用创造价值的能力的洞察力有很强的预见性。</p>
<p>杠杆解决的是从 1 到 100 乃至 10000 的问题，也就是藉由“规模化”来实现自己的“产品化”。然而，致富之路仍然需要发掘自己的专长来实现从 0 到 1 的突破。</p>
<p>纳瓦尔认为，专长可以分为销售技能和构建技能。构建技能指的是每个行业当中创造核心价值的能力，例如工程师之于科技行业。销售技能指的是把概念、理念或者产品“卖”给其他人的能力，包括销售商品，也包括市场营销、媒体传播、人才招聘、资金募集、员工激励、公共关系等等。专长是自己的兴趣所在，你能够轻松地掌握，然而社会却很难通过培训让另一个人快速地掌握同样的技能来取代你。如果一个人能同时掌握构建技能和销售技能，那么他在这个领域当中将势不可挡，或者说即使一开始只有一个人，但是很快也能集结和发挥出一个团队的力量。</p>
<p>纳瓦尔主张通过创业或者参与到创业过程当中赢得财富，这两者的共同点是拥有企业股权。纳瓦尔认为，能够产生被动收入的优质资产几乎都来自于企业股权。当然，并非所有企业都会成功，也就是说前一句话反过来不成立，不是所有企业股权都是优质资产。纳瓦尔认为，你应该在充分了解自己专长的情况下想方设法创业或者参与到创业过程当中去，勇于承担责任以取得相应的杠杆。一个好的领导者需要承担责任并带领团队取得连续的胜利，以赢得个人的信誉和财富奖励。</p>
<p>然而，承担责任也意味着当事情走向失败的时候，责任人会首当其冲。纳瓦尔认为，这类风险当中，唯一要避免的就是身败名裂的风险。</p>
<blockquote>
<p>避免身败名裂的意思就是不要锒铛入狱。所以，不要做任何违法违纪的事情，任何事都不值得拿自己的自由和声誉去冒险。要避免一败涂地的灾难性损失。避免身败名裂也意味着不要做那些可能会威胁自身安全或健康的事情。你必须照顾好自己的身体。不要做可能会让你全盘皆输的事情。不要孤注一掷、铤而走险。相反，要把赌注压在那些胜算较大、能带来巨大利益的事情上。</p>
</blockquote>
<p>这也是创业过程当中要保持的底线思维，大部分人没有经受一次身败名裂的抗风险能力，因此在绝大多数情况下都应该谨记“狡兔三窟”的智慧，而不是眼睛一闭、孤注一掷、放手一搏、铤而走险。</p>
<h2 id="对抗诱惑，利用空闲时间"><a href="#对抗诱惑，利用空闲时间" class="headerlink" title="对抗诱惑，利用空闲时间"></a>对抗诱惑，利用空闲时间</h2><blockquote>
<p>现代斗争：孤独的个体召唤出非人的意志力，进行断食、冥想、锻炼……对抗大批科学家和统计学家以充足的食物、药物和电子屏幕为武器制造出的垃圾食品、标题党新闻、无限的色情内容、无穷无尽的游戏、令人上瘾的毒品。</p>
</blockquote>
<p>毫无疑问，现代社会信息量大爆炸，每天产生乃至只考虑通过手机和各种媒介推送到一个人面前的信息已经远远超出一个人所有的精力。如何对抗这些时间杀手，赢得属于自己的可支配时间，是每个人都需要面对的挑战。</p>
<p>过去，诗歌当中也写到“劝君莫惜金缕衣，劝君惜取少年时”，或者是“莫等闲，白了少年头，空悲切”。但是那时人蹉跎时间的主要原因，是在缺乏足够的知识和信息输入的环境下，平白无故地浪费时间。如今人们面临的问题是大量信息一股脑地推送到眼前，每一个应用都迫不及待地想要打断你正在做的事情，让你把时间花在它们身上，尤其是各类存在上瘾性的图片、视频、直播。</p>
<p>纳瓦尔提到，你需要以非人的意志力来对抗这些内容，把时间和精力花在少数对自己有意义的事情上。大学期间，我的数学分析课程老师讲过，如果每天起来你无事可做，这是很糟糕的；但是如果每天起来你发现有太多的事情要做，以至于不知道从何下手，这也是很糟糕的。这也许是现代版的“过犹不及”。现代人不愁找不到消耗时间的娱乐，面临的难题几乎总是如何减轻自己认知和精力上的负担。</p>
<p>纳瓦尔还有一个有趣的观点，“只有在你感到无聊之后，才会有伟大的想法。好的想法从不会在你充满压力、忙碌、四处奔波或仓促的时候出现”。我本人可以佐证这一说法的真实性。只有在充分放松的环境下，思维才有可能不受限制地遨游，灵感才有可能自由地迸发。</p>
<blockquote>
<p>知识劳动者的时间安排与运动员如出一辙，有训练和冲刺的时间，也有休息和重新评估的时间。</p>
</blockquote>
<p>这一点在<a href="https://book.douban.com/subject/1322025/">《卓有成效的管理者》</a>和<a href="https://book.douban.com/subject/25956450/">《人件》</a>当中都有提及。这也是我个人倾向于远程办公的重要原因之一，我在办公室几乎无法拥有彻底放松的时间，也就不会有接下来长达几小时的“心流”式的集中工作的时间。例如现在是早上八点钟，而我花在写作这篇文章上的时间已经过去了一个半小时。如果今天我需要过去办公室上班，此时我所想的唯一的事情就是再睡一会。</p>
<h2 id="学习决策，锻炼判断能力"><a href="#学习决策，锻炼判断能力" class="headerlink" title="学习决策，锻炼判断能力"></a>学习决策，锻炼判断能力</h2><p>我在深度参与了企业创业和开拓新业务的过程之后，深刻理解到了构建能力是做成一件事情的必要条件，而判断和决策能力是能否充分发挥出自己和团队构建能力的决定性因素。</p>
<p>我们的教育主要教授的是在相对确定的条件下做出判断的能力，也就是所谓的做题家思维。然而，开拓一个崭新的业务，创造属于自己的企业和事业，绝大多数情况下要求你在极度不确定的情况下做决策，也就是所谓的<a href="https://book.douban.com/subject/27621053/">灰度决策</a>。这种情况如此新颖和重要，正是纳西姆·塔勒布的<a href="https://book.douban.com/subject/6854525/">《黑天鹅》</a><a href="https://book.douban.com/subject/25782902/">《反脆弱》</a>系列图书流行的原因。</p>
<p>纳瓦尔认为，你应该锻炼自己的决策判断能力。这种能力的核心要点就在于诚实地面对客观条件。</p>
<p>创业过程当中，绝大多数人都会过分乐观地估计自己遇到的问题。我们的文化倾向于维持一团和气，因此即使“事情似乎有些不对”，也很少有人站出来批评。哪怕有人站出来批评了，往往秉承“和光同尘”原则的组织风气也会倾向于“各打五十大板”式的“两边都有错”或者“两边都没错”。传统文化上，我们简称之为“和稀泥”。这也是我经常遇到的情况。</p>
<p>我本人的交流模式是相对武断的，但是从来都欢迎别人抨击我的观点。可以说，在我发现自己认识错误的那一刻，光速土下座的流畅程度已经登峰造极。当然，很多议题并非一定要分出个对错或者一定有对错，我的做法是秉承“君子和而不同”的原则积极交流，只有坦诚地交流才能碰撞出好想法，不一定要在谈话对象之间达成一致。</p>
<p>另一个在不确定性的世界当中高效决策的要点，是把握委托和代理的边界。本书当中，“委托”的意思是自己成为委托人，也就是自己去做一件事情，这会带来主人翁的责任感；“代理”的意思是成为被他人委托的代理人，因为本质上是在为别人做事，那么一旦你的利益和委托人的利益产生冲突，做事的结果就可能很糟糕。</p>
<p>创业公司常讲 ownership 的概念，跟这里想表达的意思是一致的。往往创始人和创始团队对组织有较强的 ownership 意识，这种主动性足以让人把事情做得相当出色。开源社群的协作就是基于这样的设计，同时突出了这种 ownership 意识所需要的土壤，即充分的信任和授权。</p>
<p>Apache SkyWalking 的创始人<a href="https://twitter.com/wusheng1108/status/1531953194733301760">吴晟在推特上提到过</a>，机制保证，和防范措施是一个非常公司角度的看法。开源是一个基于贡献和信任的环境，传统的“人必作恶”的思路不适合。开源社群生产高质量开源软件的保证，主要是参与者的责任心。完成任务和认真艺术化的完成，绝对是天差地别。</p>
<p>我在 PingCAP 的某次分享会上，也提到过我们到底是以一个打工人的心态在不情愿地写代码，还是作为 TiDB 的共同作者在打造高水平的开源软件，这是我们能否冷启动开源开发者社群的重要评判标准。没有人比创业团队更在乎自己的产品，如果核心团队成员在决策模型上都把自己当做被委托的代理人角色，那么事情是办不成的。</p>
<p>从决策者的角度看，如何合理地决策委托自己和委托他人，决定了能否将自己有限的时间投入到优势领域上，将团队成员的时间投入到他们各自的优势领域上。如果一个决策者事必躬亲，那么哪怕他能够通过某种方式聚集到愿意追随他的人，劳动力杠杆也是不工作的。因为在他自己搞明白一件事情之前，这件事情不可能有任何进展。这种情况下，团队的上限就被这位决策者完全限制住了，而个人的上限尤其在分工日益复杂的现代社会当中是非常有限的。</p>
<p>最后，有一个“万能”的判断法则：</p>
<blockquote>
<p>如果你难以抉择，那答案就是否定的。</p>
</blockquote>
<h2 id="注意人品，坚持核心价值"><a href="#注意人品，坚持核心价值" class="headerlink" title="注意人品，坚持核心价值"></a>注意人品，坚持核心价值</h2><p>纳瓦尔在书中提到了四个核心价值观，除去最后一个“愤怒是毫无意义的”对我来说没有深刻的冲击力，其他的三点都是我自己自觉不自觉的坚持的准则。在书中看到以文字形式明确地说明这些价值观，很有共鸣。</p>
<p>第一个核心价值观是诚实。诚实听起来是一个简单到陈词滥调的品质，但是实际做到却不容易。对我自己而言，诚实恰恰是容易被证明的，而不需要长篇大论。我不喜欢故意隐瞒或者欺骗，因为为了圆上一个谎往往需要一千个新的谎言，这些谎言又需要再被圆谎。我在不同场合都提到过，我分享自己的观点的时候总是会检验说出来的话是否问心无愧。谎言往往是在不同人面前表达了不同的观点，也就是所谓的人前一套人后一套。为了维持这样的生活和脆弱的平衡，需要付出无限的心血，并且终有一天会迎来破灭。因此我会对自己诚实，也对他人诚实。这也是我前面提到我期望更直接的交流模式，并且做到及时认错和转弯的原因。如果一个人一贯正确或者不容挑战，那么这本身就是一个无法被圆谎的谎言，为了维持一贯正确所需要付出的努力，已经远远超出能够投入到创造价值当中的努力，岂非南辕北辙乎？</p>
<p>第二个核心价值观是长期主义。这一点我在最近分享关于开源的话题已经讲过多次了，开源社群的建设和发展是明显的长期主义。Apache Group 早在上世纪就成立，而今天被广泛使用的 Apache License 2.0 直到 2004 年才写成。社群清楚地认识到自己存在的问题需要时间，试错、沟通并找到共识解决方案需要时间。部分创业者或上市公司老板认为，商业不同于开源社群，是能够超越规律短平快地创造价值的。这对于追求短期利益本身来说或许没错，在我们借鉴其他发达国家成熟的模式加速追赶的过程当中也有一定的适用性。然而，具有创造性的，跨越经济周期乃至长达一个人一辈子的价值，都来自长期主义和复利效应，无论是财富、人际关系、爱情、健康、活动，还是习惯。</p>
<p>第三个核心价值观是平级关系胜过等级关系。这从前文反对“一贯正确”并且追求坦诚沟通就能看出来，我也持有同样的观点。等级社会往往不容质疑，决策只来自于上行下效，这与每个人平等地发挥自己的主观能动性相矛盾。</p>
<p>我首先接触的集体合作模式就是开源社群的开源协同模式。在 2017 年的 Perl 6 网络聊天室当中，我可以和 Perl 语言的创始人 Larry Wall 直接沟通，当时他用的是 @<a href="https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it">TimToady</a> 的昵称。我在读文档的时候看到关于面向切面编程（AOP）相关的描述，完全不明白说的是啥，就在聊天室里询问，而他正好在线，就跟我分享了对这个范式的见解。直到几个月之后，我才知道这位聊天室的 TimToday 成员，GitHub 上挂着 Perl 6 吉祥物<a href="https://www.raku.org/camelia-logo.png">“幺蛾子”</a>的这个人，就是 Larry Wall 本人。</p>
<img src="/2022/06/09/the-almanack-of-naval-ravikant/camelia-logo.png" class="" title="Perl 6 的吉祥物“幺蛾子”">

<p>去年底的时候我写过一篇<a href="https://book.douban.com/subject/26894636">《开放式组织》</a>的<a href="open-organization.md">书评</a>，以及其中提到的<a href="https://book.douban.com/subject/27125968/">《企业的人性面》</a>这本相关联的组织管理经典的观点，都是关于协同当中平级关系的支撑。</p>
<blockquote>
<p>我赞同平级关系，不接受等级关系。我不想高于任何人，也不想低于任何人。如果我和别人不能像平级那样对待彼此，我就不想和他们交往了。</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这本书虽然有两百多页，但是在卫 Sir 书评的引导以及过往经历的印证下，读起来并不费劲。如同书中推荐序和卫 Sir 在书评和读书群当中所说，这本书常读常新。它毕竟是一名现成的“成功人士”得到广泛认同的经验之谈，在人生不同的阶段和经历不同的事情之后，再读一遍这本书，总是会有不同的体会。也许这就是经典书籍的魅力吧。</p>
<p>强烈推荐一读！</p>
]]></content>
      <categories>
        <category>大图书馆</category>
      </categories>
  </entry>
  <entry>
    <title>《大教堂与集市》书评</title>
    <url>/2021/12/14/the-cathedral-and-the-bazaar/</url>
    <content><![CDATA[<p>历时五天，我总算把<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>这本经典的开源文化著作认真读了一遍，真是酣畅淋漓。</p>
<p>本书是作者 Eric S. Raymond 的文集，其中最著名的一篇就是《大教堂与集市》，其他几篇分别是《黑客圈简史》《开垦心智层》《魔法锅》和《黑客的反击》。最有价值的是《大教堂与集市》和《开垦心智层》两章，系统解释了开源软件是如何生产的，开源开发的优势在哪，开源软件的传承是如何做到的。《魔法锅》解答了一些常见的关于开源软件使用价值和销售价值的问题，但是受限于时代背景，对商业化的讨论局限在夸大使用价值的部分，不能很好的指导基于开源软件提供软件服务的商业模式。</p>
<p>在进入具体的内容讨论之前，必须着重提到译者卫剑钒对中译本创造的价值。翻译是对原内容的二次创作，软件开发领域外文著作众多，大部分译本都让原文表意有明显的损失。卫剑钒翻译的《大教堂与集市》，阮一峰翻译的<a href="https://book.douban.com/subject/6021440/">《黑客与画家》</a>，以及云风翻译的<a href="https://book.douban.com/subject/35006892/">《程序员修炼之道（第二版）》</a>是我近一年来读过的本领域最佳译作。</p>
<span id="more"></span>

<h2 id="开源协同的优势"><a href="#开源协同的优势" class="headerlink" title="开源协同的优势"></a>开源协同的优势</h2><p>《大教堂与集市》一章主要讲的就是开源协同的优势。集市模式就是开源协同的模式，本章的要点在于论证这种模式能够生产出高水平的软件，以至于超过任何商业公司闭门造车的软件。原文的论述重点在同行评审的价值，辅以拥有用户的重要性，落点在如何以集市模式领导开源项目。出于讨论流畅性的考虑，我把前两点的顺序调换然后展开。</p>
<h3 id="拥有用户"><a href="#拥有用户" class="headerlink" title="拥有用户"></a>拥有用户</h3><p>对于任何软件来说，获取用户都是一个艰难的生存挑战，持续的用户反馈能够帮助软件不断修正前进方向，没有用户也即意味着软件的死亡。开源软件能够在早期发展阶段吸引到足够的注意力和用户。</p>
<p>一种形式是如原文作者继承 popclient 项目，从而直接继承其用户群。这在商业公司开发的软件当中是不容易做到的，因为涉及到专有软件的所有权转移，总是非常的繁琐且挫败的。大部分商业公司开发的软件，一旦因为种种原因不再维护，往往无法为人所继承而是彻底死亡。</p>
<p>因此，如今的用户对全新的专有软件往往抱有很强的怀疑态度。例如，最近一段时间迸发出来的新兴数据库软件，如果我无法获得它的源码，那么我如何能够自由地探索它呢？成熟的闭源商业软件辅以用户手册或许没有这个烦恼，但是软件的更替是不可避免的，新兴软件刚出世时，往往欠缺文档，功能不全，只有阅读源码甚至加以修改才堪堪能用。这种情况下，开源软件不是比闭源软件更好的问题，而是只有开源软件才能生存下来的问题。</p>
<p>此外，围绕开源软件或软件群形成的开源共同体有内部共通的价值观。如果你制作了一个新的开源软件，在潜在的用户群组里发帖介绍自己是不会被排斥的，如果软件质量不错，还会得到用户的自发传播。例如，我在 GitHub DCO App 异常期间，顺手开发了一个基于 GitHub Actions 的方案并在原 issue 下<a href="https://github.com/probot/dco/issues/162#issuecomment-942926111">评论介绍自己的解决方案</a>。没有回复会认为这是恶意竞争，而是出于解决问题的群策群力。又例如，Engula 项目开发过程中，向 Rust Community 和其他相关主题的资深开源开发者均寻求过意见和建议，其中认可 Engula 项目价值的人，就会自发的传播它。这对于商业软件来说是不可想象的，如果上面的行为替换成一个闭源商业软件，则参与者会认为你是一个销售人员而不是黑客同行，并且对一个完全黑盒的全新解决方案兴趣寥寥。</p>
<p>最后，开源软件不会将自己的用户局限在销售关系以内，这往往能保证软件开发者有更强的主导能力，按照符合软件工程的方式开发高质量软件，而不是在需求爆发的压力下将软件绑定在单一用户的需求上。</p>
<h3 id="同行评审"><a href="#同行评审" class="headerlink" title="同行评审"></a>同行评审</h3><p>同行评审是原文论述的重点，实际上，集市模式的核心价值就在于跨越组织边界的独立的同行评审验证设计和保证正确性。原文将其称为“Linus 定律”，即</p>
<blockquote>
<p>如果有足够多的 beta 测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。</p>
</blockquote>
<p>不过针对这个定律有两点需要解释。</p>
<p>第一点是它所强调的是独立的同行评审实施的简单性和有效性，而不是单纯的“人多力量大”。</p>
<p>开源开发的价值之一就是源代码公开使得任何人都可以分析代码逻辑以定位问题。时至今日，传统的研发组织仍然把开发人员和测试人员区分成两个竖井，测试人员几乎只能完成黑盒测试。可想而知，缺乏分析的现象型 bug 报告往往需要耗费开发人员相当多的时间重新验证、复现和定位。如果让对源代码一无所知的测试人员为 bug 定级，则两类人员之间的冲突会更加尖锐。</p>
<p>开源开发打破了这种困境。由于大家都有真实的源码，开发者和测试者很容易发展出一个共享的表达模式并进行有效的交流。一个现象型 bug 报告和一个直接关联到源码的分析型bug报告，对开发者解决问题的帮助简直是天壤之别。Linus 定律建立在开源开发的基础上，强调的是拥有源码以后加入新的眼睛的成本不在包含商业公司管控带来的限制和摩擦，从而能够从基数足够大的同行评审当中获取高价值的报告。</p>
<p>原文引用<a href="https://book.douban.com/subject/26358448/">《人月神话》</a>的 Brook 定律，提到随着开发人员数目的增长，项目复杂度和沟通成本按人数的平方增加，而工作成果只会呈线性增长。对于这个论点，原文作者是认同的。但是，开源项目所采用的沟通方式，区分成少部分核心开发人员与由 beta 测试者和潜在的贡献者组成的外围人员。外围开发者实际工作在分散而并行的子任务上，他们之间几乎不交流；代码修改和bug报告都会流向核心团队，只有在那个小的核心团队里才会有 Brooks 开销。</p>
<p>这揭示了开源开发的精英领导制内核，也解释了 Linus 定律虽然常被简化成“只要眼睛多，bug 容易捉”，但是却不是简单的“人多力量大”。</p>
<p>第二点是开源软件当中出现 bug 是正常的。这一点过于天经地义以至于当我发现我需要强调它的时候有些震惊。近年来出现的“心脏滴血”和前几天的 Log4Shell 漏洞，导致部分声音认为开源项目的使用是有风险的。</p>
<p>对此，我只能说，这当然啊！软件有 bug 不是正常的事儿么？开源开发不是银弹，任何复杂的软件都会有 bug 存在。Linus 定律成立的案例 Linux 是在高速发展的过程中保持了相对稳定的质量，而不是从来没有 bug 出现。如果你认为开源软件有不可承受的风险，最佳做法是参与其中对它做出改良。</p>
<p>此外，开源软件的许可证往往附带了免责声明，也即这个软件的源代码就这样（AS IS）给你了，没有任何保证（WITHOUT WARRANTIES）。在应用当中整合开源软件之后，保证应用的正确运行与安全性是应用开发者的责任。开源软件会因为安全问题损失声誉，因此作者会尽力提高安全性和正确性，并辅以相应的测试验证，但是这些都是尽力而为，没有保证。</p>
<h3 id="集市模式"><a href="#集市模式" class="headerlink" title="集市模式"></a>集市模式</h3><p>《大教堂与集市》一章的落点在如何以集市模式领导开源项目，这种模式相较传统的管理架构有何不同。</p>
<p>其中很多原则和技巧不是开源特有的，并通过敏捷等理念渗透到商业公司的软件开发当中。例如，“好的软件作品，往往源自开发者的个人需要”，“早发布，常发布，倾听用户的反馈”，以及“想出好主意是好事，从你的用户那里发现好主意也是好事”等等。</p>
<p>其中最重要的一点是关于发布的。开发者在需求列表不能调整和最后期限不能拖延的双重要求下，会完全顾不上质量，整个工作很可能会变成一团乱麻。Linux 通过发布两种不同类型的版本，各自宽松其中一个要求来保证软件质量和进度的协调。</p>
<blockquote>
<p>一种办法是保持最后期限不变而让需求列表灵活一些，允许某些到最后期限时仍未完成的需求被舍弃，这基本上就是“稳定版”核心采取的策略。 Alan Cox（稳定版核心的维护人）以相当规律的时间间隔将核心发布，但并不保证某个特定bug何时被修复，也不保证实验版中的某个特性何时会搬到稳定版中。</p>
<p>另一个办法是设定好想要的需求列表，并在其完成时发布，这基本上是“实验版”核心的策略。 De Marco 和 Lister 引用研究结果，指出这个进度策略即是“好了告诉我”，这不仅能够保证最高质量，而且就平均而言，与“保守”或“激进”的进度安排相比，它的交付时间更短。</p>
</blockquote>
<p>对于与传统的管理架构比较的部分，其理论基础可以参考<a href="https://book.douban.com/subject/26894636">《开放式组织》</a>与<a href="https://book.douban.com/subject/27125968/">《企业的人性面》</a>相关的论述。概括地说，开源的方式给予开发者足够的自由，以吸引高水平的黑客自发地创造价值。这种超越了对安全需要乃至生理需要的追求的模式，激发的是参与者对社会需要和自我实现需要的热忱。</p>
<p>在这里，没有预设的团队和资源，不需要在办公室环境下吞并其他团队的资源或者对其他团队的进攻做出防守。开源开发者是志愿者，是因为兴趣和能力自主选择的，他们会把自己的资源带到工作中，而不需要关心团队之间的领土争端和倾轧。</p>
<p>在这里，参与者凭借其创造的价值赢得权威。也就是说，最有才华的人能够对项目的发展做出最合适的决定。这不同于雇佣关系下被强制调配的人与项目之间的关系，而是对于特定的人，自由选择适合自己的项目，对于特定的项目，自然筛选出最合适的人。</p>
<p>原文还提到一种观点，即传统开发管理能保证艰苦和乏味的工作总能落实。我想这点毫无疑问是错误的。Linux 和 Kubernetes 的文档充足到令人难以置信，反过来只为了领工资才上班的人往往消极对抗撰写文档和测试或调试问题等工作。</p>
<p>开源共同体的目的是制造高质量的软件，在这个共同目标的引领下，不同方面的人才聚拢起来发挥自己的价值，反而是能够找到对传统开发管理认为艰苦和乏味的工作甘之如饴的人才。对于项目维护者来说，认识到这些所谓“无聊”部分的价值，协同参与者完成它们，是项目能够脱颖而出的必要条件。经过二十年来的经验积累，这逐渐成为最有才华的黑客当中的共识。</p>
<p>最后，对于想要实行集市模式的人，这里转述原文提到的“集市模式的必要条件”。</p>
<p>集市从成立伊始，就需要一个可以运行和测试的东西。当开始建设开源共同体的时候，你需要拿出一个像样的承诺。程序此时并不需要特别好，它可以简陋、有错、不完整，文档可以少得可怜。但它至少要做到能运行，且让潜在的合作开发者相信，这个软件在可预见的未来，能演变成一个非常棒的东西。</p>
<p>项目领导人需要能识别出别人的优秀创意，掌握一定水准的设计和编码能力，并且必须具备很好的人际交往和沟通能力。最后一点应该是显而易见的，为了建立一个开源开发共同体，你需要吸引人们，让他们对你做的事感兴趣，让他们乐于看到自己的贡献。一些技巧可能有助于实现这些，但远远不是全部，你的人格特征也很重要。</p>
<h2 id="开源软件的传承"><a href="#开源软件的传承" class="headerlink" title="开源软件的传承"></a>开源软件的传承</h2><p>《开垦心智层》一章讨论开源共同体的发展，以及发展过程中开源软件的所有权及转让的问题。</p>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>原文提到，开源软件的所有权获取有三种形式。</p>
<blockquote>
<p>第一种也是最显然的，就是去创建这个项目，当这个项目在开始时就只有一个维护者而且这个维护者仍然起作用的时候，所有权问题是连提都不该提的。</p>
<p>第二种方式是获取前任对所有权的移交（有点像“接力棒传递”）。这在社区中很容易理解，当项目“所有者”不愿意或者不能在开发和维护中投入必要的时间时，他（她）有义务将项目移交给一个有能力的继任者。</p>
<p>第三种方式是一个项目需要维护但项目所有者已经消失或失去兴趣了。如果你想维护该项目，你的责任是努力找到这个“所有者”，如果找不到，你可以在相关场所（比如 Usenet上专注于该应用领域的新闻组）声明该项目似乎是一个“孤儿”，而你想为之负责。</p>
</blockquote>
<p>我在协助处理 TiDB 里两个合并子项目的工作的时候，实质上就遵循了这里的原则。原来的项目由多名 contributor 参与完成，在当时的 CLA 设置下，要求每位 contributor 都必须和 TiDB 项目签 CLA 才能合并。比起强硬的改变 commit author 绕过 CLA 检查，我建议尝试联系未签署 CLA 的参与者补上。这些参与者被 at 以后很快响应并且解决了问题。</p>
<p>其实参与开源开发的人不是坏人，在项目没有发展出多样性之前，不要擅自以“内部”“外部”这种二元视角界定参与者的属性，也不要假设“外部”是邪恶的。</p>
<h3 id="分化"><a href="#分化" class="headerlink" title="分化"></a>分化</h3><p>原文将分化行为列为开源文化当中的禁忌。分化指的是派生出一个随后不能交换代码的竞争项目，并导致开发者群体的分裂。</p>
<blockquote>
<p>黑客厌恶项目分化的另一个原因是，他们惋惜那些被浪费的重复工作分化后的两个子项目总是有着或多或少平行的演化路线。他们也会注意到分支倾向于分裂合作开发者社区，使得两个子项目的人手都比父项目的人手更少。</p>
</blockquote>
<p>近年来雨后春笋般冒出来的开源项目，在分支和合作问题上起码有两点值得关注。</p>
<p>第一点是对合作的漠视。相当部分项目，号称开源，实则核心成员还是都来自同一个公司团队，规模往往超不出十几人。他们有很强的领地意识，拒绝其他人的参与，或者将其他人的贡献打包进项目整体说成都是该公司的贡献。这样做，使得不同组织的参与者失去动力甚至有种被驱逐出去的意味，实质上只是源码可得的传统项目开发模式。</p>
<p>当然，也有好的案例，且大多来自公司背景不强的项目。例如 <a href="https://github.com/InterestingLab/seatunnel">SeaTunnel</a> 还叫 WaterDrop 的时候，就吸引了不同组织成员的关注和参与，现在又被 Apache 成员关注到，合作进入 Apache 孵化器孵化。</p>
<p>第二点是对分支的痴迷。也就是公司喜欢 fork 出来搞个魔改版本，从不考虑 contributing back 还以为自己占了便宜。且不说这种行为禁锢了原本可以参与共同体的成员，代码分化带来的兼容性问题魔改版本从来不能解决。回过头来把魔改版本抛头换面又煞有介事的“开源”，应该被整个黑客社会所唾弃。</p>
<p>如果说还有一点，那就是那些所谓的“开源技术公司”，如果试图对开源共同体实施某种形式的管控，让商业公司凌驾于志愿者之上，那么这样的项目实际上更容易分化。Elastic 和 <a href="https://github.com/opensearch-project/OpenSearch">OpenSearch</a> 就是一个典型的例子。</p>
<blockquote>
<p>对于相对开放的民主制度而言，它的一个主要优势在于，绝大多数潜在的革命者发现通过在系统中工作比攻击该系统更容易让自己向目标前进。但如果既有政党联合起来“提高门槛”，导致那些较小的不满意团体觉得更难实现自己目标的话，这种优势就很容易被侵蚀破坏。</p>
<p>准入门槛不高的开放过程鼓励参与而非分裂，因为参与者能从中获得成果，而不用付出分裂所需的高昂成本。尽管这种成果可能不像分裂所得成果那样令人印象深刻，但其成本较低，且大多数人都能接受这种折衷。</p>
</blockquote>
<h3 id="冲突与解决"><a href="#冲突与解决" class="headerlink" title="冲突与解决"></a>冲突与解决</h3><p>原文提到，项目当中的冲突与解决主要围绕三个问题展开</p>
<ol>
<li>谁来负责做设计决策？</li>
<li>如何决定哪个贡献者应该被授予荣誉，如何授予？</li>
<li>如何保持项目团队和产品不被分裂为多个分支？</li>
</ol>
<p>第一个问题由上述所有权问题回答。关于分支的问题在上一节已经讨论过了。现在看第二个问题。</p>
<p>无论采用独裁者模型还是委员会模型，黑客的荣誉都跟他创造的价值相关。也就是说，黑客的声誉在礼物文化的大背景下，由他的贡献即赠与开源共同体的礼物的价值所决定。对于独裁者模型来说，独裁者本人需要能够践行这样的规则，否则高水平的参与者就会选择离开。对于委员会模型来说，还有一个额外的问题是委员会自身应该避免冲突。原文质疑委员会模型难以避免冲突</p>
<blockquote>
<p>在这种形式中，我们很难看到内部边界，并因此很难避免冲突，除非委员会内部享有极高水平的和谐与信任。</p>
</blockquote>
<p>但是，今天的软件复杂度越来越不支持独裁者模式。如果独裁者本人已经把部分决策权交给参与者，那么他在运行上就类似于委员会的模式。即使独裁者名义上拥有最终决定权，他与维护某一模块的核心成员仍然需要保持高水平的信任以减少项目当中的摩擦。</p>
<p>结合如今一部分商业公司创建或大规模参与开源项目的背景，如果项目建立的是同侪共同体（community of peers），也就是说成员的角色与个体相关，而不是与他在某个组织的职位相关，在这种情况下依然把委员会的人员增加与企业员工入离职挂钩，这种组织形式就是非常危险的。</p>
<p>具体地说，部分项目照猫画虎地搬来了 Apache 软件基金会式的同侪共同体设计，在决定项目 PMC 成员和 committer 人选时，却变成了公司同事入职，“理应”有 commit 权限，就稀里糊涂的成了什么 committer 或 PMC 成员。一旦离职，则完全不理会项目的发展，甚至出于不愉快恶意捣乱项目的日常事务。这就是没有基于项目的需要和个体对项目的认可和贡献选择委员会成员的弊病。</p>
<p>这是说缺乏多样性的项目中，单一公司的员工需要避嫌吗？当然不是。实际上，成为大力投资该项目的公司的雇员，能够尽可能多的时间投入到项目发展上，公司的员工确实有更大的可能性成为核心成员。但是必须注意的是他的推举应该是客观的，基于项目的需要和个体对项目的认可和贡献来选择。只有这样，才能努力做到委员会内部有极高水平的和谐与信任，这才是这种组织形式下项目长久发展的根基。</p>
<h2 id="开源与商业模式"><a href="#开源与商业模式" class="headerlink" title="开源与商业模式"></a>开源与商业模式</h2><p>《魔法锅》一章的主题是开源与商业模式，着重讨论了反公地模型，软件的使用价值和销售价值，以及当时存在的开源相关的商业模式。</p>
<h3 id="反公地模型"><a href="#反公地模型" class="headerlink" title="反公地模型"></a>反公地模型</h3><p>我曾多次听到有人拿“公地悲剧”来类比开源协同的开发模式，认为后者也会如前者一样失败。</p>
<p>所谓的公地悲剧，指的是假设一个村庄里的所有人都可以不受限制地在一片公共的草地上放牧，如果没有一个共识来抑制过度放牧，出于自身利益的考虑，每个人都会尽可能多的放牧，以期在公地资源耗尽之前从中获取最大价值。</p>
<p>但是，Linux 项目持续三十年，长寿的开源项目比比皆是，这种类比显然是有谬误的。原文从公地悲剧两个必要条件来反驳，一是过度使用，二是供应不足。</p>
<p>公地悲剧的一个必要条件是所有人都放牧会使得草地退化，但是开源软件一旦制造出来，不会因为被过度使用而损失价值。反过来，广泛的使用会提升开源软件带来的价值。这一点很好理解。</p>
<p>公地悲剧的另一个必要条件是没有人会修缮草地，因为公地奖励“搭便车”行为，即你修缮了草地别人就可以无偿分享你的成果，而你的付出别人并不承担，结果是付出比不上被分摊后的收益，于是所有人都不付出。</p>
<p>在开源开发中不会遇到这种情况。这是因为参与者不仅需要解决方案，他们还需要问题被及时解决。因此解决这个问题本身带来的收益就足够偿还成本，而等待别人解决问题则完全无法预期它会在何时被解决。</p>
<p>这部分解释了解决方案必然会被生产出来的问题，但是其创造者为何会无偿发布这个补丁，还需要进一步的讨论。</p>
<p>一方面，很多情况下开发者无法为其确定一个公允的市场价格。另一方面，坐等在补丁上不会有任何收益，反而会带来额外的成本，因为你现在要在上游发布新版本时重复合并这个补丁。由于上游对该补丁的存在并不知晓，这种重复合并甚至有可能是多次重做。毫无疑问，这是非常挫败的。由此看来，只要你需要上游的更新，无偿发布补丁就是最优策略。</p>
<p>但是，这里还有一个问题，如果补丁有足够的差异性，补丁作者为什么不将其闭源以获取其销售价值？对于 GPL 许可的项目来说，项目本身的演化需要与其他各方分享，这不是个问题。但是软件结合的形式有很多，GPL 对软件即服务等方式难以产生约束，还有以其他宽容开源协议如 APL 等许可的项目，这些情形正是当下开源与商业的讨论焦点。</p>
<h3 id="软件的使用价值和销售价值"><a href="#软件的使用价值和销售价值" class="headerlink" title="软件的使用价值和销售价值"></a>软件的使用价值和销售价值</h3><p>在讨论这个焦点之前，我们先看看软件的使用价值和销售价值。</p>
<p>软件的使用价值是它作为一个工具的经济价值，软件的销售价值是它作为一个可买卖商品的价值。大部分软件是作为内部系统被生产出来的，原文认为，这个比例达到九成以上。开发者的薪资实际是出于维护软件的使用价值的目的支付的。</p>
<p>如果你创造的软件主要用于内部系统，而你的薪资也来自于维护它的使用价值，那么通过闭源来保护销售价值是没有意义的，因为你不会将它用于销售。这种情况下，通过开源协同来提高软件本身的开发效率和质量，就是有收益的。</p>
<p>值得注意的是，只要软件的开发在隶属于不同组织的参与者之间共享工作流，采用开源协同的开发方式就没有额外的成本，因为公司为了用上这个软件，总是要付出开发成本的。这个共享工作流的前提条件也是《魔法锅》一文成书时未曾想到的，居然还有人为了形式开源而给同一套代码区分出两套工作流。</p>
<p>原文提到两个常见的反论意见。一个是通过闭源代码保护商业机密。这是无稽之谈，主要是代码设计糟糕。通常来说，你应该将机制开源，编写通用的逻辑，而将商业知识相关的策略单独实现。当然，后者并没有什么开源的必要。</p>
<p>另一个是说闭源能够保护软件安全。这也是谬论。除了上面商业机密泄露的场景，对于纯粹的骇客攻击行为，二进制照样能被破解，开放源码只是多了一种破解的手段。</p>
<p>类似近几天的 Log4Shell 漏洞，难道黑客不读代码就找不到这个问题了吗？如果公司内重新实现日志框架，且不说要达到 log4j2 的水平要付出多大成本，以及生态兼容性的种种问题，难道重新实现的软件就没有其他安全问题吗？</p>
<p>即使不说分析源码的破解手段并不比破解二进制的手段轻松多少，可靠的安全性也依赖于算法及其事先经过彻底的同行评审。这么看来，开源软件反而更容易修复安全问题。Log4Shell 通过同行评审发现后通过必要的 private 邮件列表上报，在上游修复后进行披露，正是这种安全同盟的一般做法。</p>
<h3 id="直接收费的问题"><a href="#直接收费的问题" class="headerlink" title="直接收费的问题"></a>直接收费的问题</h3><p>当然，上面这些讨论仍然没有覆盖当前这波开源浪潮下新出现的商业公司群体，这些公司创造开源软件，并希望基于它们创造的开源软件获利。</p>
<p>原文对直接收费类型的许可证做出了批驳，指出希望在源代码可得的前提下添加某种收费或变相收费的条款，会遭到黑客的反感，从而失去开源共同体的支持。这是因为这类许可证违背了三个开源共同体的共识。</p>
<p>第一个与对等性有关。大多数开源开发者并不反对别人利用他们的礼物获利，只是不能要求有任何人站在一个特权地位上牟利。MongoDB 的 SSPL 在理念上或许沿袭了 GPL 的一些理念，只是它对形成派生作品的描述“形成服务”太过笼统，得不到广泛的支持。但是 MongoDB Inc. 自己并没有按照 SSPL 的要求开放它的整个服务栈的源代码，这种对等性的破坏遭到了黑客的唾弃。实际上，MongoDB 的核心代码几乎只由其公司雇佣的员工开发和评审。</p>
<p>第二个与非有意后果有关。原文提到，对商业使用或销售进行限制并收费的许可证有着令人扫兴的效果。特别是这条规定给某些分发行为笼上了一层法律阴影，而这些活动正是黑客非常愿意鼓励的事。还是 SSPL 的例子，由于“形成服务”太过笼统，几乎所有黑客都倾向于不分发该软件以避免潜在的法律风险。原文认为，黑客很少在这一点上让步。实际上，这也是 OSI 拒绝承认 SSPL 是开源许可证的主要原因。</p>
<p>第三个与保持礼物文化相关，这也是最关键的一个原因。如果许可证在法律上就禁止产生分支，那么黑客们绝对不会认同这样的条款。原文解释到，虽然黑客们不赞成分支，但是分支是“最后一招”。如果维护者不能胜任或者背叛开源文化，可以通过分支来保护礼物的传递。Elastic 与 OpenSearch 就是活生生的例子，以 AWS 的工程师为首的开发者在 Elastic 转向更加封闭的时候基于开源版本分支并独立发展，保持新分支的开源属性。</p>
<h3 id="开源的商业未来"><a href="#开源的商业未来" class="headerlink" title="开源的商业未来"></a>开源的商业未来</h3><p>《魔法锅》随后介绍了当时作者所看到的的若干种基于开源软件的商业模式。这里不需要展开，因为它们都统一在同一个模型下。这个模型就是基础架构和中间件开放，应用和服务收费的模型。</p>
<p>开源基础架构，并利用同行评审的价值，协同跨越组织的参与者创造出类别杀手，做到这点的收益实在太大了。类别杀手指的是即好到没人再想使用其他备选的高质量开源原创项目，例如 Linux 和 Kubernetes 等。</p>
<p>Google 愿意开放 Kubernetes 的源代码，很大一部分原因就是为了联合其他商业公司以及整个开源共同体形成事实标准的垄断，而要做到这一点，开源协同的方式是最高效的。Kubernetes 形成垄断后，越是早期参与项目的组织，越是投入资源大的组织，越能够获得某种程度上的原厂品牌效应，并积累足以应付软件在使用上的种种问题的开发者团队。这些组织通过提供应用级别的定制和维护服务收取报酬。</p>
<p>原文认为应用非常倾向于继续封闭，这种封闭尤其可能出现在自成一体的垂直市场当中，其网络效应也较弱。这其实就是针对特定场景开发的插件或者是针对具体业务接入基础架构的实施。时过境迁，如今的软件复杂度已经不是当年一个全栈工程师从购买服务器到整个网站都能负责开发的年代，雇佣业务实施团队将越来越常见。</p>
<p>这些插件某种意义上也可以算作中间件。实际上，应用和中间件之间的差别会随着时代的发展而变化。原文认为数据库是中间件，但是如今却更被认为是某种基础软件。中间件走向闭源还是开源，取决于软件失效的代价，代价越高，走向开放的市场的压力就越大。</p>
<p>举个例子，AWS 的不少服务是闭源的，但是它们的客户端是开源的。这些客户端就是中间件，如果它们的维护更封闭，那么失效的可能性就会越高。广泛的用户会倾向于使用开源的替代品。一个案例是 AWS S3 的 Rust 客户端 rusoto 和官方后来提供开源版本。</p>
<p>Confluent 依靠提供 Apache Kafka 的服务盈利，整个商业模型包括三个部分。</p>
<p>第一部分是实施，也就是帮助客户业务与 Apache Kafka 对接，乃至于设计整个业务消息平台。这是传统上所说的“外包”工作，由于软件复杂度日益升高，这类工作所需的软件开发技能也越来越丰富，相应的雇佣薪资也就水涨船高。这种模式也被称为订阅，在一个订阅周期内，客户能够获得实施工程师的支持，商业公司在提供工单响应的保障。实施包括支持私有化部署，也包括帮助客户对接云服务。</p>
<p>第二部分是提供基于开源软件的云服务，也就是云上的 Apache Kafka 资源，客户按照使用的节点数或访问量交费，这种模式实际上是商业公司通过出租商业地产盈利。一方面，CPU 和内存等资源本身是成本，用户无论如何也要为这些成本付费。另一方面，商业公司在资源之上提供了消息平台的抽象，屏蔽了部署和运维软件的复杂度，并以此来赚取差价。对于无力自行维护的企业来说，购买云服务就是最优选择。</p>
<p>值得一提的是，这种部署的附加值是工程师水平和硬件成本的函数，云厂商往往能够获取更廉价的硬件成本，因此独立服务提供商最好追求部署和运维本身的开销下降，这种运维和部署的策略是商业机密和盈利的基础。另一方面，可以通过维持云中立，避免供应商锁定等优势，利用云厂商之间的竞争激发用户的优先选择意愿。</p>
<p>第三部分是专有软件，例如 ksqlDB 等。只不过 ksqlDB 的位置更像是接近基础架构的中间件，被 Apache Flink 和 Materialize 等项目挤压了不少生存空间。反观 Apache Pulsar 和 Apache RocketMQ 就没有将类似功能做成专有软件以期销售，避免被其他项目分化用户。</p>
<p>对于哪些软件不适合通过闭源获取商业价值，《魔法锅》一文介绍了应该考虑开放源码的软件，时至今日仍然是正确的</p>
<ol>
<li>可靠性、稳定性、可扩展性非常重要。</li>
<li>除了独立的同行评审，没有其他便捷易行的方法验证设计和实现的正确性。</li>
<li>该软件对客户的业务非常关键，因此客户期望避免供应商锁定。</li>
<li>该类软件受网络效应主导，即你无法实现压倒性的市场控制力。</li>
<li>关键方法属于公共知识。</li>
</ol>
<p>开源与闭源在几乎所有层面上都是并存的，并且呈现出一种动态发展的趋势。</p>
<p>起初，Windows 垄断了操作系统的市场。当 Linux 出现以后，服务端操作系统的份额开始逆转，并且出现 RedHat 等商业公司。原文称为中间件的数据库，起初被 Oracle 主宰，如今它也承受着 PostgreSQL 的冲击，海量提供 PostgreSQL 服务的商业公司也能生存下来。今天，云原生技术和软件即服务的概念改变了软件生产和使用的格局，越来越多的商业公司创造开源软件或参与到其开发当中，目的就是推出下一个类别杀手，并取得之后的软件服务战争的优势。</p>
<p>实际上，最好的商业价值获取方式仍然依赖创造性的垄断，这也是知名商业著作<a href="https://book.douban.com/subject/26297606/">《从 0 到 1》</a>的观点。只不过，软件的复杂度以及开源开发应对这种复杂度在生产力上的显著优势，使得你无法在一个很大的范围内实现垄断。但是你仍然可以找到合适的垂直领域，或者就是为客户做实施——这也许是最垂直的一种方式了。</p>
<p>如今，想要创造局部垄断的一种新方式，是通过开源协同的集市模式创造出一个类别杀手，在此过程中获得某种程度上的原厂品牌效应，并积累足以应付软件在使用上的种种问题的开发者团队。进一步的，将原本的市场格局改变，在不改变固有需求的情况下改变产生商业价值的位置。以操作系统为例，原本商业公司以创造出商业操作系统为竞争优势，Linux 出现后，如何基于 Linux 提供更好的服务，或者看到 RedHat 如今的上云策略，提供海量 Linux 服务器资源的运维和应用的部署服务。</p>
<p>改变不利于自己的商业格局，并在环境有利于自己的时候做好下一次颠覆的准备，才是开源时代的商业未来。我也相信这种形式，能够促使企业家真正成为创新的先锋，而不是被长时间垄断所麻痹，不思进取乃至阻止社会生产力的进步。</p>
]]></content>
      <categories>
        <category>大图书馆</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>共同创造价值</title>
    <url>/2022/02/10/value-creation/</url>
    <content><![CDATA[<p>如何吸引开源开发人员参与项目？如何让他们留下来，成为项目共同体的一部分？这是两个做开源运营必须回答的问题。</p>
<p>我对这两个问题的回答，简而言之是和开源参与者共同创造价值，使得开源项目和开源共同体能够回答潜在参与者的两个事关去留的灵魂提问。</p>
<ol>
<li>我能为你做什么？</li>
<li>我应该怎么做到？</li>
</ol>
<p>从共同创造价值的角度出发，通过开源运营回答参与者可以做什么的问题，只有可做的事情是令人兴奋的价值创造，才有可能触发潜在的参与者的兴趣。进一步，只有潜在的参与者能够在文档材料与其他成员的帮助下共同完成价值创造，这样的正向激励才能让参与者留下来，成为项目共同体的一部分。</p>
<span id="more"></span>

<p>本文内容部分整理自我在开源社举办的 COSCon’21 活动上的主题分享<a href="https://www.bilibili.com/video/BV1Tg411K7KS/">《Why Contributors Stay and Grow》</a>的第二部分。</p>
<h2 id="我能为你做什么？"><a href="#我能为你做什么？" class="headerlink" title="我能为你做什么？"></a>我能为你做什么？</h2><p>考虑一个开源开发人员接触项目的典型旅程。他首先要知道这个项目的定位是什么，以决定是否进一步了解它。</p>
<p>如果项目的定位看起来很有趣，或者像是正在解决他希望解决的问题，那么进一步激发他参与贡献的诱因，就是他发现可以为这个项目做点什么。</p>
<p>如果这个项目复杂到无从下手，没有任何引导回答“我能为你做什么”这个问题的入口，那么大部分潜在的参与者都会选择直接放弃理解，也就无法参与。如果这个项目简单到不需要添加什么功能，例如 <a href="https://github.com/antirez/linenoise">LineNoise</a> 和 <a href="https://github.com/pacman82/atoi-rs">atoi-rs</a> 等等，或者稳定到没遇到任何迫切的新需求，例如 ZooKeeper 等等，那么大家已经用得特别开心，也就少有参与贡献的动机了。当然，后者或许是件好事。</p>
<p>我们考虑一个蓬勃发展当中的项目，它足够复杂以不断产生新需求，它又很有活力以致力于把问题解决得足够好。在这样的项目里，潜在的参与者通常能够为项目做什么呢？从这个角度出发，也就能够知道哪些是可能的动机触发点，以拓展共同创造价值的故事。</p>
<h3 id="代码之内的参与"><a href="#代码之内的参与" class="headerlink" title="代码之内的参与"></a>代码之内的参与</h3><p>开源项目最终生产的是开源软件，很容易想到围绕软件代码参与贡献。典型的代码贡献可以分成这四类。</p>
<ul>
<li>评审代码</li>
<li>修复缺陷</li>
<li>改进实现</li>
<li>增加功能</li>
</ul>
<p><strong>首先要讲的是评审代码。</strong></p>
<p>这是一种经常被忽略的参与动机。因为相当部分开源共同体，总是考核并引导参与者自己写代码和提交补丁，只把写代码当成贡献，而将评审代码视作一种不得已而为之的成本，甚至当做是 committer 和 maintainer 的特权。</p>
<p>这当然都是不对的。</p>
<p>实际上，code review 是开源开发人员之间交流技术和建立信任的主要手段。大部分软件的生产过程中，解决问题的办法往往不止一种。每个项目会在众多可能性当中选择自己认可的技术实践，形成自己的调性。通过代码和文档，以及生产代码和文档的过程，这种调性以共识的形式从核心成员同步到每一个参与者的认知当中。这里所说的生产代码和文档的过程，code review 就是其中重要的一环。</p>
<p>对于潜在的参与者来说，参与代码评审并提出问题，门槛较之提交补丁整体要低一些。当然，评审代码并留下意见建议，很多时候要求 reviewer 对软件的理解比补丁作者本身要更高。然而，这里所说的参与代码评审并不局限于针对补丁的实现提出形如补丁的补丁的意见建议，而是强调围绕补丁代码观察和讨论本身。</p>
<p>例如，PostgreSQL 共同体的 <a href="https://commitfest.postgresql.org/">CommitFest</a> 就允许任何参与者以 reviewer 的角色评审待合并的补丁。合并代码的动作自然只能由经验丰富的 committer 来执行，但是任何对这个补丁感兴趣的人，都可以参与评审。你可以针对实现提出问题，可以针对文档提出建议，可以本地测试补丁并回报结果，可以就自己不理解的地方，遵守<a href="http://www.catb.org/~esr/faqs/smart-questions.html">提问的礼仪</a>提出问题。当然，如果某个补丁解决了你的问题，或者实现得非常精彩，不要吝啬感谢、赞扬和鼓励。</p>
<p>TiDB 开发者指南当中有专门的一个章节，告诉潜在的参与者他可以通过<a href="https://pingcap.github.io/tidb-dev-guide/contribute-to-tidb/review-a-pr.html">评审代码</a>的方式为开源共同体做出贡献。其中关于撰写 review comments 的建议值得在这里分享。</p>
<ul>
<li><strong>Be respectful to pull request authors and other reviewers.</strong> Code review is a part of your community activities. You should follow the community requirements.</li>
<li><strong>Asking questions instead of making statements.</strong> The wording of the review comments is very important. To provide review comments that are constructive rather than critical, you can try asking questions rather than making statements.</li>
<li><strong>Offer sincere praise.</strong> Good reviewers focus not only on what is wrong with the code but also on good practices in the code. As a reviewer, you are recommended to offer your encouragement and appreciation to the authors for their good practices in the code. In terms of mentoring, telling the authors what they did is right is even more valuable than telling them what they did is wrong.</li>
<li><strong>Provide additional details and context of your review process.</strong> Instead of simply “approving” the pull request. If your test the pull request, report the result and your test environment details. If you request changes, try to suggest how.</li>
</ul>
<p>另外，代码评审并不局限于补丁合并之前，也不是必须发表评论。</p>
<p>如果一个已合并的补丁激起了你的好奇心，或者你发现了其中存在的问题，完全可以 review after commit 即合并后评审。这对于高速发展的项目来说尤其重要，因为它们往往会在较短的时间窗口内合并补丁，乃至直接向主分支推送代码。代码评审不是形式主义，不像某些极力推行某种流程的人所宣称的必须在合并前收集到两个赞同才能合并，务实的评审和合并策略应该是持续发生、交错进行的。</p>
<p>不是必须发表评论，意思是所有的参与者在提交代码之前，都应该了解他所要参与的这个开源共同体的惯例，也就是常说的“入乡随俗”。这个过程一般也是通过浏览现有补丁来完成的，其实也算是评审代码的一类。我在撰写提交信息和实际提交补丁之前，往往都会先观察共同体当中的其他人是怎么做的，避免不必要的摩擦，提高协同的效率。如果当前流程有明显的缺陷，也是一个潜在的参与点。</p>
<p><strong>修复缺陷、改进实现和增加功能，这三种都是代码贡献。</strong></p>
<p>理想情况下，潜在的参与者具备代码贡献所需的技术背景，在使用软件或阅读代码的过程中，自己发现可能的改进项，仿照现有的 pull request 风格提交补丁。</p>
<p>这种情况也不算少见。常见的案例是参与者掌握了一项新技能，例如一种新的代码风格或设计模式，一种项目管理或持续集成实践，或者一种具有一定普遍性的功能，从而把已经完成的工作，带到其他缺乏这个改进项的项目当中。具体的例子，比如我在看到我的工作里引用的 atoi-rs 项目，没有按照 Rust 项目的惯例配置支持的 Rust 版本，同时功能开发趋于稳定但却没有发布 1.0 版本导致我不是特别敢用，就通过 issue 和 pull request 的方式直接把我掌握的技能复刻到该项目当中。</p>
<ul>
<li><a href="https://github.com/pacman82/atoi-rs/issues/14">Remaining works for 1.0 release</a></li>
<li><a href="https://github.com/pacman82/atoi-rs/pull/17">improve MSRV settings</a></li>
</ul>
<p>上面的例子里有一点值得强调，就是当潜在的参与者不确定能够为开源项目做什么的时候，可以直接询问。当然，这种询问应该是有的放矢的，询问之前应该对项目做基本的了解，而不是居高临下的要求维护者准备好甚至生造出待完成的工作并交给自己。</p>
<p>反过来，从项目维护者的角度出发，回答代码贡献层面潜在的参与者可以做什么的问题，能够采取的方式包括以下几种。</p>
<p>第一种，也是 GitHub 原生支持和倡导的方式，就是为 issue 标注 good first issue 或 help wanted 标签。我在<a href="https://mp.weixin.qq.com/s/OW4AgqsQNBGT2scjGMR-pA">夜天之书 #7</a> 一文里讨论过这两种标签的使用方式。绝大部分 GitHub 的用户的心智模型能够适配这两个标签，并且首先会尝试寻找 good first issue 或 help wanted 标签标注的 issue 作为参与的切入点。</p>
<p>第二种，以 tracking issue 的形式组织起待办事项。通过将零散的 issue 和 pull request 按照主题和模块组织起来，以类似于重构和组织代码的形式管理 issue 和 pull request 来降低潜在参与者的理解成本。</p>
<p>这种做法全面推行，就会在顶层形成一个项目的路线图。例如 <a href="https://flink.apache.org/roadmap.html">Flink 的路线图</a>就把项目的模块分得比较清楚。每个模块现在是稳定状态，快速开发状态，还是原型状态也会标注出来。进一步的，列出每个模块当前正在进行的 Flink Improvement Proposal 和背景，开发人员就可以从这个入口了解相关工作，再从 proposal 关联的 tracking issue 参与到开发工作里面来。当然，这个过程里还有许多可以做代码之外的参与的切入点，这里不做展开。</p>
<p>路线图的更新频率比较慢，日常开发工作里接触得多的是 tracking issue 和对应的改进提案。成熟项目基本都会有一个完整的提案流程，从“我能为项目做什么”的角度出发，这个流程里包含的信息应该可以教会潜在的参与者分辨不同阶段的提案，并且理解当前阶段提案发起人需要得到哪些帮助。另一方面，关于 tracking 的组织，我做过一个视频<a href="https://www.bilibili.com/video/BV1AV411W7WD/">《如何在开源社区做项目管理？》</a>具体讨论的实践手法。</p>
<p>这些手段的最终目的是一致的。因为开发活动过于琐碎，单个开发活动的价值很难吸引潜在的参与者付出时间和注意力自己补全所需的细节。这种情况下，作为项目维护者和开发活动的发起人，应该尽可能地从多个层面以人能理解的方式把这些具体的开发活动归纳总结，以提供不同详略程度的内容呈现。</p>
<p>如同前文提到的，这个过程类似于重构和组织代码。你不能指望开发人员一上来就盯着每一行代码看，这样低效率的理解项目的定位、设计和发展方向。同样，你也不能指望潜在的参与者从大量琐碎的开发活动里归纳出项目共同体正在做什么，接下来要干嘛。只有把开源项目的开发活动模块化和主题化，才有可能把理解和参与的门槛降低到当前时代下潜在参与者所愿意付出的精力的范围之内。</p>
<p>这其实不止是开源项目的问题，而是一个普遍的项目管理的问题。把潜在的参与者换成项目团队的萌新成员，推理过程和结论一样成立。项目维护者采取这样的做法，也不是全然无私奉献，而主要是控制软件工程由于复杂度增加带来的熵。这对于项目本身的健康快速发展也是有利的。</p>
<h3 id="代码之外的参与"><a href="#代码之外的参与" class="headerlink" title="代码之外的参与"></a>代码之外的参与</h3><p>开源共同体虽然是围绕开源软件形成的，但是可能的参与形式远不止于代码贡献。<a href="https://www.apache.org/theapacheway/index.html">The Apache Way</a> 经常被人引用的一点就是“共同体高于代码”。</p>
<blockquote>
<p><strong>Community Over Code:</strong> the maxim “Community Over Code” is frequently reinforced throughout the Apache community, as the ASF asserts that a healthy community is a higher priority than good code. Strong communities can always rectify problems with their code, whereas an unhealthy community will likely struggle to maintain a codebase in a sustainable manner.</p>
</blockquote>
<p>其实，这里的 community 是包括 code 的，两者并非互斥关系，只是强调决策的基点是共同体的利益，而不只是关注代码。不过，我们首先看到开源共同体当中代码之外的参与形式。</p>
<p><strong>第一类是使用。</strong></p>
<p>开发软件的最终目的是投入使用，因此，使用软件并报告反馈，本身就是参与贡献。我见过不少数据库开发人员，并不了解数据分析师和业务开发人员等具体用户到底是怎么使用数据库的，生产环境里最常见的用法，最常被使用的 SQL 特性，沉浸在内核开发当中的工程师未必能够非常准确的把握。通过测试软件在生产环境下的表现，使用真实业务负载验证软件最终交付的价值，对开源软件的打磨价值都是不可忽视的。</p>
<p>TiDB 共同体非常重视用户使用。<a href="https://zhuanlan.zhihu.com/p/272761218">“我们已经用起来了”</a>，是他们最喜欢听到的话。TiDB 的 <a href="https://asktug.com/t/topic/542887">AskTUG</a> 论坛上每天都有海量的问题。这些问题大部分都比较初级，但是初级问题反复出现，意味着开源项目的文档建设和知识库建设不够充分，缺少一个快速上手的文档和常见问题的列表（FAQ）。除去这部分问题，进阶的问题能够描述清楚一个具体的使用场景和遇到的障碍。这类问题往往可以使用某种技巧绕过，这些技巧集合起来，就是使用软件的最佳实践。</p>
<p>前面提过，开发软件的最终目的是投入使用，而软件最终投入生产是一个复杂的过程，任何一个环节无法满足需求，没有绕过方案，都有可能导致用户放弃使用。而任何软件刚刚发布的时候，都是存在这样那样的问题的。通过使用软件并报告反馈，其实就是常说的“踩坑”过程，逐步把软件使用的“坑”给填平，开源软件触达更多用户也就成为可能。为什么 Java 生态比 C# 生态好这么多？为什么 Python 生态比 Elixir 生态好这么多？相当一部分原因就是在漫长的用户使用过程当中，许多未来用户可能遇到的问题，都被先行者给解决了。</p>
<p>对于具备技术能力的开发者来说，使用上游软件并发现问题，还有可能是深入参与的契机。例如我在改进 Apache Flink 的高可用模块的时候，深入理解了 Apache ZooKeeper 和 Apache Curator 的设计实现，并以此为契机为两个项目做出贡献，并成为 Apache Curator PMC 的一员。</p>
<p>另一方面，上面提到的旅程当中，除了使用者以外，还有一个角色就是答疑者。只有少部分提出问题的人，能够自己解决问题。大部分提出问题的人，都需要有另一个经验更丰富的共同体成员协助解决问题。</p>
<p>AskTUG 论坛有版主机制，赋予积极答疑并愿意承担一定协调责任的成员版主的头衔和权限。通过开放合作，AskTUG 论坛聚集起近十位版主，为解答 TiDB 系列产品用户遇到的问题发挥了中流砥柱的作用。可以从<a href="https://asktug.com/t/topic/183426">《TiDB 社区版主，一群平凡又伟大的 TiDBer》</a>一文当中窥见一二。</p>
<p>Apache 基金会治下的项目共同体，往往也强调承担答疑职责的重要性和共同体对这种行为的认可。例如，Apache Flink 项目对 committer 候选人的第一个期待，就是能够积极回答用户问题</p>
<blockquote>
<p>Community contributions include helping to answer user questions on the mailing list, …</p>
</blockquote>
<p><strong>第二类是发布。</strong></p>
<p>发布一个软件并非易事，<a href="https://perlbrew.pl/Perlbrew-%E4%B8%AD%E6%96%87%E7%B0%A1%E4%BB%8B.html">《Perlbrew 中文简介》</a>一文中介绍了 Perl 5.8.8 到 5.10.0 版本之间的发布工作燃尽了两位顶级黑客的精力和热情的故事。</p>
<p>这个故事以发布流程的改进为结局，后来的 Perl 版本发布短到一个月内就可完成。不过，发布这一活动作为开源软件生命周期的重要一环这个事实，却从来没有改变过。PostgreSQL 共同体每次发布都会有一个两到三人组成的临时发布团队，并且整个发布流程都被记录在 Wiki 文档里。我在<a href="https://mp.weixin.qq.com/s/M43TJVxb6CykPI8MiFS55w">夜天之书 #20 The PostgreSQL Community</a> 里有一整段详细讨论。Engula 项目第一份开发者文档，就是<a href="https://github.com/engula/engula/blob/bbbfd9bbaa60bdd7b46adf04c9af658da9e67057/docs/dev/release-guide.md">发布指南</a>。<a href="https://community.apache.org/apache-way/apache-project-maturity-model.html">Apache 项目成熟度模型</a>里，也对发布的质量详细区分了五个等级。</p>
<p>软件的发布是持续交付或叫持续部署的一环，涉及的专业知识不比开发软件核心功能少。一个项目有可靠的持续交付，下游用户才能基于它构建起繁荣的生态。</p>
<p>举个例子，我在分析 TiDB 软件工程上的问题的时候，就提出过发布过程和产物不够清晰，版本支持策略未定义等问题。现在的 TiDB 不像 Apache 项目有明确的文件服务器和稳定获取发布产物的地址，而是依靠工具来完成部署。耦合发布和部署不是一个好选择，尤其是在上一个<a href="https://github.com/pingcap/tidb-ansible">部署工具生命不过三年</a>，<a href="https://github.com/pingcap/tiup">新工具生命不过两年的</a>的情况下。<a href="https://mp.weixin.qq.com/s/DXdDvyo9l3r7Uu3HO5cQ9w">Bytebase 支持 TiDB 的旅程</a>当中，虽然不乏对部署工具的赞许，但也指出了新工具只支持新版本的缺点。由于耦合，部署工具不支持，发布产物也就难以获取。另外，文中也直接明了地提出了版本策略不清晰带给下游的问题。</p>
<p>随着开源吞噬软件，融合不同组件的解决方案在交付时如何进行合规审计和安全审计也是一个日渐复杂的问题，这些问题都归属于发布这一开发活动当中。如果你是一个掌握软件持续交付经验的人才，从这个角度切入参与开源共同体将是非常犀利的，这也是当前不少开源项目求之不得的人才。</p>
<p><strong>第三类是内容。</strong></p>
<p>围绕开源软件开展内容创作，是几何级数乃至指数级数壮大开源共同体的秘诀。内容创作可以大体可以分为四个类型，即文档、博客、演讲和演示。</p>
<p>文档是最贴近开源软件的内容创作。实际上，不少开源软件把用户文档作为版本交付的一部分。<a href="https://docs.pingcap.com/tidb/stable">TiDB 的用户文档</a>经常受到赞扬，<a href="https://www.kubernetes.dev/community/">Kubernetes 的共同体文档</a>也被其他开源共同体用作治理和运营的参考材料。</p>
<p>类似的例子数不胜数。一位经验丰富的技术写作者在交流过程当中曾经提到，好的内容创作能够简明扼要的抓住潜在参与者的注意力，在这个信息爆炸的社会当中为开源共同体赢得劳动时间的投入。</p>
<p>好的用户文档获取用户的注意力，提高软件普及程度，扩大开源共同体生存的基本面。好的开发者文档获取参与者的注意力，减少参与贡献过程当中的摩擦损耗，提高协作效率。好的愿景和价值观，能够聚拢起志同道合的参与者长期为项目发展持续做出贡献。</p>
<p>高质量的文档，必定基于对核心开源软件的理解，对受众的共情，以及文字写作的功底。Apache Pulsar 的 PMC 成员 <a href="https://lists.apache.org/thread/22zl46xlthzk8lmmcdm2r3vhcn4nn5qf">Jennifer Huang</a> 正是出于为 Pulsar 共同体创作技术文档等内容而收获认同的。</p>
<p>博客可以认为是文档的延伸。它是不那么正式的，具备个人风格的内容。同样，许多知名的开源项目，在文档之外都会维护一个博客列表。开源共同体当中也会传阅列表之外的优质博客。例如，我一下子就能想起来 Flink 相关的两篇让我获益匪浅的博客。</p>
<ul>
<li><a href="https://wuchong.me/blog/2020/02/25/demo-building-real-time-application-with-flink-sql/">基于 Flink SQL 构建流式应用</a></li>
<li><a href="http://www.whitewood.me/2020/06/08/Flink-1-11-Unaligned-Checkpoint-%E8%A7%A3%E6%9E%90/">Flink 1.11 Unaligned Checkpoint 解析</a></li>
</ul>
<p>类似的例子也比比皆是，我在撰写 This Week in TiDB 期间也多次引用了共同体成员发布的高质量博客。博客的下一步就是书籍，例如 Eric S. Raymond 为 Linux 共同体做宣传的<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>。很明显，这些内容的传播效率较之软件代码、改进提案和用户文档本身，具有更好的传播效果。这一点还体现在中文社群当中多有对知名开源项目提案的解读上。</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/354979657">JEP 402: 统一基本值与对象</a></li>
<li><a href="https://mp.weixin.qq.com/s/Vr9IQIGvevimeo_A2_I3KQ">2022 年异步 Rust 的改进计划</a></li>
</ul>
<p>演讲的传播效果较之博客又要更进一步，因为它不需要受众阅读并理解文字的含义，而是通过视听体验直接获得感觉。Linus 的经典演讲相当之多，他在这些演讲当中表达的观点为 Linux 项目聚拢起志同道合的核心成员发挥了重要作用。</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=JZ017D_JOPY">Linus Torvalds on his insults: respect should be earned.</a></li>
<li><a href="https://www.youtube.com/watch?v=IVpOyKCNZYw">Linus Torvalds - Nvidia F_ck You!</a></li>
</ul>
<p>Flink Forward 大会，KubeCon 大会，COSCon 中国开源年会，越来越多开源共同体举办的峰会集中输出开源文化和开源软件的价值，以影响整个软件行业对开源软件的认识和使用。作为开源世界的一员，无论是参与演讲还是运营支持，以至于发起峰会，都是对开源共同体壮大的重要贡献。</p>
<ul>
<li><a href="https://www.flink-forward.org/">Flink Forward</a></li>
<li><a href="https://www.youtube.com/watch?v=BbDUZFGJoHw">Panel Discussion: How to Attract Developers to Join Your Community</a></li>
<li><a href="https://space.bilibili.com/525037536/channel/collectiondetail?sid=63363">COSCon’21 第六届中国开源年会</a></li>
</ul>
<p>最后要讲的是演示。演示可以融入到上面提到的三种方式当中。例如，文档可以加入快速开始的演示项目，上面提到的《基于 Flink SQL 构建流式应用》博文本身就是一个示例应用的讲解，演讲当中也经常插入演示环节增强表现效果。</p>
<p>单独谈论演示的原因，自然是因为它非常重要。在信息爆炸、注意力稀缺的今天，短视频以其能够快速抓住眼球，从而大量占用用户时间成为应用新贵。演示起到的就是一个类似的效果。例如，<a href="https://en.wikipedia.org/wiki/Black_Perl">Perl 的代码诗</a>在相当一段时间内吸引了众多开发者的兴趣和尝试。例如，<a href="https://zhuanlan.zhihu.com/p/379477275">TiDB 的热力图活动</a>既强调了 TiDB 重视可观测性的调性，又足够有趣以吸引潜在用户试用。例如，<a href="https://www.bilibili.com/video/BV183411E7Ua">太极图形的太极开物宣传视频</a>就将它在计算机图形学领域的先进性和应用价值生动的传达给每一个观众，相当惊艳。</p>
<p>在软件开发越来越趋于复杂的今天，能够通过演示为开源共同体赢得更多的关注乃至劳动时间的投入，就是为开源共同体做出的重大贡献。</p>
<h3 id="再谈代码贡献"><a href="#再谈代码贡献" class="headerlink" title="再谈代码贡献"></a>再谈代码贡献</h3><p>如同我在《Why Contributors Stay and Grow》演讲里最后要回过来强调的一样，虽然比起代码贡献，代码之外的参与种类繁多，并且能够达到的传播效果远超代码贡献本身，但是开源共同体的价值，始终是建立在优秀的开源软件之上的，而开源软件，说到底还是代码支撑起核心功能，编译产物是交付物的主要内容。</p>
<p>我们在强调 Community Over Code 的时候，需要避免过犹不及。Community Over Code 不应该忽略核心成员的能力和影响力，开源共同体的价值核心，还是依靠这些核心成员尤其是写出最初的代码，一开始规范软件开发流程的人来定义的。用户使用和反馈也好，内容创作也好，前提是有一个好用的软件。虽然上游软件应该适应下游需求来创造，但是最终形成的开源共同体，还是上游定义的软件及围绕开发软件的共同体的价值观推向下游的。</p>
<p>这一点很好理解。创作 GNU 系列项目的人，通过软件及共同体传播自由软件的理念。Linux 选择了 GPLv2 协议，进而影响了整个 Linux 发行版的生态的调性。试图抛开软件，抛开具体的核心成员，定义一套任何人都可以采用的方案建设成功的开源共同体，是不切实际的。这就像是没有一个确保成功的创业法则一样。</p>
<p>只有深入参与到共同体的发展历程当中，通过长时间的投入赢得声誉，建立影响力，并且对软件的定位和共同体的价值取向有相当的理解，对参与共同体发展的核心成员乃至所有成员都有良好的联系，才能够结合具体的情况从共同体层面为现在该干什么，下一步该怎么走做出正确决策。</p>
<h2 id="我应该怎么做到？"><a href="#我应该怎么做到？" class="headerlink" title="我应该怎么做到？"></a>我应该怎么做到？</h2><p>前面讨论“我能为你做什么”的问题的时候，针对每一种可能的参与手段，其实已经或多或少回答了“应该怎么做”这个问题。因此，本段不再对前文已经提过的内容做复述，而是从回答“我应该怎么做到”这个角度出发，给出一个结构化的答案。</p>
<p>我认为，要想解决潜在的参与者提出的“我应该怎么做到”参与贡献的问题，项目维护者应该从这三个方面入手。</p>
<ul>
<li>内容</li>
<li>论坛</li>
<li>聊天室</li>
</ul>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>前文已经花了不少篇幅讨论为开源共同体创造内容是重要的贡献。这种贡献一部分就体现在能够回答“我应该怎么做到”这个问题上。</p>
<p>不同于论坛和聊天室的形式，内容是一种较为单向的信息传递方式，即潜在的参与者单方面的接收内容（主要是文档）传递的信息。因此，内容应该着重考虑受众的体验，解答最为常见，答案最为明确甚至固定的问题。例如，共同体的角色划分和治理体系，共同体认可的价值观，报告缺陷、评审代码、提交补丁等活动的一般性流程等等。</p>
<p>以 TiDB 开发者指南为例，其第二章 Contribute to TiDB 就是我和张翔专门为了回答“我应该怎么做到”撰写的文档，从它的结构就可以看出我们是如何系统性地回答这些问题的。</p>
<ul>
<li>Community Guideline</li>
<li>Report an Issue</li>
<li>Issue Triage</li>
<li>Contribute Code</li>
<li>Cherry-pick a Pull Request</li>
<li>Review a Pull Request</li>
<li>Make a Proposal</li>
<li>Code Style and Quality Guide</li>
<li>Write Document</li>
<li>Committer Guide</li>
<li>Miscellaneous Topics</li>
</ul>
<p>其他成熟的开源共同体也有类似的材料。</p>
<ul>
<li><a href="https://devguide.python.org/">Python Developer’s Guide</a></li>
<li><a href="https://rustc-dev-guide.rust-lang.org/">rustc-dev-guide</a></li>
<li><a href="https://wiki.postgresql.org/wiki/Development_information">Development information</a></li>
<li><a href="https://flink.apache.org/contributing/how-to-contribute.html">Apache Flink: How To Contribute</a></li>
</ul>
<p>更不用说称得上“卷帙浩繁”的 Apache 基金会的文档和 Kubernetes 共同体的文档。</p>
<p>这些文档，加上共同体当中热衷于布道和培养新人的成员在博客和演讲上的内容分享，是潜在参与者了解如何具体参与一次贡献的直接材料。你正在阅读的这篇文章本身，也作为内容有着回答应该怎么参与贡献的作用。</p>
<h3 id="论坛-聊天室"><a href="#论坛-聊天室" class="headerlink" title="论坛 + 聊天室"></a>论坛 + 聊天室</h3><p>上面提到，文档和博客等形式，潜在的参与者作为被动接收方往往只能单向地获取信息。然而，真实世界当中参与开源共同体的活动，往往每个人都会遇到对于自己独一无二的问题。这些问题不够普遍，所以并不能在解决一般性问题的文档上找到答案。为了解决参与贡献旅程上“最后一公里”的问题，我们需要一个对等的沟通工具。</p>
<p>我在<a href="https://mp.weixin.qq.com/s/gOcQpXtUPqr1Ti7Hkyr_RQ">夜天之书 #16 Open Discussion</a> 一文里介绍过 TiDB 共同体解决这个问题的心路历程，这个经验应用到建设 Engula 开源共同体当中，就是 <a href="https://docs.github.com/en/discussions">GitHub Discussions</a> + <a href="https://zulip.com/">Zulip</a> 即论坛 + 聊天室的模式。</p>
<p>其中论坛是唯一信源，也就是说，类似于 Apache 共同体强调的一切都发生在邮件列表上，所有共同体成员只需要关注论坛这一个渠道，就应该能够接收所有必要的信息。同时，在论坛上提出的问题，应该具有最高的响应优先级。</p>
<p>通过定义唯一信源，信息交互才能在当下这个沟通工具琳琅满目的环境下以一种尽可能低消耗的方式进行。否则，每个人都有他喜欢的沟通方式，甚至是非持久化或非公开的方式，例如不录屏的视频会议，或者微信聊天等等。如果在这些地方的讨论也可以作为信源，那么共同体当中发生的事情，将有可能只是一小部分人未经记录的部落共识。这种共同体当中具有排他性的小团体，对信息对等的流通是极其有害的。</p>
<p>回到解决“我应该怎么做到”这个问题上来，信源的分裂也将提高潜在的参与者理解到底应该在哪里解决他“最后一公里”问题的难度。也就是说，解决“最后一公里”问题的路径，本身成为了“最后一公里”问题的一部分。</p>
<p>选择论坛而不是邮件列表，体现了用户喜好的差异。其实对我来说，论坛和邮件列表的价值是一样的，无非是共同体成员更喜欢哪一个用户界面罢了。类似的，聊天室之于论坛，是用户沟通习惯上的差异。IRC 和 Zulip 在我看来也是一样的，无非是共同体成员更喜欢哪一个罢了。只要指定一个，就可以减少工具数量爆炸带来的信息熵。</p>
<p>不过，聊天室作为即时沟通工具，较之论坛或者相对更为正式的邮件，在即时响应问题上有独特的优势。一两句话能解决的问题，即时通信工具更加轻量级。模糊概念的讨论，即时通信工具能够更好地完成实时的头脑风暴。前者的典型例如 <a href="https://gitter.im/akka/akka">Akka 的 Gitter 聊天室</a>，后者的典型例如 <a href="https://rust-lang.zulipchat.com/">Rust 的 Zulip 聊天室</a>。</p>
<p>但是，聊天室核心的问题就在于它的信息密度太低，一旦超过一百人，昨天的消息基本上就已经完全归入历史，要想重提就得从头再来了。虽然现代聊天室大多支持主题化讨论的功能，但是较之论坛的设计理念，还是比较薄弱。因此我在设计沟通工具方案的时候，总是以论坛作为唯一信源。同时在选择聊天室方案的时候，总是选择公开的聊天室，选择支持主题化讨论的聊天室，选择支持引用内容链接的聊天室。支持引用内容链接，就可以在论坛当中直接链接到聊天室的特定讨论串当中，从而打通两边内容的交叉引用。这样避免了大量内容存在于聊天室当中，削弱论坛定位的情况，既能维护论坛唯一信源的定位，又能利用即时通信的优势。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
        <tag>开源治理</tag>
      </tags>
  </entry>
  <entry>
    <title>《开源之迷》书评</title>
    <url>/2022/04/21/the-fascination-of-open-source/</url>
    <content><![CDATA[<p><a href="https://book.douban.com/subject/35716759/">《开源之迷》</a>是<a href="https://opensourceway.community/">“开源之道”</a>主创适兕所著“开源之道三部曲”的第一部。本书的“迷”是着迷的“迷”，旨在向读者介绍什么是开源，以及开源令人欲罢不能的优势。适兕在<a href="https://opensourceway.community/posts/the_way_of_open_source/how-to-make-money-of-open-source-way/">《适兕是如何生存的？》</a>提到，自己从 2015 开始运行“开源之道”，2018 年辞去全职工作，一心发展开源之道。开源之迷，一至于此。</p>
<p>本书发售前，我曾经应邀写了一小段推荐词，不过最后因为出版的原因没有随书印刷。这里附上原文内容，也可以对比只读样章跟读完全书以后体感的差别。</p>
<blockquote>
<p>适兕老师将他多年关注、学习和参与开源世界的理解灌注在开源之道三部曲当中。这本《开源之谜》里，我最期待的内容莫过于“在所有人看见的地方工作”。这一章的名字取自适兕老师推荐的三十多本开源之书其中一本，开源运动之所以冠上这个名字，就有强调源代码及其研发协作活动的公开性的原因。如果你想知道开源协同为什么是软件开发模式的必然方向，开源协同的价值和做法，阅读这本《开源之谜》一定不会错。</p>
</blockquote>
<span id="more"></span>

<h2 id="在所有人看得见的地方工作"><a href="#在所有人看得见的地方工作" class="headerlink" title="在所有人看得见的地方工作"></a>在所有人看得见的地方工作</h2><p>实际拿到本书以后，才发现《在所有人看得见的地方工作》一章非常单薄，前后仅十页的篇幅。除了引用 Linus 对外公开 Linux 项目的邮件以外，就是对想法公开、交流公开且归档以及流程公开几个点做了少数几句议论。姑且不说与同名开源书籍《WORKING IN PUBLIC》相比，例证详实程度和议论深度都难以望其项背，单是读完这十页的内容，留下的印象也不过是做什么都要公开，而对于为什么要这么做，具体可参考的案例和可能遇到的问题，则只字未提。</p>
<p>不过，后一篇《开源世界的日常》花了五十页的篇幅从源码到 DevOps 系统，从沟通渠道到市场营销，讨论了一些典型的用例，还算做了一点补救，但是还是没有讲清楚为什么要这么做，以及可能遇到的问题。</p>
<p>除去补充前一章的部分，《开源世界的日常》一章讨论市场营销的部分质量是不错的。开源社群的运营和发展不仅无需刻意避开市场营销，甚至应该主动思考如何让开源软件在市场形成强大的影响力。</p>
<p>Perl 社群当中的相当部分成员会在 IRC 或邮件列表上讨论新功能和 CPAN 上新的软件库，目标用户是谁，如何高效地推广到目标用户群体当中。Apache 社群在项目<a href="https://tisonkun.org/open-source-guides/apache-maturity-model/">成熟衡量模型</a>当中，明确指出市场营销是参与贡献的一类。</p>
<p>适兕在书中提及了网站、博客和论坛等等渠道，并介绍了运作这些渠道所需的基本知识。我想这跟他多年以来运营“开源之道”项目密不可分。除了线上渠道，适兕在书中还强调了线下活动的价值和典型线下活动的案例。我在分享<a href="https://www.bilibili.com/video/BV1ya411i7qr">《How the ASF builds communities》</a>的时候也专门讨论了 Apache 社群当中的线下活动，就是在赛博朋克化和个人原子化的环境下，强调人与人面对面的连结的重要性。</p>
<h2 id="开源的范畴非常广泛"><a href="#开源的范畴非常广泛" class="headerlink" title="开源的范畴非常广泛"></a>开源的范畴非常广泛</h2><p>从适兕在本章和全书的举例当中，我也发现了一件有趣的事情，那就是开源的范畴是非常广泛的。</p>
<p>《开源之迷》一书中，适兕举例往往选择 Linux Kernel 及其相关的项目，这是因为他开发软件的时间里大部分是在和 Linux 发行版打交道。我自己撰文举例的时候，往往也举的是 Apache 项目尤其是大数据项目的例子，还有参与过的 Perl 社群和 TiDB 社群的例子。</p>
<p>除此以外，开源还有非常多的类别。</p>
<ul>
<li>区块链技术最初的论文是公开的，<a href="https://github.com/ethereum">以太坊</a>是开源软件，<a href="https://github.com/hyperledger">HyperLedger</a> 也是开源软件。</li>
<li>应用监控系统 <a href="https://skywalking.apache.org/">Apache SkyWalking</a> 是开源软件。</li>
<li>角色扮演游戏的开发框架 <a href="https://github.com/EasyRPG">EasyRPG</a> 是开源软件。</li>
<li>Linux 发行版上广泛使用的办公软件 <a href="https://github.com/LibreOffice">LibreOffice</a> 也是开源软件。</li>
<li>绝大多数编程语言要投入实际使用所需的编译器、解释器、运行环境、标准库和实用工具，几乎也都是开源软件。</li>
</ul>
<p>可以说，现代软件开发，基本不可能离开开源软件。</p>
<p>不同项目的风格是不一样的，受到目标人群、技术领域和利益多寡的影响，在一个社群当中合理的规则或惯例，照搬到另一个开源社群当中，可能会面临水土不服的情况。这是我在<a href="https://zhuanlan.zhihu.com/p/397682701">《开源社区的治理模型应当因地制宜》</a>以 TiDB 社群为例讨论过的问题。</p>
<h2 id="开源世界的人物"><a href="#开源世界的人物" class="headerlink" title="开源世界的人物"></a>开源世界的人物</h2><p>要说《开源之迷》当中我最喜欢的章节，非《开源世界的人物》莫属。在这个篇章里，适兕充分发挥了向导的定位，从参与的普罗大众，到计算机科学家、程序员，再到律师、布道师、学者和商人，一口气从自由软件运动到开源运动再到今天，横跨多个领域介绍了与开源有关的关键人物以及他们的贡献。</p>
<p>本书定位就在揭示开源的迷人之处，适兕作为向导带领读者领略开源的魅力。我必须承认在阅读这一章节的时候，好几次我都为开源历史上出现过这样的人，他们做了这样的事而感慨不已。</p>
<p>其中印象最深的是适兕放在最初提及的“不起眼的推动者：大众驱动的开源”。在关注到开源世界的明星之前，在看到一个一个成功的项目之前，首先要强调的是开源软件乃至整个开源生态，能有今天的成就，包含了每一个参与者的努力。开源软件是每一个参与者添砖加瓦堆砌而成的，Linux 的贡献者已经超过了一万人，提交数超过了一百万个，这不只是一两个明星开发者的功劳，而是开源的胜利。</p>
<p>其他人物介绍也很出彩，这里不做展开复述，只讲几个名字。</p>
<p><a href="https://en.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</a> 和他发明的万维网构成了开源的平台基础，其代码本身是公共领域的，即任何人可以随意使用，其协作方式是日后有名的 RFC 模式，时至今日仍然有大量的开源项目采用。</p>
<p>GNU 工程的创始人 <a href="https://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman</a> 和 Linux 的作者 <a href="https://en.wikipedia.org/wiki/Linus_Torvalds">Linus Torvalds</a> 还有<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>的作者 <a href="https://en.wikipedia.org/wiki/Eric_S._Raymond">Eric S. Raymond</a> 自然也在其中。其实，如果你把他们三人的传记或著作放在一起，《若为自由故》、《只是为了好玩》和《大教堂与集市》，就能发现开源的包罗万象。每个人参与开源的理由可能是各不相同的，但却不妨碍他们在一个以分享精神为核心的模糊共识下共同创造价值。</p>
<p>除此之外，还有 FFmpeg 和 QEMU 的作者 <a href="https://en.wikipedia.org/wiki/Fabrice_Bellard">Fabrice Bellard</a> 和著名技术书籍出版商 O’Reilly 的创始人 <a href="https://en.wikipedia.org/wiki/Tim_O%27Reilly">Tim O’Reilly</a> 等等，他们的故事都很有趣。</p>
<p>最后，在写成这篇书评之前，我常引用本书对于“搭便车者”的论述，即如果只是作为消费者使用开源软件，缺乏上游思维，孤僻地认为可以和开源社群隔绝开来，其结果必然是“任由投喂，失去创新能力”。</p>
<p>总的来说，这本书对想要了解“开源”这个话题的读者来说，还是值得一读的。它可以是带领你探索开源世界的方方面面的一本介绍性书籍，适兕也是一名不错的向导。期待“开源之道”三部曲的后续两作发布，如同适兕所计划的一样，讨论清楚如何实践开源，以及为什么要做开源。</p>
]]></content>
      <categories>
        <category>大图书馆</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源布道</tag>
      </tags>
  </entry>
  <entry>
    <title>开源社群的注意力经济</title>
    <url>/2022/05/22/open-source-attention-economy/</url>
    <content><![CDATA[<p><a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>中有一个著名的 Linus 定律，“只要眼睛多，bug 容易捉”。在这本书里面，作者讨论了开源社群的集市开发模式，以其开放的特征，以及提供源码从而支持参与者基于相同的真实的源码进行高效交流，驯服了大型软件开发的复杂性。诚然，在其论述中，基于源码的，快速发布反馈缺陷报告和补丁修补的开源协同方式，能够制造出 Linux 这样的大型开源软件。然而，这一论述却有一个隐含的前提假设，那就是开源软件得到了足够多的关注。</p>
<p>Linux 无疑得到了全世界开发者的海量关注，并且一直如此。开源运动的启蒙阶段，大量的软件都被开创式的制造出来，彼时少有其他开源竞争者的存在，因此眼球或者叫注意力能够投放到的目标是相对有限的。另一方面，开源社群彼时仍是小众圈子，天然地对进入其中的注意力有一个质量筛选的机制，除非货真价实的黑客，否则很难在当时的开源社群当中生存。</p>
<p>然而，如今的开源软件从覆盖面到数量上已经彻底超出了所有人的预期，在软件渗透到社会生活的方方面面的前提下，形成了几乎任何软件都包含开源组件的“软件吞噬世界，开源吞噬软件”的格局。越来越多的开源参与者，已经观察到<a href="https://zhuangbiaowei.github.io/opensource/2022/01/15/Talking-again-about-OSS-Supply-Chain.html">“眼球不够用”</a>的情况了。换句话说，整个开源共同体的注意力供给总量，不足以应对所有开源软件高效发展的需求。</p>
<p>在这样的前提下，开源社群的参与者，应该考虑如何分配自己宝贵的注意力，以促进自身利益与开源社群发展需要的双赢；开源社群的维护者或说开源软件的作者，还需要额外考虑如何吸引开源参与者乃至整个社会可能提供的注意力，从而维系开源软件的高质量，并放大高质量开源软件的影响力。本文将从开源共同体具体的案例出发，讨论这两个问题。</p>
<span id="more"></span>

<h2 id="勿以善小而不为"><a href="#勿以善小而不为" class="headerlink" title="勿以善小而不为"></a>勿以善小而不为</h2><p>讨论如何合理分配参与者的注意力，提高开源协同效率之前，首先要做到的是增加有效的投入到开源社群当中的注意力总量。为此，我经常在宣传开源之道的过程中提到的观点就是“勿以善小而不为”。也就是说，如果你发现了开源社群值得改进的地方，无论是关于软件代码的还是社群建设的，都可以尝试推进落地，而不用因为担心这个改进微不足道，而自我否定了采取行动的理由。</p>
<p>这一点我在<a href="https://www.bilibili.com/video/BV1w54y1Z7VP">《如何向开源项目提交第一个 Pull Request？》</a>视频里也提到过。许多开源新手刚刚接触开源协同，就是从经典的 fix typo 也就是修复拼写错误入手的。从这样一个具体的工作出发，熟悉了开源社群的合作方式，知道如何把自己脑海中的一个改进想法落实到一个具体的补丁，如何与其他社群成员沟通并推进补丁合并到主分支。另一方面，开源软件的迭代与演进，虽然很大程度上是以实现新功能和架构设计作为主路线和里程碑的，但是使得一个软件能够应对严肃复杂的生产环境，稳定、可靠且高效地服务用户需求，占据补丁多数的反而是细微的改进，一个一个缺陷的修复，以及日积月累的代码重构。</p>
<p>我接触的第一个开源社群是 Perl 6 语言社群，<a href="https://github.com/hankache/rakuguide/pull/143">参与 Perl 6 语言社群的第一个 PR</a> 就是有关文档翻译的改进。从这个第三方文档的参与开始，我把 <a href="https://github.com/Raku/doc/commits?author=tisonkun">Perl 6 的官方文档整个梳理和修改了一遍</a>。在此过程中，我了解到语言设计的背景，目前遇到的问题，以此在知乎上写了若干介绍 Perl 6 设计和使用的文章，改进 Perl 6 的<a href="https://github.com/Raku/roast/commits?author=tisonkun">测试套件 Roast</a> 和<a href="https://github.com/Raku/nqp/commits?author=tisonkun">中间语言 NQP</a> 的代码。</p>
<p>可以说，没有当时“勿以善小而不为”的冲动，我就错过了一次乃至以后许多次能够推开开源世界大门的机会。因为这样的理念和由此带来的经验，我在得到一份与 Apache Flink 相关的实习工作以后，就轻车熟路地订阅了项目的开发者邮件列表，并且积极地从代码迁移工作出发了解 Java 软件工程的最佳实践，从修复并发问题的工作出发熟悉分布式系统的常见模式和问题，参与讨论向其他经验丰富的工程师学习，最终能够独立撰写功能提案并落地实现，在一年半以后成为了 Flink Committers 之一。</p>
<p>时至今日，在这样的观点的驱动下，我往往是看到软件有可改进空间，就会尝试参与贡献。如果某个社群碰到了我曾经解决过的问题，或者有解决思路正好缺事实检验的困难，我也会评估自己的精力尽力而为提供帮助。<a href="https://github-readme-stats.vercel.app/api?username=tisonkun">GitHub Stats 的个人资料页</a>上显示我曾经参与过一百多个开源项目，其中许多只是我碰巧看到了或大或小的破窗，顺手为之做出修复。</p>
<p>我相信解决开源社群的注意力投入和分配的问题，不是在总量一定的注意力的基础上，舍弃一些应该投入的工作，人为选择“重要”的工作，而是激发开源参与者持续产生有效的投入到开源社群当中的注意力，提高开源协同的效率，减少不必要的损耗，从而使得每一项应该投入的工作都得到相应的关注。</p>
<h2 id="遵守软件工程实践"><a href="#遵守软件工程实践" class="headerlink" title="遵守软件工程实践"></a>遵守软件工程实践</h2><p>关于不必要的消耗投入到开源社群当中的注意力的话题，前两天我在发布了<a href="https://twitter.com/tison1096/status/1528237424064679936">一条推文</a>讨论。其中典型的就是为了追求数字，违背软件工程最佳实践，选择低效的方式参与开源协同。可以从两个方向来看这类反面教材。</p>
<h3 id="开源参与者的动机"><a href="#开源参与者的动机" class="headerlink" title="开源参与者的动机"></a>开源参与者的动机</h3><p>第一个方向是开源参与者的动机。</p>
<p>去年六月份，Linux Kernel 邮件列表上出现了一封反对刷榜式提交补丁的邮件。</p>
<ul>
<li><a href="https://lkml.org/lkml/2021/6/18/153">Please don’t waste maintainers’ time on your KPI grabbing patches</a></li>
</ul>
<p>这封邮件首先提到删除死代码和修改拼写错误，对于一个软件来说都是有价值的。但是，如果同一个人或者同一个组织的人，在短时间内把同样的平凡的变更拆分成若干个小的补丁提交，以达到增加被合并的补丁的数量的效果，那么这将会过分浪费项目维护者的时间。试想，一个参与者可以在阅读文档的过程中提出修改拼写的补丁，但是他在阅读一篇文档的过程中发现的三个相同或位置上临近的拼写错误，非要拆成三个补丁提交上来，这就确确实实浪费了评审和合并补丁的时间。</p>
<p>尤其是对于并非首次参与的开发者，成熟的开源社群实质上对其有一定的心理预期，上述邮件的作者 Qu Wenruo 也提到</p>
<blockquote>
<p>It’s OK for first-time&#x2F;student developers to submit such patches, and I really hope such patches would make them become a long term contributor. In fact, I started my kernel contribution exactly by doing such “cleanups”.</p>
<p>But what you guys are doing is really KPI grabbing, I have already see several maintainers arguing with you on such “cleanups”, and you’re always defending yourself to try to get those patches merged.</p>
</blockquote>
<p>这并不是说，修复拼写错误和重构代码是新手的专利，实际上，大部分开源项目的核心开发者也经常做着类似的事情。这里的区别就在于你是按照一个符合软件工程实践的心态以合适的节奏和平均质量产出补丁的，还是为了追求数字而刻意反复多次要求项目的维护者立即处理这类平凡的变更。我想对于绝大部分开发者来说，都能够感受到与这两种合作方协同的区别。开源协同应当是一种高效的协同手段，如果开发人员朴素地就能感受到一种行为是违背这一目标的，那么它一定是错的。</p>
<p>当然，对于偶尔看见的平凡变更，我会很乐意顺手合并。如果出现频繁刷榜的人，我的观点与 Qu Wenruo 在后续回复中提到的一致。要么，可以考虑开发一个工具系统的扫描同类问题，例如 <a href="https://github.com/rust-lang/rust-clippy">rust-clippy</a> &#x2F; <a href="https://golangci-lint.run/">golangci-lint</a> &#x2F; <a href="https://github.com/diffplug/spotless">spotless</a> 等就是系统性处理代码中的风格问题和容易导致错误的片段的工具。要么，至少先表明你或你的团队将要做这样的改动，并且明确时间，与项目维护者达成一致后在确定的时间段内集中提出类似的修改，以一种 BugBash 的方式来处理。这也是我在 Apache ZooKeeper 社群推动采用 Checkstyle 来减少补丁之间无谓的空白符变更的方式。</p>
<ul>
<li><a href="https://lists.apache.org/thread/6o6l1yk2t12pfdlrsr1lkpwg06bwwx0m">Clean up the all the checkstyle violations in the zookeeper-server module</a></li>
<li><a href="https://issues.apache.org/jira/browse/ZOOKEEPER-3431">Enable BookKeeper checkstyle configuration</a></li>
</ul>
<p>这种在开源社群当中提前讨论的模式，不只适用于前面提到的平凡变更，对于复杂的补丁，其实更应该提前沟通而不是直接甩一个合并请求。我在两年多前写<a href="https://zhuanlan.zhihu.com/p/93334196">《如何参与 Apache 开源项目社区》</a>的时候就提过这个观点。</p>
<blockquote>
<p>对于大的特性修改，国内开发者特别是一些写多了内部代码想也不想就提交的人，会犯的一个常见的错误是没有修改的背景和抽象设计，直接就 pia 上去一坨代码，英语又差，别人看不懂他也解释不通。其实代码的提交是一个协作的过程，需要达成共识，并不是说甩一脸代码别人就会去看，特别是 Java 之类的很多样板化的修改的代码，diff 贼多信息量贼少。对于任何 non-trivial 的改动，都需要有一定的描述来表明动机；对于大的改动，更需要设计文档来留存记忆。人的记忆不是永久的，总会忘记最初的时候自己为什么做某一件事情，设计文档的沉淀对于社区摆脱人的不确定性演化有至关重要的作用。只有记下来最初是为了做什么事而做出的这个改动，以后移交代码或者教授新人的时候才好援引和解释。</p>
</blockquote>
<p>其实，这也是提高开源协同效率的方式。核心参与者的注意力是有限的，层次化地讨论问题，渐进地融入到开源社群当中，能够逐步取得现有团队的信任，并在其他核心成员的帮助下完成需要更多投入的工作。</p>
<p>对于真的毫无意义的补丁，我会说明情况并拒绝合并。典型地，例如增加 Getter&#x2F;Setter 式的自解释代码的测试，这类测试是冗余的；或者把 do-while 循环改成 while 循环一类的纯风格变更。</p>
<ul>
<li><a href="https://github.com/apache/curator/pull/309">CURATOR-516: Remove Deprecated newSetFromMap</a></li>
<li><a href="https://github.com/apache/curator/pull/377">CURATOR-586: Check if namespace is not null</a></li>
<li><a href="https://github.com/apache/curator/pull/418">(test) Add test for InstanceSpec.<init> and .getQuorumPort</a></li>
</ul>
<p><a href="https://zguide.zeromq.org/docs/chapter6/">《ZeroMQ 权威指南》</a>里提到，如果一个缺陷报告无人理睬，那么就代表着不是个问题，应该即时关闭。Apache SkyWalking 的维护者也表达过类似的观点，如果没人想修复一个问题，那么就说明这不是个问题，至少不是一个紧急或常见的问题。我认为，具体的策略是一回事，清晰地让社群成员及潜在的参与者尽可能了解社群的风格，确实能够有效减少不必要的摩擦和注意力消耗。</p>
<p>关于代码风格，我的观点是每个深入到模块当中的开发者都会逐渐把模块的风格和结构重构成最符合自己认知的模样，从而使得自己能够高效地相应需求做出后续变更。所以，长期参与的开发者，浸淫在某个模块当中的专家，才有权决定一个模块应该以何种风格来写成。这也是我前面在提到参与其他开源社群时，是“评估自己的精力尽力而为提供帮助”隐含的一层意思。如果只是我个人风格偏好不同，或者我有一个想法，但是并不能保证这个想法落地之后遇到衍生问题能不能及时响应，出于基本的负责任的态度，我不会认为项目的维护者理应接受这个看起来合理的提案。</p>
<h3 id="开源维护者的动机"><a href="#开源维护者的动机" class="headerlink" title="开源维护者的动机"></a>开源维护者的动机</h3><p>第二个方向是开源维护者的动机。</p>
<p>开源维护者很大程度上决定了开源社群的发展方向，他们的认识、行动与倾向将影响社群招徕何种注意力，以及注意力将会投入到哪些工作当中。如果开源维护者没有仔细考虑这个问题，或者简单地将开源协同所需的注意力投入等同于广告营销式的注意力收割，那么在实施过程当中就会引起开发者的反感和挑战。</p>
<p><a href="https://github.com/Xuanwo">@Xuanwo</a> 在上个月的一篇文章<a href="https://xuanwo.io/reports/2022-13/">《开源运营当论迹不论心》</a>里以 TDengine 运营的“灭虫活动”为案例说明了这种缺乏考虑的弊端。文章当中提到，希望通过物质激励或者传播技巧招徕更多参与者，这本身无可厚非。但是，违反软件工程的实践，从维护者的角度刻意采用一种更低效的方式“改进”代码，利用人工地毯式搜索的低效特点，制造相同需求需要更多参与者的结果，虽然赢得了短期的喧闹，过后却是一地鸡毛。</p>
<p>这篇文章下面的评论当中 TDengine 的创始人提出了这个活动的动机。</p>
<blockquote>
<p><a href="https://github.com/jtao1735">@jtao1735</a> 作为 TDengine 的创始人，认真读了这篇博客，很认同一个观点，那就是开源运营需要帮助开发者去解决真正的问题，包括 TDengine 的核心技术问题，而不是一些简单的 typo, 对于有一定经验的程序员而言，意义不大。我们当时发起这个活动时，是因为在几个高校巡讲，想吸引在校大学生加入进来，不少学生连 GitHub 账号都没有，因此把门槛大大降低了一下。</p>
</blockquote>
<p>我对这段话也做了回复。</p>
<blockquote>
<p>其实运营本身就有一些 marketing 的属性。“帮助”这个词太笼统了，不如说向社群成员和潜在的社群成员展示和分享 TDengine 是什么，TDengine 要解决什么问题，TDengine 是怎么解决这些问题的。从这三个角度出发，哪些地方是合适的切入点，谁是目标受众，就会清楚很多了。</p>
<p>每个层面的 contribution 都值得感谢，原文和我个人都不认为 fix typo 一类的工作不应该做，而是不用这样大张旗鼓的做。</p>
<blockquote>
<p>想吸引在校大学生加入进来，不少学生连GitHub账号都没有，因此把门槛大大降低了一下。</p>
</blockquote>
<p>这个说法也是不成立的。起码说明你的目的就是吸引在校大学生“进来”，也就是在 contributor graph 上出现，至于进来做什么，无所谓。这就是问题本身，而不能用来回应问题。GitHub 怎么用，首先 GitHub 自己有文档，而 PingCAP 为了解决这个问题，采取的做法是做一个系列视频<a href="https://www.bilibili.com/video/BV1h5411E7pM">【GitHub 新手指南】极简教程教你如何给开源仓库提 PR</a>。</p>
</blockquote>
<p>最后一段也说明我在这一节开头的观点，也就是开源维护者的认识、行动和倾向将影响社群招徕何种注意力。</p>
<p>如果你关注如何将开源软件打造成高水平的软件。那么你所抛出来的问题就有一条明确的主线。例如 Flink 长期讨论如何在 Kubernetes 环境上部署，前后数年均在不断完善这项功能，从将其作为一个单纯的新的虚拟机环境，到利用 Kubernetes 的资源管理能力，再到整合 Operator 应用管理框架，吸引了许多专业人才贡献聪明才智和生产用例。</p>
<p>如果你关注的是如何提高无差别的 star 数或者 contributor 数量，而不是将它们作为主线发展的一个校正自己行为的辅助指标、副产品，那么为了这些数字，会去做一些与软件发展不相干甚至相抵触的事情，也就不奇怪了。</p>
<p>说到底，开源协同是一种上限极高、潜在参与人数极多的软件工程模型，要想在这样开放的环境下协同海量的潜在参与者，并不是一件易事。如果简单地想象成“开源即成功”或者“人越多越成功”，那势必得不到自己想要的结果。至于某些开源维护者把自己都不知道怎么做或者不愿意做的工作，异想天开地“向社群提出一句话需求”，幻想有个盖世英雄能够出面解决，那就是彻头彻尾的巨婴心态了。</p>
<p>《时代周刊》评价 Linus 的时候说，“有些人生来就注定能领导几百万人，有些人生来就注定能写出翻天覆地的软件。但只有 Linus Torvalds 两样都能做到。”这也侧面体现了开源协同所需要的品质之稀缺。同时，这句话也暗含着 Linux 的核心决策尤其是早期的核心决策，虽然已经有众多参与者的贡献，但是 Linus 是决定 Linux 要往何处去的那个人。这就反驳了上文提到的维护者想不清楚，反而希望另一个素未谋面的救星能够机械降神的荒唐。</p>
<p>类似的运营例子其实不少，例如 <a href="https://mp.weixin.qq.com/s/sWC5snMR16OzExX-9eGxNw">Alluxio 开源社区贡献积分奖励计划</a>。其实单从市场声量和招徕用户方面，这些小奖品换注册、点击和转发等等，都是行之有效的 To C 营销手段。对于宣传大使（Ambassador）参与演讲和公开站台，如果采用报销行程和周边反馈，可能比起积分货币会是有效的方式。至于开源平台和技术上的评估，就不太适合用数量来简单衡量。</p>
<p>高质量的开源社群在软件开发上要的是精英社群，不能指望依靠一场活动“转换”一批参与者。这个过程是长期主义细水长流的，搞好流程和文档，找到外向型的社群成员，多多曝光就行。哪怕是搞活动或者专项冲刺，也需要注意和项目发展契合。比如 Apache 项目参与 GSOC 大多是社群切实需要的工作，而不是这样明显由脱离实际开发活动搞出来的标准化 issue 或 pr 数量。追求简单的数量容易引来刷榜的投机者，这些投机者投入钻营得越厉害，例如做出前文《开源参与者的动机》里提到的种种怪事，实际上社群整体的开发效率会受到越严重的影响。</p>
<p>如果真的希望投入资金激励社群开发活动，可以参考 <a href="https://www.perlfoundation.org/grants.html">The Perl Foundation Grants</a> 的做法，建立一个拨款委员会和一套技术评审流程，把赞助者的钱用于激励完成社群期待完成的工作上。实际上，GSoC 的形式可以认为就是 Google 出钱给开源项目用于推动它们重要不紧急的工作的落地。让开发者运行开发者社群，才能更准确地吸引到匹配的参与者，并且利用好这些参与者投入的精力。</p>
<h2 id="找到共同价值"><a href="#找到共同价值" class="headerlink" title="找到共同价值"></a>找到共同价值</h2><p>既然应该让开发者运行开发者社群，那么对于这些承担了运营职责的开发者来说，具体应该怎么找到匹配的参与者并让这些参与者高效地参与呢？我想这里的指导原则是要找到开源社群和潜在参与者的共同价值。</p>
<p>这里需要强调的是，找到共同价值的过程，不仅仅是开源维护者发现潜在参与者的需求，匹配社群当中需要完成的工作，同时也是参与者理解社群的要求，配合其他社群成员共同创造价值的过程。</p>
<p>为什么强调这点呢？我在发布<a href="value-creation.md">《共同创造价值》</a>之后，有回复提到“共同创造价值，而不是欢迎谁给谁贡献代码，不存在谁给谁的事情”。这就是前半段所强调的，先来的社群成员应该平等地追求合作。我在观察多个开源社群具体的运营过程里也发现，存在“既看不起参与者，又要惯着参与者”的情况。这也是指标导向带来的不良后果。因为要追求数字，在执行过程中就弱化了对参与者的筛选，来者不拒；因为来者不拒，大量招徕的参与者水平不足，而又强行要求甚至需要他们完成复杂的工作。这样僵持之下，就变成了酷似考试请枪手，枪手还是无偿代打的局面。甚至于参与者在环境的误导下，认为维护者有义务解决他个人的问题。</p>
<p>这一点在<a href="https://my.oschina.net/u/4489239/blog/5047833">《对话吴晟：真正伤害开源的是开发者本身》</a>一文里也有提及。</p>
<blockquote>
<p>真正伤害开源的，还是开发者本身。最常见的两个问题。一个是开发者，特别是中国的开发者认为，软件作者去帮助他人是天经地义的，因为整个软件是你写的，所以我来问你问题，你就应该有问必答。如果你不答，就认为你这个人摆架子。而不是考虑因为软件作者用了自己的时间提供服务，所以应该表示感谢。</p>
</blockquote>
<p>所以我想要在这里特别强调“共同”这个词所隐含的平等的含义。</p>
<p>在这样的指导原则下，与人协作并不是一件难事。例如，我在成为 <a href="https://github.com/apache/incubator-kvrocks">Apache Kvrocks (Incubating)</a> 项目的导师之后，在构建过程当中发现了 CMake 脚本存在优化空间。我想起来在发布<a href="how-cmake-works.md">《CMake 是怎样工作的》</a>之后，<a href="https://github.com/PragmaTwice">@PragmaTwice</a> 分享了他的一些经验，正好跟我想做的改进相符合。因此，我邀请他把他的经验实践在 Kvrocks 项目上，也欢迎他从 C++ 资深开发者的角度整体评审一下 Kvrocks 的工程质量。</p>
<p>很快，@PragmaTwice 就完成了一系列<a href="https://github.com/apache/incubator-kvrocks/issues/575">构建系统改造</a>的工作，并且提出了若干个可以进行工程改进的思路。社群当中与他合作的维护者能够看出他在 C++ 方面的技术水平，并且交流起来没有障碍。我想如果他能持续参与到社群当中，并且愿意承担更多责任的话，成为项目维护者只是水到渠成。</p>
<p>其实，这才是开源协同本来就应该有的样子。因为自己想做，恰好有一个开源社群也有类似的需求，双方一拍即合按照软件工程的最佳实践推进开发。我想这就是向潜在的开发者宣传开源协同的魅力的时候应该着重提及的内容。因为如果你只盯着公司业务代码，尤其是在校学生都很难接触到实际的需求，对于技术成长有追求，希望看到自己的工作落地会怎么样的开发者来说，提供一个有现成软件基础的、有用户群体的开源软件，是一个很大的诱惑。</p>
<p>另一方面，这种共同价值并不局限于代码参与，甚至不应该局限于单一项目。我进入开源世界的大门是 Perl 6 语言社群，但是不再参与也有两年多了。我在完成 <a href="https://github.com/pingcap/tidb/issues/26022">TiDB 测试迁移的工作</a>的时候，前后协同了不下五十名开发者，其中绝大部分也在一段时间后离开。</p>
<p>但是，在这个过程里，首先我完成了工作工程上本身要达成的目标，提高测试代码编写和运行的方便性，减少不同测试的耦合，从而为软件测试覆盖和能够有自信地常态化重构做准备。此外，我做了一个完整的从提案到实施，从模糊的原则到具体每个场景的最佳实践的案例。此后开发的<a href="https://github.com/tikv/tikv/issues/11452">内存悲观锁</a>等功能开发就可以 follow 这样的案例来进行。这样的软件工程实践能够影响一部分开发者，我已经很开心了。</p>
<p>最后，这些参与者当中有人留了下来，参与到其他开发工作当中；也有人告诉我，他是因为这个契机才开始参与开源社群。我想这跟我从 Perl 6 打开的大门进入到开源世界，最终在其他的开源社群当中发光发热，应该会是类似的。对于参与者来说，他所期待的基本价值之一是个人成长，那么我所维护的开源社群能够在他成长的过程当中跟他一起做出一些贡献，让这个软件更好一些，不也足够了吗？</p>
<p>当然，共同的价值可以是非常多元的。我个人的理想是提升整个软件行业，所以在写作的过程中难免会经常有所偏向。最近看到 Taichi 开源社群有个 <a href="https://github.com/taichi-dev/voxel-challenge">Taichi Voxel Challenge</a> 活动，邀请任何人基于 Taichi 创造自己的三维图形作品。这也算是邀请测试的一种形式。创造出来的作品看着非常有趣，“只是为了有趣”也是一个很好的共同价值。</p>
<img src="/2022/05/22/open-source-attention-economy/taichi-voxel-garden.jpeg" class="" title="Taichi 生成的庭院">

<p>如果开源社群的维护者所追求的“价值”，就是纯粹的数字，以满足自己依托开源软件创办的公司在宣传和融资或其他经营方向上的需要，或许前面提到的种种市场营销手段，就是维护者所追求的价值。这样的维护者与刷榜换取虚假的名声或者直接物质激励的投机者一拍即合，或许也可以找到某种共同价值。</p>
<p>但是，这与我所坚持和相信的“开源社群的目的是制造高质量的开源软件，开源协同是一种高效的软件开发协同手段”背道而驰。</p>
<p>我在写作《如何参与 Apache 开源项目社区》之前，就有许多人问过我“怎么才能成为 Apache Flink 的 Committer 呢”。那篇文章某种意义上是回应这个问题的，但是我并不是功利地说应该怎么去增加贡献量，怎么创造出新功能的需求，而是讨论怎么与其他社群成员协作，在交流和合作开发上有哪些技巧应该掌握。最后落脚点在“兴趣使然”，也就是目的是成为开源社群力量的一部分，齐心协力完成复杂系统的开发和价值交付。在这个过程里收获成长和信任，成为项目的 Committer 或者参与到整个 Apache 社群当中成为基金会正式成员，也就是顺其自然的事情。</p>
<p>同样，如果开发开源软件的最终目的只有商业成功，那么目前看到的可行的终局就是 MongoDB 或者 Elastic 的形式，也就是走向 Source Available 软件的道路，禁止其他参与者商用。实际上，我很推荐这些公司一开始就采用商业保护性质的源码可得软件协议，例如 <a href="https://mariadb.com/bsl11/">Business Source License 1.1</a> 或者加上 <a href="https://commonsclause.com/">Commons Clause</a> 等。如果你想清楚了这一点，你仍然能够通过拆分模块的方式生产开源组件，鼓励生态建设，或者简单地只考虑用户社群，用户当中有开发能力的人，本身对它采用的软件有改进的需求，也没有商业上的冲突，是可能会提交有意义的缺陷报告或者补丁的。但是，这是一种商业上的“免费增值”营销策略，与开源运动的精神就相差甚远了。同时，想清楚这一点，在开源的名义下追求参与者数量或者各类行为活动的数字指标，就是完全的无稽之谈。</p>
<p>开源软件的源代码是可以免费获得的，因此销售源代码必然是不可行的商业模式。开源软件的实施是有附加值的，许多企业服务公司实际上正大规模地使用开源软件组装出自己的解决方案。开源吞噬软件的背景下，供应链上的开源软件的维护是必要成本，因此 RedHat 通过订阅模式能够建立起自己的收入来源，SQLite 的作者为支付酬劳的客户实现功能和提供问题相应支持。开源共同体的生态潜在的价值是无穷无尽的，CockroachLabs 通过提供云上托管数据库服务盈利，为了调优，它需要改进 Golang 运行时的性能，这些改进最好是合并到上游，才能保证在 Golang 后续演进的过程里 CockroachDB 的代码依赖的逻辑自然不被破坏，能够平滑升级。因为这样的原因参与到上游开发建设的参与者，不需要掌握上游的某种垄断权利来盈利。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>运营</tag>
        <tag>注意力</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache 开源社群的经验</title>
    <url>/2022/03/13/the-apache-community/</url>
    <content><![CDATA[<p>大约二十年前我刚开始进入互联网的世界的时候，支撑起整个网络的基础设施，就包括了 Apache 软件基金会（ASF）治下的软件。</p>
<p><a href="https://httpd.apache.org/">Apache Httpd</a> 是开启这个故事的软件，巅峰时期有超过七成的市场占有率，即使是在今天 NGINX 等新技术蓬勃发展的时代，也有三成左右的市场占有率。由 Linux、Apache Httpd、MySQL 和 PHP 组成的 LAMP 技术栈，是开源吞噬软件应用的第一场大型胜利。</p>
<p>我从 2018 年参与 <a href="https://flink.apache.org/">Apache Flink</a> 开始正式直接接触到成立于 1999 年，如今已经有二十年以上历史的 <a href="https://www.apache.org/">Apache 软件基金会</a>，并在一年后的 2019 年成为 Apache Flink 项目 Committer 队伍的一员，2020 年成为 <a href="https://curator.apache.org/">Apache Curator</a> 项目 PMC（项目管理委员会）的一员。今年，经由<a href="https://github.com/WillemJiang">姜宁</a>老师推荐，成为了 <a href="https://www.apache.org/foundation/members.html">Apache Members</a> 之一，也就是 Apache 软件基金会层面的正式成员。</p>
<p>我想系统性地做一个开源案例库已经很久了。无论怎么分类筛选优秀的开源共同体，The Apache Community 都是无法绕开的。然而，拥有三百余个开源软件项目的 Apache 软件基金会，并不是一篇文章就能讲清楚的案例。本文也没有打算写成一篇长文顾及方方面面，而是启发于自己的新角色，回顾过去近五年在 Apache Community 当中的经历和体验，简单讨论 Apache 的理念，以及这些理念是如何落实到基金会组织、项目组织以及每一个参与者的日常生活事务当中的。</p>
<span id="more"></span>

<p>不过，尽管对讨论的对象做了如此大幅度的缩减，由我自己来定义什么是 Apache 的理念未免也太容易有失偏颇。幸运的是，Apache Community 作为优秀的开源共同体，当然做到了我在<a href="value-creation.md">《共同创造价值》</a>一文中提到的回答好“我能为你做什么”以及“我应该怎么做到”的问题。Apache Community 的理念之一就是 Open Communications 即开放式讨论，由此产生的公开材料以及基于公开材料整理的文档汗牛充栋。这既是研究 Apache Community 的珍贵材料，也为还原和讨论一个真实的 Apache Community 提出了不小的挑战。</p>
<p>无论如何，本文将以 Apache 软件基金会在 2020 年发布的纪录片 <a href="https://www.youtube.com/watch?v=JUt2nb0mgwg">Trillions and Trillions Served</a> 为主线，结合其他文档和文字材料来介绍 Apache 的理念。</p>
<h2 id="以人为本"><a href="#以人为本" class="headerlink" title="以人为本"></a>以人为本</h2><p>纪录片一开始就讲起了 Apache Httpd 项目的历史，当初的 Apache Group 是基于一个源代码共享的 Web Server 建立起来的邮件列表上的一群人。软件开发当初的印象如同科学研究，因此交流源码在近似科学共同体的开源共同体当中是非常自然的。</p>
<p>如同 ASF 的联合创始人 Brian Behlendorf 所说，每当有人解决了一个问题或者实现了一个新功能，他出于一种朴素的分享精神，也就是“为什么不把补丁提交回共享的源代码当中呢”的念头，基于开源软件的协作就这样自然发生了。纪录片中有一位提到，她很喜欢 Apache 这个词和 a patchy software 的谐音，共享同一个软件的补丁（patches）就是开源精神最早诞生的形式。</p>
<p>这是 Apache Community 的根基，我们将会看到这种朴素精神经过发展形成了一个怎样的共同体，在共同体的发展过程当中，这样的根基又是如何深刻地影响了 Apache 理念的方方面面。</p>
<p>Apache Group 的工作模式还有一个重要的特征，那就是每个人都是基于自己的需求修复缺陷或是新增功能，在邮件列表上交流和提交补丁的个人，仅仅只是代表他个人，而没有一个“背后的组织”或者“背后的公司”。因此，ASF 的 <a href="https://www.apache.org/foundation/how-it-works.html">How it Works</a> 文档中一直强调，在基金会当中的个体，都只是个体（individuals），或者称之为志愿者（volunteers）。</p>
<p>我在某公司的分享当中提到过，商业产品可以基于开源软件打造，但是当公司的雇员出现在社群当中的时候，他应该保持自己志愿者的身份。这就像是开源软件可以被用于生产环境或者严肃场景，例如航空器的发射和运行离不开 Linux 操作系统，但是开源软件本身是具有免责条款的。商业公司或专业团队提供服务保障，而开源软件本身是 AS IS 的。同样，社群成员本人可以有商业公司雇员的身份，但是他在社群当中，就是一个志愿者。</p>
<p>毫无疑问，这种论调当即受到了质疑，因为通常的认知里，我就是拿了公司的钱，就是因为在给这家公司打工，才会去关注这个项目，你非要说我是一个志愿者，我还就真不是一个志愿者，你怎么说？</p>
<p>其实这个问题，同样在 How it Works 文档中已经有了解答。</p>
<blockquote>
<p>All participants in ASF projects are volunteers and nobody (not even members or officers) is paid directly by the foundation to do their job. There are many examples of committers who are paid to work on projects, but never by the foundation itself. Rather, companies or institutions that use the software and want to enhance it or maintain it provide the salary.</p>
</blockquote>
<p>我当时基于这样的认识，给到质疑的回答是，如果你不想背负起因为你是员工，因此必须响应社群成员的 issue 或 PR 等信息，那么你可以试着把自己摆在一个 volunteer 的角度来观察和参与社群。实际上，你并没有这样的义务，即使公司要求你必须回答，那也是公司的规定，而不是社群的要求。如果你保持着这样的认识和心态，那么社群于你而言，才有可能是一个跨越职业生涯不同阶段的归属地，而不是工作的附庸。</p>
<p>社群从来不会从你这里索取什么，因为你的参与本身也是自愿的。其他社群成员会感谢你的参与，并且如果相处得好，这会是一个可爱的去处。社群不是你的敌人，不要因为公司下达了离谱的社群指标而把怒火发泄在社群和社群成员身上。压力来源于公司，作为社群成员的你本来可以不用承受这些。</p>
<p>Apache Community 对个体贡献者组成社群这点有多么重视呢？只看打印出来不过 10 页 A4 纸的 How it Works 文档，volunteer 和 individuals 两个词加起来出现了 19 次。<a href="https://www.apache.org/theapacheway/index.html">The Apache Way</a> 文档中强调的社群特征就包括了 Independence 一条，唯一并列的另一个是经常被引用的 Community over code 原则。甚至，有一个专门的 <a href="https://community.apache.org/projectIndependence.html">Project independence</a> 文档讨论了 ASF 治下的项目如何由个体志愿者开发和维护，又为何因此是中立和非商业性的。</p>
<p><a href="https://www.apache.org/foundation/how-it-works.html#hats">INDIVIDUALS COMPOSE THE ASF</a> 集中体现了 ASF 以人为本的理念。实际上，不止上面提到的 Independence 强调了社群成员个体志愿者的属性，Community over code 这一原则也在强调 ASF 关注围绕开源软件聚集起来的人，包括开发者、用户和其他各种形式的参与者。人是维持社群常青的根本，在后面具体讨论 The Apache Way 的内容的时候还会展开。</p>
<h2 id="上善若水"><a href="#上善若水" class="headerlink" title="上善若水"></a>上善若水</h2><p>众所周知，<a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a> (APL-2.0) 是所谓的<a href="https://en.wikipedia.org/wiki/Permissive_software_license">宽容式软件协议</a>。也就是说，不同于 <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GPL 3.0</a> 这样的 Copyleft 软件协议要求衍生作品需要以相同的条款发布，其中包括开放源代码和自由修改从而使得软件源代码总是可以获取和修改的，Apache License 在协议内容当中仅保留了著作权和商标，并要求保留软件作者的任何声明（NOTICE）。</p>
<p>ASF 在软件协议上的理念是赋予最大程度的使用自由，鼓励用户和开发者参与到共同体当中来，鼓励与上游共同创造价值，共享补丁。“鼓励”而不是“要求”，是 ASF 和自由软件基金会（Free Software Foundation, FSF）最主要的区别。</p>
<p>这一倾向可以追溯到 Apache Group 建立的基础。Apache Httpd 派生自伊利诺伊大学的 NCSA Httpd 项目，由于使用并开发这个 web server 的人以邮件列表为纽带聚集在一起，通过交换补丁来开发同一个项目。在项目的发起人 Robert McCool 等大学生毕业以后，Apache Group 的发起人们接过这个软件的维护和开发工作。当时他们看到的软件协议，就是一个 MIT License 精神下的宽容式软件协议。自然而然地，Apache Group 维护 Apache Httpd 的时候，也就继承了这个协议。</p>
<p>后来，Apache Httpd 打下了 web server 的半壁江山，也验证了这一模式的可靠性。虽然有些路径依赖的嫌疑，但是 ASF 凭借近似“上善若水”的宽容理念，在二十年间成功创造了数以百亿计美元价值的三百多个软件项目。</p>
<p>纪录片中 ASF 的元老 Ted Dunning 提到，在他早期创造的软件当中，他会在宽容式软件协议之上，添加一个商用的例外条款。这就像是著名开源领域律师 Heather Meeker 起草的 <a href="https://commonsclause.com/">The Commons Clause</a> 附加条款。</p>
<blockquote>
<p>Without limiting other conditions in the License, the grant of rights under the License will not include, and the License does not grant to you, the right to Sell the Software.</p>
</blockquote>
<p>附加 The Commons Clause 条款的软件都不是符合 OSD 定义的开源软件，也不再是原来的协议了。NebulaGraph 曾经在附加 The Commons Clause 条款的情况下声称自己是 APL-2.0 协议许可的软件，当时的 ASF 董事吴晟就提 issue (<a href="https://github.com/vesoft-inc/nebula/issues/3247">vesoft-inc&#x2F;nebula#3247</a>) 指出这一问题。NebulaGraph 于是删除了所有 The Commons Clause 的字样，保证无误地以 APL-2.0 协议许可该软件。</p>
<p>Ted Dunning 随后提到，这样的附加条款实际上严重影响了软件的采用。他意识到自己实际上并不想为此打官司，因此加上这样的条款对他而言是毫无意义的。Ted Dunning 于是去掉了附加条款，而这使得使用他的软件的条件能够简单的被理解，从而需要这些软件的用户能够大规模的采用。“水利万物而不争”，反而是不去强迫和约束用户行为的做法，为软件赢得了更多贡献。</p>
<p>我仍然很敬佩采用 GPL 系列协议发布高质量软件的开发者，Linux 和 GCC 这样的软件的成功改变了世人对软件领域的自由的认识。然而，FSF 自己也认识到需要提出修正的 LGPL 来改进应用程序以外的软件的发布和采用，例如基础库。</p>
<p>APL-2.0 的思路与之不同，它允许任何人以任何形式使用、修改和分发软件，因此 ASF 治下的项目，以及 Linux Foundation 治下采用 APL-2.0 的项目，以及更多个人或组织采用 APL-2.0 的项目，共同构成了强大的开源软件生态，涵盖了应用软件，基础库，开发工具和框架等等各个方面。事实证明，“鼓励”而不是“要求”用户秉持 upstream first 的理念，尽可能参与到开源共同体并交换知识和补丁，共同创造价值，是能够制造出高质量的软件，构建出繁荣的社群和生态的。</p>
<h2 id="匠人精神"><a href="#匠人精神" class="headerlink" title="匠人精神"></a>匠人精神</h2><p>Apache Community 关注开发者的需要。</p>
<p>Apache Group 成立 ASF 的原因，是在 Apache Httpd 流行起来以后，商业公司和社会团体开始寻求和这个围绕项目形成的群体交流。然而，缺少一个正式的法律实体让组织之间的往来缺乏保障和流程。因此，如同纪录片当中提到的，ASF 成立的主要原因，是为了支撑 Apache Httpd 项目。只不过当初的创始成员们很难想到的是，ASF 最终支撑了数百个开源项目。</p>
<p>不同于 Linux Foundation 是行业联盟，主要目的是为了促进其成员的共同商业利益，ASF 主要服务于开发者，由此支撑开源项目的开发以及开源共同体的发展。</p>
<p>举例来说，进入 ASF 孵化器的项目都能够在 <a href="https://infra.apache.org/">ASF Infra</a> 的支持下运行自己的 apache.org 域名的网站，将代码托管在 ASF 仓库中上，例如 <a href="https://gitbox.apache.org/repos/asf">Apache GitBox Repositories</a> 和 <a href="https://github.com/apache/">Apache GitHub Organization</a> 等。这些仓库上运行着自由取用的开发基础设施，例如持续集成和持续发布的工具和资源等等。ASF 还维护了自己的邮件列表和文件服务器等一系列资源，以帮助开源项目建立起自己的共同体和发布自己的构件。</p>
<p>反观 Linux Foundation 的主要思路，则是关注围绕项目聚集起来的供应商，以行业联盟的形式举办联合市场活动扩大影响，协调谈判推出行业标准等等。典型地，例如 CNCF 一直致力于定义云上应用开发的标准，容器虚拟化技术的标准。上述 ASF Infra 关注的内容和资源，则大多需要项目开发者自己解决，这些开发者往往主要为一个或若干个供应商工作，他们解决的方式通常也是依赖供应商出力。</p>
<p>当然，上面的对比只是为了说明区别，并无优劣之分，也不相互对立。ASF 的创始成员 Brian Behlendorf 同时是 Linux Foundation 下 Open Source Security Foundation 的经理，以及 Hyperledger 的执行董事。</p>
<p>ASF 关注开发者的需要，体现出 Apache Community 及其成员对开发者的人文关怀。纪录片中谈到 ASF 治下项目的开发体验时，几乎每个人的眼里都有光。他们谈论着匠人精神，称赞知识分享，与人合作，以及打磨技艺的愉快经历。实际上，要想从 Apache 孵化器中成功毕业，相当部分的 mentor 关注的是围绕开源软件形成的共同体，能否支撑开源软件长久的发展和采用，这其中就包括共同体成员是否能够沉下心来做技术，而不是追求花哨的数字指标和人头凑数。</p>
<p>讲几个具体的开发者福利。</p>
<p>每个拥有 @apache.org 邮箱的人，即成为 ASF 治下项目 Committer 或 ASF Member 的成员，JetBrains 会提供免费的全家桶订阅授权码。我从 2019 年成为 Apache Flink 项目的 Committer 以后，已经三年沉浸在 IDEA 和 CLion 的包容下，成为彻底使用 IDE 主力开发的程序员了。</p>
<p>Apache GitHub Organization 下的 GitHub Actions 资源是企业级支持，这部分开销也是由 ASF 作为非营利组织募资和运营得到的资金支付的。基本上，如果你的项目成为 Apache 孵化器项目或顶级项目，那么和 GitHub Actions 集成的 CI 体验是非常顺畅的。Apache SkyWalking 只算主仓库就基于 GitHub Actions 运行了十多个端到端测试作业，Apache Pulsar 也全面基于 GitHub Actions 集成了自己的 CI 作业。</p>
<p>提到匠人精神，一个隐形的开发者福利，其实是 ASF 的成员尤其是孵化器的 mentor 大多是经验非常丰富的开发者。软件开发不只是写代码，Apache Community 成员之间相互帮助，能够帮你跟上全世界最前沿的开发实践。如何提问题，如何做项目管理，如何发布软件，这些平日里在学校在公司很难有机会接触的知识和实践机会，在 Apache Community 当中只要你积极承担责任，都是触手可得的。</p>
<p>当然，如何写代码也是开发当中最常交流的话题。我深入接触 Maven 开始于跟 Flink Community 的 Chesnay Schepler 的交流。我对 Java 开发的理解，分布式系统开发的知识，很大程度上也得到了 Apache Flink 和 Apache ZooKeeper 等项目的成员的帮助，尤其是 Till Rohrmann 和 Enrico Olivelli 几位。上面提到的 Ted Dunning 开始攻读博士的时候，我还没出生。但是我在项目当中用到 ZooKeeper 的 multi 功能并提出疑问和改进想法的时候，也跟他有过一系列的讨论。</p>
<p>谈到技艺就会想起人，这也是 ASF 一直坚持以人为本带来的社群风气。</p>
<p>我跟姜宁老师在一年前认识，交流 The Apache Way 期间萌生出相互认同。姜宁老师在 Apache 孵化器当中帮助众多项目理解 The Apache Way 并予以实践，德高望重。在今年的 ASF Members 年会当中，姜宁老师也被推举为 ASF Board 的一员。</p>
<p>我跟吴晟老师在去年认识。他经常会强调开发者尤其是没有强烈公司背景的开发者的视角，多次提到这些开发者是整个开源生态的重要组成部分。他作为 PMC Chair 的 Apache SkyWalking 项目相信“没有下一个版本的计划，只知道会有下一个版本”，这是最佳实践的传播，也是伴随技术的文化理念的传播。SkyWalking 项目出于自己需要，也出于为开源世界添砖加瓦的动机创建的 <a href="https://github.com/apache/skywalking-eyes">SkyWalking Eyes</a> 项目，被广泛用在不止于 ASF 治下项目，而是整个开源世界的轻量级的软件协议审计和 License Header 检查上。</p>
<p>主要贡献在 Apache APISIX 的琚致远同学今年也被推选成为 Apache Members 的一员。他最让我印象深刻的是在 APISIX 社群当中积极<a href="https://lists.apache.org/thread/40spln9t62dz8dlwf0xg174g131t89fq">讨论社群建设的议题</a>，以及作为 APISIX 发布的 GSoC 项目的 mentor 帮助在校学生接触开源，实践开源，锻炼技艺。巧合的是，他跟我年龄相同，于是我痛失 Youngest Apache Member 的噱头，哈哈。</p>
<p>或许，参与 Apache Community 就是这样的一种体验。并不是什么复杂的叙事，只是找到志同道合的人做出好的软件。我希望能够为提升整个软件行业付出自己的努力，希望我（参与）制造的软件创造出更大的价值，这里的人看起来大都也有相似的想法，这很好。仅此而已。</p>
<p>原本还想聊聊 The Apache Way 的具体内容，还有介绍 Apache Incubator 这个保持 Apache Community 理念常青，完成代际传承的重要机制，但是到此为止似乎也很好。Apache Community 的故事和经验很难用一篇文章讲完，这两个话题就留待以后再写吧。</p>
]]></content>
      <categories>
        <category>夜天之书</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>开源社群</tag>
        <tag>开源案例</tag>
      </tags>
  </entry>
</search>
