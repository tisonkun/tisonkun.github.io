<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Engula 开源共同体观察报告</title>
    <url>/2021/12/05/engula-community-observation/</url>
    <content><![CDATA[<p>Contributor 参与开源共同体的过程一定会问两个问题，第一个是我能为你做什么，第二个是我该怎么做到它。本文以观察报告的形式总结了我在参与 <a href="https://engula.io/">Engula</a> 开源共同体期间的体会，以及 Engula 现有的部分切入点，可以作为想要参与的同学的参考。</p>
<p>Engula 的设计目标是一个弹性、自适应、可扩展、平台无关的 serverless 存储引擎。基于 Engula 可以实现高可靠且高性价比的数据处理逻辑，例如数据库。Engula 从今年八月份开始以开源协同的方式发起，所有代码以 Apache 2.0 协议授权，使用 Rust 语言开发。</p>
<span id="more"></span>

<p>“好的软件作品，往往源自开发者的个人需要。”这句话对于 Engula 而言也是成立的。因为看到了云原生时代单机系统演进为集群系统的趋势，深感于云数据库等数据处理逻辑在新时代下重复实现存储引擎的冗余，Engula 将存储系统的基本功能模块化后就云环境做了针对性设计，从而支持后来的开发者在实现云环境的数据处理逻辑时，能够有开箱即用的存储系统功能，例如共识、复制、缓存、压缩等等，以及针对不同功能的不同资源配置。</p>
<p>今年十月份，Engula 发布了<a href="https://engula.io/posts/demo-1">概念验证报告</a>。目前概念验证阶段已经结束，共同体成员正在主分支上以发布第一个原型版本为目标快速迭代。</p>
<h2 id="Engula-开源共同体的沟通"><a href="#Engula-开源共同体的沟通" class="headerlink" title="Engula 开源共同体的沟通"></a>Engula 开源共同体的沟通</h2><p>讨论具体的项目内容之前，我想先介绍一下 Engula 开源共同体的沟通手段。这样，在讲到具体的参与切入点的时候，你也能知道应该以什么方式与其他成员沟通。</p>
<p>目前，Engula 所有正式的讨论和开发都发生在 GitHub 上。<a href="https://github.com/engula/engula">项目代码</a>不用说当然托管在 GitHub 的代码仓库里。工作项以 issue 记录，代码评审基于 pull request 来做。</p>
<p>值得一提的是，Engula 主仓库开启了 GitHub Discussion 功能。这是一个进行开放式讨论或者提问解答的小型论坛，取代了其他开源项目常见的邮件列表或者 Discourse 论坛的功能。类似于 Apache 孵化项目一开始只有一个 dev 邮件列表，目前 Engula 的 Discussion 论坛也只有开放讨论形式的 General 目录和问答形式的 Q&amp;A 目录。虽然 General 目录下的讨论主题很泛化，比如 Journal 或 Cache 等，但是我认为这些并不起到目录的作用。也就是说，如果你有关于 Journal 的问题要问，或者灵感要分享，不是一定要在那个主题下回复，而是完全可以另起一个主题来讨论。实际上，我更倾向于类似邮件列表体验的大量简短且能收敛的讨论，而不是一个大而全什么都聊的主题。后者很容易丧失焦点并且难以输出价值。</p>
<p>另外，作为非正式沟通和即时通讯需要的补充，Engula 共同体创建了 <a href="https://engula.zulipchat.com/">Zulip 聊天室</a>。这跟 Rust 共同体的选型是一样的，并且由于是开源项目，Zulip Cloud 提供了免费的支持保存所有聊天记录的标准服务。需要注意的是，正式的讨论和开发仍然需要记录在 GitHub 上，其他所有渠道的讨论都是辅助性的。关注共同体运营的同学可以看看<a href="https://github.com/engula/engula/discussions/141">有关即时通讯工具选型的讨论</a>，后续我也会针对开源共同体的沟通发布一篇文章。</p>
<h2 id="Engula-v0-2"><a href="#Engula-v0-2" class="headerlink" title="Engula v0.2"></a>Engula v0.2</h2><p>“早发布，常发布，倾听用户的反馈。”这是开源软件开发的最有效方式。对于 Engula 这样新发起的项目来说，发布第一个可用版本，将允许参与者在一个最小可行的基础上持续开发。否则所有设计都不过是思想实验，拿不出可行的软件，参与者的热情也将被消磨殆尽。</p>
<p>由于 Engula 在概念验证阶段使用了 0.1 的版本号，因此目前正在开发的第一个原型是 v0.2 版本。该版本的开发在 <a href="https://github.com/engula/engula/issues/57">RoadMap v0.2</a> 上追踪，预计将于今年十二月底发布。下面具体介绍目前的进展。</p>
<h3 id="存储引擎内核"><a href="#存储引擎内核" class="headerlink" title="存储引擎内核"></a>存储引擎内核</h3><p>v0.2 版本计划包含的主要内容就是存储引擎内核，包括底层的 Journal 和 Storage 抽象，这两者的上层封装 Kernel 抽象，以及存储引擎的用户接口 Engine 抽象。</p>
<p>在过去的一个半月里，共同体成员针对这些抽象做了不少讨论和原型设计。目前，这些实现正在朝着一个可发布的状态迭代，包括基于内存的实现，基于本地文件的实现，以及基于 gRPC 协议的实现。项目的发起人 @huachaohuang 正在总结之前的讨论，沉淀出反应 v0.2 设计的设计文档。相关的主题和工作项如下。</p>
<ul>
<li><a href="https://github.com/engula/engula/issues/57">Roadmap v0.2</a></li>
<li><a href="https://github.com/engula/engula/issues/65">Roadmap v0.2 - Journal</a></li>
<li><a href="https://github.com/engula/engula/discussions/70">Discussion: Journal</a></li>
<li><a href="https://github.com/engula/engula/issues/68">Roadmap v0.2 - Storage</a></li>
<li><a href="https://github.com/engula/engula/issues/145">Roadmap v0.2 - Kernel</a></li>
<li><a href="https://github.com/engula/engula/issues/73">Roadmap v0.2 - Engine</a></li>
<li><a href="https://github.com/engula/engula/discussions/55">Discussion: API</a></li>
<li><a href="https://github.com/engula/engula/pull/132">docs: rewrite the design document</a></li>
</ul>
<p>主题讨论是开放式的，工作项则是相对确定的。欢迎熟悉存储引擎开发的同学参与到讨论中来，review 抽象的设计。对于上面工作项里具体的待实现内容，也欢迎想要参与 Engula 的同学一起开发。</p>
<h3 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h3><p>项目发起之初，我们就开始讨论<a href="https://github.com/engula/engula/discussions/32">如何高效地开发 Engula 项目</a>。对于正在朝着第一个发布版本努力的 Engula 来说，我们并不需要复杂高端的开发流程，而是适合当下需要的简洁有效的手段。</p>
<p>目前有一个<a href="https://github.com/engula/engula/issues/144">关于版本发布的工作项</a>正待解决，我先引用之前的讨论回复了<a href="https://github.com/engula/engula/discussions/32#discussioncomment-1561701">开源项目发布的整体关注点</a>和 <a href="https://github.com/engula/engula/discussions/32#discussioncomment-1561991">v0.2 版本的极简发布策略</a>。如果你有相关的项目发布经验，也欢迎参与到这个工作项当中来，一起发布 v0.2 版本。我想在版本发布之后，会总结一个版本发布手册，也确保任何人都能够从代码仓库开始复现发布产物。</p>
<p>项目开发所需要的持续集成流水线已经基于 GitHub Actions 搭建起来了。对于托管在 GitHub 上的开源项目来说，这是一个非常方便的持续集成实现。有时间我会展开讲讲相关的知识和最佳实践。持续集成的另一面是如何在本地进行验证，我在<a href="https://github.com/engula/engula/issues/150">这个议题</a>下有相关的回复。如果你有高效的开发实践，欢迎加入分享。</p>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>上面提到，Engula v0.2 发布将是一个可用版本。它设计上提供两种使用方式，一种是作为三方库内嵌使用，这类似于 RocksDB 的用法，另一种则是作为服务提供，用户使用客户端与存储服务交互。</p>
<p>对于后一种使用方式，Engula 需要提供命令行工具以简化部署、启停、基础交互等操作。最基础的，需要有一个二进制文件来启动基于 gRPC 协议的 Engula 服务。进一步的，类似 CockroachDB 或 Docker 的命令行工具，优雅的实现支持不同操作一行命令完成。</p>
<p>目前，Engula 使用 <a href="https://github.com/clap-rs/clap">clap-rs</a> 库来封装自己的命令行工具。设计哲学方面则参考自 <a href="https://clig.dev/">Command Line Interface Guidelines</a> 文档。欢迎 CLI 爱好者一起讨论 Engula 的需要，打造一个让人爱不释手的命令行工具。</p>
<h3 id="集群服务部署"><a href="#集群服务部署" class="headerlink" title="集群服务部署"></a>集群服务部署</h3><p>原本的 v0.2 版本计划中，包括实现 Engula 部署到集群环境中的功能。但是基于开发周期的考虑，第一个原型版本只要在本地环境可以使用就应该发布。所以集群服务部署的内容被延迟到下一个开发周期当中实现和交付。v0.2 版本仍然会交付直接在本地环境启动 Engula 服务的能力，但是集群部署或者说与云环境集成的部署能力，将不会包含在 v0.2 版本当中。</p>
<p>关于集群服务部署的话题，前几天有参与者问我有什么相关材料可以学习，我在这里也做一个回答。目前看来，Engula 服务在集群上部署的时候，直接打交道的应该 Kubernetes 或者 YARN 一类的集群管理系统，而不是重新实现一遍 Kubernetes 直接跟物理机或容器打交道。</p>
<p>在此前提下，我能想到的两种实现集群服务部署的方向，一个是实现资源申请和调度的抽象，另一个是在主要支持 Kubernetes 平台部署的前提下，利用 Operator 等平台提供的机制进行部署。我倾向于后者。</p>
<p>前者实际上是为 Engula 服务实现了一套自己的集群管理逻辑，把 Kubernetes 或 YARN 当成资源提供方，申请到资源后转换成自己的资源抽象，并实现调度和部署。这样做的好处是有一层抽象隔开了 Engula 资源管理逻辑和不同的集群环境，实质是一个双层资源调度，能够提供额外的定制空间。缺点是设计实现极其复杂，并且为了用上底层集群环境的功能，实际上做到最后会变成底层集群环境接口的超集。如果做成简单的抽象，则会损失很多底层集群环境本来能够提供的能力。</p>
<p>后者基于 Kubernetes Operator 的能力，把 Engula 服务作为定制资源调度起来。这种设计下，Engula 存储引擎内核对集群服务部署是无感知的，完全由 Operator 来决定最终的 Engula 服务的拓扑结构。资源管理和集群管理都由 Operator 切面来完成，而 Engula 存储引擎内核的各个模块则像运行在多个物理机上一样，通过发现服务相互连接和通信。</p>
<p>关于 Kubernetes Operator 的相关材料，推荐阅读以下内容。</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">Operator pattern</a></li>
<li><a href="https://www.redhat.com/en/topics/containers/what-is-a-kubernetes-operator">What is a Kubernetes operator?</a></li>
<li><a href="https://github.com/cncf/tag-app-delivery/blob/main/operator-wg/whitepaper/Operator-WhitePaper_v1-0.md">CNCF Operator White Paper</a></li>
</ul>
<p>同时，虽然倾向于不实现另外一套集群管理逻辑，但是无论如何集群服务部署要跟集群管理系统打交道，Engula 服务层面也会有应用集群的管理逻辑。推荐阅读以下材料掌握一些基础知识。</p>
<ul>
<li><a href="https://doc.akka.io/docs/akka/current/typed/cluster-concepts.html">Cluster Specification</a></li>
<li><a href="https://kubernetes.io/docs/concepts/architecture/">Cluster Architecture</a></li>
<li><a href="https://blog.cloudera.com/resource-localization-in-yarn-deep-dive/">Resource Localization in YARN: Deep Dive</a></li>
</ul>
<h2 id="Engula-开源共同体的发展"><a href="#Engula-开源共同体的发展" class="headerlink" title="Engula 开源共同体的发展"></a>Engula 开源共同体的发展</h2><p>开源共同体的核心是开源软件，因此它的发展肯定也离不开软件本身的演进。这一点在上面已经讨论了不少。针对围绕软件形成的共同体的运行，我之前做过一个 <a href="https://github.com/tisonkun/engula.github.io/blob/85350e76644a7d28049dfc7cb32e2dad03f84abf/docs/posts/community-project.md">The Engula Community Project</a> 的提案，里面有我对打造一个新的开源共同体的思考，欢迎阅读。</p>
<p>由于这个提案本身不是一种硬性的承诺，其中的提议也需要共同体成员认可和实际执行才有效，所以我不再计划把它发布到 Engula 的网站上，而是针对每一个关键的提议，以 contributor 文档或共识的方式逐个落实到 Engula 开源共同体当中。</p>
<p>我希望 Engula 能够成为发源于本土的优秀开源共同体，不仅作为一个 serverless 存储引擎创造技术价值，也是开源协同模式下健壮成长的标杆。</p>
]]></content>
      <tags>
        <tag>Engula</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>《开放式组织》书评</title>
    <url>/2021/12/05/open-organization/</url>
    <content><![CDATA[<p>本文部分启发自在 <a href="https://alc-beijing.github.io/alc-site/">ALC Beijing</a> 录制播客时讨论的内容，仅引用我个人的观点。播客内容应该近期会在前面链接的网站上发布。</p>
<p><a href="https://book.douban.com/subject/26894636">《开放式组织》</a>这本书单看它本身，讲的是红帽公司的组织管理经验。这是一个将商业价值建立在开源项目之上的公司审视公司内部的组织形式的著作，并且主要关注在红帽这个案例上。这样，不管是在经验的普遍性上，还是在开放式组织这种形式跨越组织，尤其是建立商业公司和开源社区之间的联系这方面的讨论上，都有所欠缺。</p>
<span id="more"></span>

<p>从理论到实践，从企业审视内部到跨越组织边界，连接商业公司和开源社区，这样一个广义上的“开放式组织”阅读主题，我推荐以下几本书共读。</p>
<ul>
<li><a href="https://book.douban.com/subject/27125968/">《企业的人性面》</a></li>
<li><a href="https://book.douban.com/subject/34834429/">《协同》</a></li>
<li><a href="https://book.douban.com/subject/26976995/">《社区运营的艺术》</a></li>
<li><a href="https://book.douban.com/subject/35531548/">《用户共创》</a></li>
</ul>
<p>《企业的人性面》我认为是《开放式组织》背后的理论基础，成书于 1960 年，历久弥新。《协同》是国内学者关注“内破部门墙，外拓企业边界”的研究跨越组织边界合作的当代著作。《社区运营的艺术》和《用户共创》均出自 Ubuntu 社区经理 Jono Bacon 之手，讨论了开源社区这一开放式组织的运行方式与最佳实践。这几本书都是阅读《开放式组织》的有益补充。</p>
<h2 id="为什么要理解开放式组织这种形式？"><a href="#为什么要理解开放式组织这种形式？" class="headerlink" title="为什么要理解开放式组织这种形式？"></a>为什么要理解开放式组织这种形式？</h2><p>这个问题也是计划中的“开源协同”系列文章里会展开讨论的问题，这里做简略的回答。这个问题在《开放式组织》里没有直接讨论，而是作为已知假设。然而，这个问题却是想在国内推行开放式组织这种管理模式首先要回答的问题。</p>
<p>本书涉及这个问题的一句话</p>
<blockquote>
<p>我们发现，开发开源软件的最佳方法同样也非常适用于管理整个公司。</p>
</blockquote>
<p>也就是说，开放式组织就是开发开源软件时协调开发团队或者说开源社区的组织管理手段。我喜欢将开放式组织这种组织管理手段简称为“开源协同”。开源软件在开源协同的生产力加持下，在不同领域攻城略地，击溃了专有软件的统治。如果企业想要基于开源软件打造商业价值，那么它就必须了解开源软件。在这种情况下，传统的控制管理模型会导致企业和开源社区激烈的摩擦。要想获得生产力的提升，企业必须成为开放式组织。</p>
<p>这种摩擦来自于时代发展带来的对于组织管理的颠覆。《协同》当中提到的“强个体的价值崛起”，以及《用户共创》当中提到的“社区成员为社区工作，而不是为商业公司工作”都是这一点的佐证。如今，开源社区有能力依靠其同侪社区当中强大的个体打造高价值的软件，其力量足以支持 Linux 赢下服务端操作系统，支持 Rust 成为富有竞争力的系统级编程语言，支持 PostgreSQL 成为世界前列的数据库软件。开源社区及其成员无需依赖于企业尤其是单一企业的控制而生存。因此，他们可以坚持为社区工作，而不是为商业公司工作。</p>
<p>在这种情况下，如果坚持传统的控制管理模型，试图将社区成员驯化成免费劳动力，必将破坏可能的跨越组织边界的合作的信任基石，回退到商业公司雇佣一批员工实现一个本身即是产品的软件。前文说到，开源软件得益于开源协同的生产力加持，正在不同领域中击溃专有软件的统治。在这一背景下，仍然希望聚集起一批员工写出足以媲美开源软件的专有软件，是不太现实的。绝大部分情况下，你无法聚拢起比拟开源社区的专家团队。<a href="https://book.douban.com/subject/2265341/">《维基经济学》</a>当中提到，“唯一有资质做出新发现的人可能在他的组织范围之外”，这将是越来越常见的情况。</p>
<p>《开放式组织》并没有过多的讲这部分内容，因为红帽已经走过了这个阶段。要想跟 Linux 社区达成最好的协同，乃至形成某种意义上的“原厂”品牌，必须以开放式组织的形式运作。本书更多的是讲在已经要运行一个开放式组织的前提下，如何发挥这一组织形式最大的生产力。其实作者 Jim 已经在第一章中提到过，他一开始也试图以传统的控制管理模型来管理红帽公司，但是开放式组织的力量已经不可阻挡，正如开源社区这一开放式组织的力量也不会以商业公司的意志为转移一样。于是他开始学习、理解并运用开放式组织的形式来释放红帽公司员工的生产力。</p>
<h2 id="如何点燃工作热情？"><a href="#如何点燃工作热情？" class="headerlink" title="如何点燃工作热情？"></a>如何点燃工作热情？</h2><p>开放式组织具体的管理策略和<a href="https://book.douban.com/subject/30356081/">《奈飞文化手册》</a>所介绍的准则多有共通之处，其理论基础则都很可能来自《企业的人性面》当中提到的企业管理的 Y 理论。</p>
<p>点燃工作热情是这类组织要面临的第一个挑战。《奈飞文化手册》写到，“成年人最渴望的奖励，就是成功”。《开放式组织》在本章中也提到</p>
<blockquote>
<p>你需要一个能让大家时刻铭记在心的目标，而不只是停留在追求利润这个层面上，这是吸引顶尖人才的唯一方法。</p>
</blockquote>
<p>如果利用马斯洛的需求层次理论来分析，这是要求激发员工对尊重和自我实现的需要的追求。传统的控制管理模型压抑员工的安全需要乃至生理需要的满足，主要使用金钱和职位来激励员工，但是这种激励不能持续。不仅仅是因为员工得到满足后激励作用就会消失，更因为商业公司无法持续用金钱和职位激励每一位员工。与之相反，开放式组织不会压迫员工的生理需要和安全需要，而是激发新时代高价值的强个体的热忱和渴望，也即点燃工作热情来发掘被压抑而无法释放的生产力。</p>
<p>值得注意的是，本章名为“构建充满热情的工作环境”，对于如何做到上面提到的激发热忱和渴望，书中的论调也是</p>
<blockquote>
<p>对于管理者而言，如今最重要的任务就是建立一个启发思考、培育积极的投入精神，并且推崇无限热情、想象力和主动性的工作环境。</p>
</blockquote>
<p>也就是说，组织管理要做的是构建环境。虽然需要关注个体在环境中的发挥来校正对环境状况的认识，但也不用过分纠结某一个人的热情是否点燃。一个人没有热情，是很难点燃出热情的，根本就不可燃。管理者能做的是破除环境当中压抑了人原本的热情的限制条件，释放原本就存在的工作热情。</p>
<p>这一思路也出现在《企业的人性面》当中，书中对比纠结个体，试图利用一致的模式创造标准化人才的“制造”手段，提出了人才的“栽培”方法。</p>
<blockquote>
<p>个人将成长为他可以成为的样子，只要为他们创造适当的成长环境。</p>
</blockquote>
<p>也就是说，开放式组织基于对个人价值的认可和个人能力的信任，致力于创造出能点燃员工工作热情，积极投入工作的环境。</p>
<h2 id="如何提高员工的参与度？"><a href="#如何提高员工的参与度？" class="headerlink" title="如何提高员工的参与度？"></a>如何提高员工的参与度？</h2><p>首先自己要参与，而不是作为一个局外人去提升其他员工的参与度。《开放式组织》当中写到，“想要得到，就先要付出”，就是对每个希望提高员工参与的成员提出的建议。</p>
<p>《企业的人性面》当中花了一整章的篇幅讨论何为参与以及如何参与。根本是要树立诚信，员工能够真正地参与到事务活动和决策中来，整个旅程没有破坏安全感和信任的坏例子。</p>
<p>假模假样的号召参与，实际并不采纳意见等仍然遵循控制管理模型的做法，并不能够瞒天过海，反而是失掉员工的信任，进而整个提高参与度的努力都会失败。</p>
<h2 id="何为精英领导制？"><a href="#何为精英领导制？" class="headerlink" title="何为精英领导制？"></a>何为精英领导制？</h2><p>本书的第四章、第五章和第六章都聚焦在如何做决策这个议题上，而开放式组织从开源社区当中借鉴到的决策方式，自然是精英领导制。</p>
<p>《开放式组织》很有价值的一点在于对比了精英制度和民主制度，并明确地指出了精英制度不同于民主制度的要点。</p>
<blockquote>
<p>精英制度是指根据提出的最佳方案做决定的方式；才能是选择的唯一标准，而非地位、偏见或特权。在一个公民公司里，最优的行动方案是在公开、充分、信息量足够的辩论之后胜出的方案。精英就是每一个有思想、有知识的人，每一个在真正理解之后得出的好想法都会得到重视。毫无才华的吹牛皮之人不会得到尊重。实施了精英制度之后，参与性民主必然将权利转移至最低一级人群的说法也将不攻自破。</p>
</blockquote>
<p>许多开源社区做得不好的一点，就是太强调平等乃至于变成平均主义。其实社区成员积累社会资本，应该是一个 earn authority 的过程，积极主动的 contribution 获得别人的尊重，而不是凑人头投票决策。</p>
<p>Linus 多次表示自己他只以技术论高低，PostgreSQL 社区和 Apache 社区推选新的 Committer 时是核心成员闭门会决议后公示，都是反对民粹的体现。开源社区的公平是基于 contribution 赢得权威的精英领导制，遵守 earn authority by contribution, not by position 的原则。近年来不少开源社区的维护者不堪民粹道德绑架的压力频频爆出“开源世界的暗面”，就是没有形成健康的精英领导制的认知。</p>
<p><a href="https://www.bilibili.com/video/BV1454y1E7xp">Linus Torvalds: 我不在乎政治正确，我只在乎技术本身</a></p>
<p><a href="https://www.bilibili.com/video/BV19f4y1F7QQ">荣耀还是负担？开源大神们居然这么累</a></p>
<h2 id="开放式组织是不是未来唯一的或者最高级的组织形式？"><a href="#开放式组织是不是未来唯一的或者最高级的组织形式？" class="headerlink" title="开放式组织是不是未来唯一的或者最高级的组织形式？"></a>开放式组织是不是未来唯一的或者最高级的组织形式？</h2><p>最后，我想讨论一下这个问题。因为在我讨论开源项目和开放式组织的话题的时候，经常会有人举单一反例，以开源项目和开放式组织如果不是普适的那么就是错的这种无厘头逻辑，来搅乱讨论的氛围。</p>
<p>对于这个问题的答案，我只能说不是。开放式组织是一种选择。控制管理模型也有适合它的军队或教会等组织，前面已经讨论过需要理解开放式组织的原因。现在仍然有专有软件领跑某个领域，仍然有技术领先的源码可得的专有软件开放 API 或允许带有限制的修改，如果你的商业模式适用于这些形式，大可不必采用开放式组织的形式。</p>
<p>但是，软件复杂度将不断提高，基础软件乃至其部分再也无法仅凭一个人或一个公司的全体员工来编写。开源社区这种跨越组织边界，凝聚不同背景专家共同开发的形式，将会生产出高质量的软件，成为事实标准并击溃专有软件。这样的事情正在持续不断的发生。所以至少这个领域的企业，应当理解和采取开放式组织的形式。这种形式也是当前开源社区唯一成功的组织形式。</p>
<h2 id="红帽公司的管理原则"><a href="#红帽公司的管理原则" class="headerlink" title="红帽公司的管理原则"></a>红帽公司的管理原则</h2><ol>
<li>因为想来，所以加入我们。</li>
<li>贡献是决定性因素，但不是交换条件。</li>
<li>不论由谁提出，只要是最好的想法就能胜出。</li>
<li>我们鼓励并且期待开放、坦诚、充满热情的辩论。</li>
<li>我们欢迎反馈意见，本着“早发行，勤发行”的精神做出改变。</li>
</ol>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>大图书馆</tag>
        <tag>组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>高效参与开源的诀窍</title>
    <url>/2021/12/05/effective-open-source-participant/</url>
    <content><![CDATA[<p>大部分人参与开源社区会面临的一个巨大挑战，那就是缺乏时间。本文试图提供一种方式，帮助想要参与开源社区的同学高效利用有限的时间。</p>
<p>在一个开源社区里，maintainers 需要关注的范围比 contributors 要大得多。本文分别讨论这两类人群适用的参与开源社区的技巧，以减少过程中的摩擦，提高时间的利用率。</p>
<span id="more"></span>

<h2 id="Contributors"><a href="#Contributors" class="headerlink" title="Contributors"></a>Contributors</h2><h3 id="第一步要加入社区"><a href="#第一步要加入社区" class="headerlink" title="第一步要加入社区"></a>第一步要加入社区</h3><p>参与开源社区的第一步就是加入社区。加入社区的方式有很多，可以订阅邮件列表，关注开发活动，参与技术或非技术讨论，等等。很多希望参与开源社区的人迟迟迈不出第一步就是忽略了自己首先要加入社区，跟社区建立起联系。</p>
<p>一个典型的错误做法是完全不顾开源社区是开发开源项目的主体，一头钻进技术细节里，暗搓搓地做一个“大功能”，然后希望社区尽快合并这个补丁，让自己得到荣誉。</p>
<p>Linux Foundation 有一篇博文明确反对了这种做法。</p>
<blockquote><p>Some organizations make the mistake of developing big chunks of code in house and then dumping them into the open source project, which is almost never seen as a positive way to engage with the community. The reality is that open source projects can be complex, and what seems like an obvious change might have far reaching side effects in other parts of the project. Any significant change is likely to require some community discussion before it moves to implementation to make sure that there are no side effects and that the solution is aligned with the broader goals for the project. While you discuss it with the community, it can help to focus on the problem, rather than a specific solution, before you invest too much time in the creation of a body of code.</p>
<footer><strong>Linux Foundation</strong><cite><a href="https://www.linuxfoundation.org/tools/participating-in-open-source-communities/">Participating in Open Source Communities</a></cite></footer></blockquote>

<p>一个现实的例子，前几天有人问我，自己做了一个 Flink StateBackend 的实现，提交给社区是不是就能当 PMC 了。这个问题属实把我整不会了。从来没有在社区当中亮相的人，突然出现并提出自己实现了一个“大功能”，在其他成员眼里跟民科没什么不同。绝大部分情况下，这种实现跟上游社区的开发节奏是脱节的，很难合回去。也就是说，闭门造车的形式自我感动地开发项目，即使花费了时间，大概率还是白忙一场。</p>
<p>刚开始接触 Flink 社区的时候，我就按照项目文档的提示订阅了 users 和 dev 两个邮件列表。实话说，最初的三个月，我基本看不懂他们在说什么。当时的我尽可能地读每一封邮件，从邮件里面引用的链接一个个点进去了解背景，混沌当中建立起对项目的初步印象。直到四个月后第一次提交代码，这个祛魅的过程才算完成。从此以后，我逐渐能够轻松地参与到技术讨论，也掌握了 review 的沟通习惯。</p>
<p>最近，我在跟人介绍 Engula 项目的时候，也是先发<a href="https://github.com/engula/engula/discussions">讨论区</a>和<a href="https://discord.gg/AN6vgVXaHC">聊天室</a>的链接。新成员可以阅读过往的讨论，挂在聊天室里，观察社区讨论问题和推进工作的方式，了解已有的设计实现和结论。参与闲聊或者回复感兴趣的话题，找到自己愿意投入的工作。只有这样，才能进一步深入参与开源社区，而不是接触了好几年，却始终迈不出第一步。</p>
<h3 id="找到感兴趣的问题"><a href="#找到感兴趣的问题" class="headerlink" title="找到感兴趣的问题"></a>找到感兴趣的问题</h3><p>要想利用有限的时间创造更多价值，最好的方法是找到一个感兴趣的问题，然后持续投入进去直到解决。</p>
<p>一个典型的错误做法是强迫自己做着不感兴趣的工作。这种情况下，由于内心是抗拒的，即使投入再多的时间，也几乎不会有产出。</p>
<p>可能有人会不理解，开源社区的 contributor 都是自愿参与，如果不想做某个工作，不是不做就可以了吗。其实不然，社区成员身处其中很容易感受到无形的社交压力。</p>
<p>一种情况是不懂得拒绝。知乎上有个问题，<a href="https://www.zhihu.com/question/475269038/answer/2045981148">如何优雅地拒绝开源项目的 PR 邀请</a>，讲的就是这种情况。我在回答里分享了一个自己拒绝 Flink 社区成员里的 PR 邀请的案例。另一种情况是错误估计难度，即自以为能搞定这个工作，做的过程里发现不对，又不好意思改口说自己搞不定。应对这些情况的方法非常简单，直截了当地说明情况即可，解放自己避免浪费时间。</p>
<p>另外一个难题是自己往往对比较有挑战性的工作感兴趣，但是从一个刚接触项目的 contributor 到能够完成一个复杂任务之间有一道坎。</p>
<p>要跨过这道坎，同样需要积极采取行动，而不要独自纠结。首先可以考虑从简单的工作入手，比如阅读项目文档时发现的拼写错误。一个简单的贡献能带你走完整个 contribution 流程。一回生二回熟，做其他有挑战性的工作也就不会在流程上踩坑。其次可以保持和 maintainers 的交流，以了解现有逻辑的设计背景和演进过程。只有对工作涉及的逻辑有充分的了解，才能写出高质量的代码。高质量的代码也意味着更少的返工和不必要的争论，也就避免了时间的浪费。</p>
<h3 id="建立与其他成员的联系"><a href="#建立与其他成员的联系" class="headerlink" title="建立与其他成员的联系"></a>建立与其他成员的联系</h3><p>随着参与的深入，总有你一个人无法完成的工作。开源协同的价值就在于跨越所属组织的边界合作开发项目。合作的基础是成员之间的信任，也就是良好的关系。</p>
<p>开源社区是围绕开源软件建立起来的。但是并不只有软件本身带来技术价值，人与人的连结带来认同感和归属感，这些也能满足社区成员的需要。此外，相互信任的基础能很大程度提升价值创造的效率，例如减少浪费在同步和对齐上的时间。因此，建立并保持与其他项目成员的关系至关重要。</p>
<p>做到这一点的方式就是充分的沟通。同样，这需要以开放的心态对待平时的交流。不要把所有事情都憋在心里。不要纠结于想清楚所有细节再开始沟通，其他成员一时间内往往没办法追上你所想的所有细节。我的建议是，当你有一个初步的想法，也做了力所能及的调研，就可以整理一下，发布到社区当中征求意见。</p>
<p>我给 Engula 项目做了一个<a href="https://github.com/engula/engula.github.io/pull/15">社区计划</a>。老实说，内容并不成熟，但是我一个人干想也得不出结论，所以在经过几轮自我 Review 以后，就先抛出来征求意见。另一个例子是 Engula 的 maintainer @huachaohuang 想为 contributor 提供开发文档，于是就发起了一个<a href="https://github.com/engula/engula/discussions/84">关于 Dev Guide 的讨论</a>。正好我对这个话题也早有想法，当我看到发出来的讨论以后，发现他也在关注这个话题。于是我花了一个小时把自己的想法写下来，经过讨论以后提 PR 推进主分支。</p>
<p>沟通协作的过程里冲突在所难免。我在好几个项目里都别人讨论甚至争论过很多次技术问题，给别人的行为提过意见，也夸赞过好的做法。开源社区解决冲突的方式比较朴素，一般是有话直说，尽量客观地达成共识，按照流程约定做出决策。不用整那么多弯弯绕浪费时间。</p>
<p>举一个现实的例子，曾经有人跟我抱怨提上去的 PR 被 maintainer 挑战了，问我应该怎么回复。怀疑 maintainer 是不是有偏见，抱怨很难跟 maintainer 沟通，大量的时间精力浪费在纠结这些臆想出来的问题，自然是筋疲力竭，感觉在开源社区里寸步难行。</p>
<h3 id="适合参与开源协同的工作"><a href="#适合参与开源协同的工作" class="headerlink" title="适合参与开源协同的工作"></a>适合参与开源协同的工作</h3><p>最后，关注到相当一部分 contributors 的公司员工的身份。这显然会影响到他们参与社区的动力和能力。</p>
<p>主要的挑战是，如果工作期间不允许参与开源社区，同时工作本身已经消耗了太多的时间精力，那么 contributors 对参与开源社区也只能是有心无力。这其实是很长一段时间里开源社区的参与在国内发展缓慢的原因。大量的开发者都在过度工作，下班只想躺平休息，没有动力再谈什么开源贡献。</p>
<p>不过，随着时间的发展，情况也在发生着变化。越来越多的公司采用更加灵活合理的工作时间，尤其是以研发为核心竞争力的公司。如果你所在的公司仍然要求超负荷工作，燃烧生命赚血汗钱，那么是时候找份新工作了。时代已经变了，就让这些公司被无情的淘汰吧。</p>
<p>另一个方向是考虑在工作期间参与开源社区。如果你确实喜欢某个开源项目，那么最佳策略就是找一份允许你全职投入这个项目的工作。这样的工作岗位如今并不少见。尤其是随着企业级解决方案越来越倾向于采用开源组件，企业对熟悉开源软件的人才的需求只会日益增加。如果找不到全职投入开源项目的工作，与之相关的工作也是备选方案。</p>
<p>不过，即使这份工作允许你全职投入开源项目，也并不意味着你能够参与开源社区。特别是当你的老板认为参与开源社区不能为公司创造价值的时候。面对这个问题，首先你可以问问你的老板，说不定他不这么觉得，那就省事儿了。如果你的老板确实难以理解，那你就得像兜售一个技术方案一样向他宣传参与开源社区的价值了。我在其他的文章里对这一点已经有不少讨论，你可以看看。</p>
<p>普适的时间管理手段这里就不展开介绍了，各种相关书籍和 GTD 方法论都很值得一看。</p>
<h2 id="Maintainers"><a href="#Maintainers" class="headerlink" title="Maintainers"></a>Maintainers</h2><h3 id="发展新成员"><a href="#发展新成员" class="headerlink" title="发展新成员"></a>发展新成员</h3><p>Maintainers 比起 contributors 需要关注的更多的事情。随着开源项目日渐复杂，开源社区逐渐成长，单靠一个人的力量很难处理好所有的事务。这个时候，就需要 maintainer 适时地发展项目维护的队伍。</p>
<p>首先需要理清 maintainer 头衔的定位。实际上，大部分项目的维护是个苦力活，而 maintainers 就是一群承担这些工作的社区成员。Maintainers 可能会拥有合并 PR 的权限，在社区治理中能投票做决策，确定项目发展的方向。但是，这种权限并非特权。在一个健康的社区里，任何社区成员都可以做技术讨论，也可以就社区发展话题提出自己的观点。对于技术观点，客观上更加合理的方案理应被采纳。对于社区发展话题，maintainers 也一定会考虑建设性的提议。</p>
<p>可能有不少人把成为 maintainer 当成参与开源社区的目标，这是很好的。如果你理解了 maintainer 的职责，通过 contribution 积累了足够的信誉，成为 maintainer 为开源社区服务，这个头衔是一个显式的认可。不过，大可不必过分纠结于 maintainer 头衔。这只是对 contribution 认可形式的其中一种，而不是唯一一种。</p>
<p>Maintainers 的职责并不轻松，所以 Python 社区和 Apache 软件基金会下的项目社区都会有一个询问 contributor 是否愿意成为 maintainer 的流程。也存在 contributor 拒绝邀请的情况，因为就像前面提到的，健康的开源社区里，只要提议是合理的，就能凭借其客观的优势胜出。成为 maintainer 并不意味着在方案选择上有特权。</p>
<p>对于 contributor 的感谢，也可以通过宣传渠道发布。比起一个模糊的 maintainer 头衔，作为技术人员，我会更在意这个人实际在开源社区里实际完成的事情。</p>
<p>基于上面的认识，我们引出下一个观点。Maintainers 发展新成员，必须是有选择性的。</p>
<p>这种选择性的主要依据是维护项目的需要，而不是追求数量或者过分在意 diversity 等等。这可以类比到开发软件的目的是提供技术价值，而不是代码行数或者所采用的编程语言的数量。</p>
<p>一个典型的错误案例是出于自己同时是公司员工的身份，被命令将 maintainers 的人数发展到某个数字。这种指标只关注数字而不关注具体的人，而且往往定得脱离实际。公司员工迫于指标压力很容易降低 maintainers 的标准，逮到一个算一个的凑人头，或者为了 diversity 对不同背景的 contributor 采取不同的标准。这样发展出来的 maintainers 不仅不能分担项目维护的职责，还很有可能因为不胜任而产生新的问题。</p>
<p>另一个典型的错误经常出现在个人项目上，当个人项目发展壮大，唯一的 maintainer 想要发展新成员时，很容易陷入到要找一个自己的分身的误区。 也就是说，新的 maintainer 必须和自己一样能够关注到项目的方方面面。这是不对的。没有两个人完全相同。只要一个 contributor 有足够的信誉，并且能在项目或社区的维护的某个方面上承担职责，他就是一个好的 maintainer 人选。</p>
<p>不过，这里讲到的信誉是一个非常主观的概念，提名 maintainer 的倾向每个项目也各有不同。</p>
<ul>
<li>Perl 社区最初由 Larry Wall 独裁。近年来，随着他逐渐淡出核心成员圈子，Perl 社区的治理实际上已经变成由 28 人组成的 core team 负责。</li>
<li>PostgreSQL 社区由 7 人组成的 core team 和 28 位 committers 处理所有工作。</li>
<li>ASF 治下的项目有一套比较固定的<a href="http://www.apache.org/foundation/how-it-works.html#roles">治理模型</a>。具体到每个项目，例如 <a href="https://pulsar.apache.org/en/contributing/#becoming-a-committer">Apache Pulsar</a> 和 <a href="https://flink.apache.org/contributing/how-to-contribute.html">Apache Flink</a> 会有自己具体的要求和倾向。</li>
<li>Spring Project 社区的 committers 都是 Pivotal 公司或 VMWare 公司的员工。但是它显然也是诞生于开源协同的作品。</li>
<li>Linux Kernel 基本上还是由 Linus 独裁。同时，海量的驱动和架构支持有各自的 maintainer 进行维护。参考 <a href="https://www.kernel.org/doc/html/latest/process/maintainers.html">Linux Kernel Maintainers 页面</a>。</li>
<li>Netty 社区没有明确的规则。Trustin Lee 发起项目并独自维护了三年。随后，Norman Maurer 和 Scott Mitchell 等少数几个人持续参与，成为 maintainer 并共同维护 Netty 项目至今。</li>
</ul>
<p>如果让我对 maintainer 提一个基础要求，我会希望他在项目或社区中做出了卓越的贡献，并且当前的 maintainers 团队乐于和他一起工作。</p>
<h3 id="结构化流程"><a href="#结构化流程" class="headerlink" title="结构化流程"></a>结构化流程</h3><p>除了增加项目维护的人员，另一个基本的减少时间浪费的手段就是结构化流程。我们分点介绍其内涵。</p>
<p><strong>第一点是直觉大于文档</strong>。对于托管在 GitHub 上的项目来说，help wanted 和 good first issue 标签是一个众所周知的约定。合理标记 issue 能让 contributor 按照过往的经验快速找到切入点。我在<a href="https://github.com/pingcap/community/issues/516">修订 TiDB 社区的治理方案</a>的时候，也是以跟 GitHub 开箱即用的功能亲和为主要目标之一。如果参与一个开源项目有太多新东西要学，那么 maintainers 就有的是要解释的东西了。大部分人效率最高的路径是完全凭直觉做事，并取得好的结果。所以如无必要，请勿设立复杂的规则。</p>
<p><strong>第二点是文档大于口述</strong>。直觉毕竟只能解决部分问题，对于特殊的或者需要强调的内容，明确记录下来作为文档绝对是个好主意。</p>
<p>不过文档首要的还不是记录流程，而是项目的目标或者叫定位。这是每个对项目感兴趣的人都会问的问题，高水平的 contributor 尤甚。他们不仅仅是想在开源社区里做简单的工作，更想成为一个伟大的或富有价值的项目的缔造者。如果你想为你的项目吸引到高水平的开发者，那么最好是确定一个清晰且令人振奋的目标，并将它展示在最显眼的地方。例如，Apache Flink 的定位是数据流上的有状态计算，其中有状态这点是开源世界里开创性的工作。例如，PostgreSQL 的定位是世界最先进的开源关系型数据库。例如，Elixir 语言的目标是构建可扩展和可维护的应用。</p>
<p>其次是约定俗成的文档，包括 README 和 CONTRIBUTING 等等。其中一般包含项目的简介，开始使用的方法，参与贡献的基本流程，和指向更多文档的链接。大部分 contributor 会尝试寻找和阅读这些文档。如果他们能从其中解决自己的问题，就不需要 maintainer 花时间说明了。至少，在有人提问的时候，直接发一个文档的链接，也能省不少事儿。</p>
<p>另一个值得强调的是 Code of Conduct 即行为准则。提名新的 maintainer 之前最好确保被提名人知悉和理解社区行为准则。行为准则通常是一些涉及平等、尊重和避免冒犯的原则。虽然大多数开源社区很少遇到严重违反行为准则的情况，但是 maintainers 应该对此保持敏感。这类问题一旦处理不当，很容易演变成政治斗争，甚至导致社区分裂或项目停摆。</p>
<p>最后是设计文档。Contributors 要深度参与技术贡献需要了解相关代码的设计背景和演进过程，设计文档就是最好的参考材料。良好的代码质量有助于避免 contributor 阅读源码时受挫，但是项目固有的复杂度还是需要设计文档来辅助解释。如果代码质量和设计文档都缺位，想要深度参与技术贡献的 contributor 就不得不指望 maintainer 花费大量的时间解释和指导了。这点对于 maintainer 自己也是一样的。当你想要做一个新的功能，如果没有好的技术文档，你也得懵圈，也得拉人反复对齐。</p>
<p><strong>第三点是避免私下讨论</strong>。有关项目和社区的讨论，唯一的信源应该是一个公开的渠道。例如，ASF 治下的项目要求所有有效的讨论都应该发生在邮件列表上。例如，大部分托管在 GitHub 上的项目隐含了讨论应该发生在 GitHub 平台上。社区成员可能还会通过其他的沟通渠道辅助交流，例如即时通信软件。但是这些辅助渠道的讨论需要被抄送到唯一信源上才实际生效。这样，contributor 才能在无需了解诸多渠道的前提下有能力获取所有有价值的信息。</p>
<p>这些公开讨论的内容以及表现出来的做事方式，就是社区当中的“活文档”。模仿是人类的天性，如果你希望别人遵循某种做事方式以减少冲突，那么最好以身作则，再带动更多的人跟随。前面讨论 contributor 的参与技巧时候说过，加入社区并首先观察别人是怎么做的，是一种避免浪费时间的好方法。那么与之相对的，maintainer 也要在项目维护和日常交流方面为此提供方便。</p>
<blockquote><p>Open Communications: as a virtual organization, the ASF requires all communications related to code and decision-making to be publicly accessible to ensure asynchronous collaboration, as necessitated by a globally-distributed community.</p><footer><strong>Apache Software Foundation</strong><cite><a href="https://www.apache.org/theapacheway/index.html">BRIEFING: THE APACHE WAY</a></cite></footer></blockquote>

<p><strong>第四点是考虑自动化</strong>。结构化的流程更容易自动化。当你的流程越来越结构化，那么是时候考虑自动化它了。显然，无需 maintainer 亲自动手的自动化流程能够减轻项目维护的压力。</p>
<p>同样，最好的自动化是符合直觉的。GitHub 平台提供了一系列自动化的支持。尤其是 <a href="https://github.com/features/actions">GitHub Actions</a> 发布以后，自动化的灵活性得到了进一步的提升。利用项目代码托管的平台提供的开箱即用的能力做自动化，能够最大程度的避免各种冲突。</p>
<p>自动化还应该建立在现有的成熟流程上，而不应该凭空生造一个流程。好的案例包括提交文档变更后自动部署文档页面，利用 merge bot 提高 pull requests review 和 merge 的效率等等。</p>
<p>其中，后者的采用是有两面性的。许多代码提交极其活跃的开源社区也仍然不需要引入自动化流程。当然，测试基本是自动化的，至少有脚本。不过 review 和 merge 还是可以人工完成的。我比较认同 merge bot 的地方是有些实现了排队合并功能以及 roll up 打包测试功能。这两个功能在保证合入主分支的代码是基于最新的主分支测试过的前提下，减少了需要进行测试的次数和人为协调的负担。但是，有些 merge bot 强制要求 review 和 merge 走非常严格的审批流程，把这个过程变得复杂不堪，这是我非常反对的。所以在引入 merge bot 之前，请确保你清楚地知道它如何改善协作效率，并保留回滚的能力。</p>
<p>另一个典型的错误案例是 stale bot 的自动关闭功能。真的，没人喜欢这个功能。开发者来到社区是为了和人建立联系，共同开发好的软件，而不是为了被机器人支配。应对 issue 或 PR 的积压问题，首先应该尽可能的及时处理。其次，大部分积压的 issue 是无效的内容，例如愿望清单和模糊的想法，这些只需要快速关闭即可。对于低优先级的 bug issue 的积压，既然问题是实际存在的，也不是 wontfix 的情形，凭什么关掉呢？如果当前的 maintainers 积极主动地处理 issue 和 PR 还是处理不过来，那么是时候寻找一个新的 maintainer 了。</p>
<blockquote><p>Users SHALL NOT log feature requests, ideas, suggestions, or any solutions to problems that are not explicitly documented and provable.</p>
<footer><strong>Collective Code Construction Contract</strong><cite><a href="https://rfc.zeromq.org/spec/42/#24-development-process">Development Process</a></cite></footer></blockquote>

<p>流程自动化的标杆案例包括 <a href="https://github.com/kubernetes/test-infra/tree/master/prow">Kubernetes 社区</a>和 <a href="https://github.com/rust-lang/homu">Rust 社区</a>。在学习这两个社区的做法的时候，需要强调的是</p>
<ol>
<li>请关注这两个社区为流程自动化投入了多少人力。</li>
<li>请关注这两个社区是在什么时候引入了何种自动化逻辑。</li>
<li>请关注这两个社区的成员如何利用自动化流程。</li>
<li>请关注这两个社区在流程自动化上的异同。</li>
<li>请关注这两个社区推行流程自动化时的讨论，尤其是争议。</li>
<li>请勿货物崇拜，直接照抄它们的方案。否则你会死得很惨。</li>
</ol>
<p>既然 Rust 社区都不抄 Kubernetes 社区的方案，你为啥贸贸然就要抄？</p>
<h3 id="日常事务"><a href="#日常事务" class="headerlink" title="日常事务"></a>日常事务</h3><p>前面讲的是一些整体的做法，回到每个 maintainer 身上，实际的项目维护工作其实是日常事务。</p>
<p><strong>最常见的问题是开发的风险控制</strong>。开源项目通常会有自己的版本发布周期。有时候你希望下个版本能交付某几个关键功能或改进，而这些工作并不都是由你一个人完成。尤其是，你之所以想交付这些变更，是因为公司的要求，而开发团队包括并非公司员工的成员。这个时候就需要你做好项目的风险控制。</p>
<p>从公司员工的角度，我介绍过开源项目和商业公司独立运营的协同模型。运用这个模型，可以把商业上紧急的需求实现在 fork 仓库上，交付 hotfix 应对紧急情况。稍后，把改动 contribute back 到开源项目当中。这样就可以把商业要求和软件开发的工程要求隔离开来，避免向开源社区倾倒粗糙的补丁。<a href="https://github.com/streamnative/pulsar">Stream Native</a> 就在公司组织下有 Apache Pulsar 的 fork 仓库。我没有仔细研究过他们的具体做法，但是显然他们把一些公司关心的内容都放在 fork 仓库上记录。让上帝的归上帝，凯撒的归凯撒。这是好文明。</p>
<p>如果评估出来更合适的做法是把改动直接做在上游，那么我会建议在需要严格控制风险的情况下，直接由公司员工组成开发团队。当然，这些员工得靠自己的努力在开源社区当中赢得信誉，而不是只根据职位就被允许直接提交代码。如果同样的需求已经有其他团队在做，那么沟通就是必要的。如果信得过这个团队，保持关注并提供帮助即可。否则，可以尝试接管项目开发。Flink 社区的 <a href="https://issues.apache.org/jira/browse/FLINK-16654">FLIP-85</a> 提案是我和 Uber 的工程师分别独立提出的。经过几轮邮件列表上的讨论，最终由阿里的工程师主导实现。我参与了 review 和提供了部分参考实现。</p>
<p>上面讲的是一个好的案例。其实对于一个活跃的开源社区来说，PR 冲突的情况不会太少，种类也很多。</p>
<p>TiDB 社区发生过一起有名的 <a href="https://github.com/pingcap/tipb/pull/208">Xuanwo 事件</a>。完全相同的两个补丁，后提交的反而先被合入，导致先提交的被迫关闭。尤其是这个事件发生在并不繁忙的仓库上，并且两个补丁提交的时间相差一个月。这是一种非常典型的情况，需要 maintainers 保持对项目范围内发生的活动的关注。</p>
<p>Flink 社区有不少经典的乐子。<a href="https://issues.apache.org/jira/browse/FLINK-10052">FLINK-10052</a> 作为我从 2019 年就和 @lamberken 配合修复完成并经过生产环境验证的高严重性问题，在过去的三年里提交的三个补丁都因为缺乏响应最终没有合并。这也导致不少用户被迫手动打补丁。<a href="https://issues.apache.org/jira/browse/FLINK-11937">FLINK-11937</a> 是另一个例子。两家员工提供了不同的方案，其中一方缺少社区话语权，无力单独推进合并，另一方有能力但是无意推进，也不允许其他人推进。同样的案例还有 <a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-44%3A+Support+Local+Aggregation+in+Flink">FLIP-44</a> 和 <a href="https://lists.apache.org/thread/snlsb5z9lcogdo7359dcwr4hn5qpymlo">Queryable State</a> 等等。</p>
<p>Flink 的例子其实证明了商业公司需要通过 fork 仓库的来应对商业需求。另外也可以看到这些讨论的发起人是如何被 stale bot 二次伤害的。</p>
<p>从开源协同的角度，contributor 不是程序，而是真实的人。上面提到的沟通手段，去掉公司员工的背景也同样适用。商业公司要做风险控制，开源社区也是一个组织，也可以做风险控制。只不过，开源社区是一个开放式组织。在这个环境下控制风险的手段不是管控，而是协同。前面讲到的文档和结构化的流程在这里同样可以起作用。信息在 contributor 之间自由流通，就不会有 FUD 产生的伤害。平时保持和其他 contributor 的联系，就能知道当前的工作最应该找谁一起做。</p>
<p>大部分情况下，contributor 是能够自我驱动和自我激励的。他们爆发出的创造力不可小觑。单就时间上的风险而言，如果你在开发文档里明确写下开发周期和发布模型，contributor 是乐于见到自己参与或主导开发的工作随新版本一起发布的。越是自我驱动参与开源社区的 contributor 越重视积累信誉。这个过程中，如果你作为 shepherd 指导或参与进去，只需要切实地关注和解决开发团队成员遇到的困难，并在需要时帮助他们管理好进度。</p>
<p>其他的沟通技巧和 maintainer 的最佳实践这里不再展开。Open Source Guides 提供了这个话题非常有益的补充，推荐延伸阅读。</p>
<ul>
<li><a href="https://opensource.guide/best-practices">Best Practices for Maintainers</a></li>
<li><a href="https://opensource.guide/leadership-and-governance">Leadership and Governance</a></li>
<li><a href="https://opensource.guide/building-community/#growing-your-community">Building Welcoming Communities</a></li>
</ul>
<h2 id="Have-fun"><a href="#Have-fun" class="headerlink" title="Have fun"></a>Have fun</h2><p>不论是 contributor 还是 maintainer 你都已经通过参与开源社区为社会创造出了价值。时不时想想你为什么要参与或维护这个项目，回顾这个项目已经取得的成就。你已经做得很好了。</p>
<p>软件都有自己的生命周期，开源软件也不例外。开源社区的工作也不是你生活的全部。如果你找到了新的乐趣，完全可以把项目交给其他 maintainers 维护，或者直接归档。如果开源项目的维护已经超出你的能力范围或者消耗了太多的时间精力，也可以休息一段时间甚至放弃对项目的维护。作为开源社区成员的你没有义务非得维护这个项目或者响应别人的请求。你把自己的工作自由的提供给其他人利用，已经创造了非常客观的价值。</p>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>企业如何实践开源协同</title>
    <url>/2021/12/05/open-source-collaboration-enterprise-perspective/</url>
    <content><![CDATA[<p>随着开源概念的红火，越来越多的企业将内部项目公开托管到 GitHub 等平台，也有越来越多依托开源项目建立起来的企业。对于这些企业来说，它们的目标不只是开放项目源代码，更希望能够形成开源共同体，打造围绕项目的软件生态。</p>
<p>然而，其中大部分项目由于成员背景的单一性，最终都终结于仅源码可得的形态。对于这些新兴项目来说，初始成员从属于同一企业是既定事实。在这样的前提下，企业应该如何实践开源协同，形成开源共同体呢？</p>
<span id="more"></span>

<h2 id="共享工作流"><a href="#共享工作流" class="headerlink" title="共享工作流"></a>共享工作流</h2><p>从开发者的角度出发，根本问题是要共享工作流。共享工作流，即项目开发的核心流程只有一套，所有 contributor 无论背景都基于这套核心流程工作。</p>
<p>对于企业内部项目开放源代码的情况，要做到这一点并不容易。项目往往在企业内部已经有一套成熟的工作流。如果在设计开源方案的时候，没有把共享工作流考虑在内，即使代码公开，大部分开发流程也会保持在企业内部。如果 contributor 不是企业员工，则根本无法参与。</p>
<h3 id="Case-Study-OceanBase"><a href="#Case-Study-OceanBase" class="headerlink" title="Case Study: OceanBase"></a>Case Study: OceanBase</h3><p>这个问题的典型案例是 <a href="https://github.com/oceanbase/oceanbase">OceanBase</a> 项目。</p>
<p>OceanBase 项目的源代码托管在 GitHub 和 Gitee 两个平台上，同时接受问题报告和补丁提交。通常来说，一个项目只会有唯一的问题报告和补丁提交方式。例如，Linux 采用 Bugzilla 记录问题，邮件列表提交和评审补丁。GitHub 上有 Linux 的镜像，但是是只读的。其他的例子包括 GCC 和 PostgreSQL 等，都会有唯一的工作流，其他代码仓库只是镜像。OceanBase 两边都接受问题报告和补丁提交，反而是对两边的反馈都不重视。</p>
<p>可以猜测，它的核心流程既不是 GitHub 上的工作流，也不是 Gitee 上的，而是企业内部的工作流。这种情况下，能从开放可参与的平台上提交的大概率就只有简单的拼写错误或者代码重构补丁。因为即使是资深的开发者，缺少必要的信息和充分的讨论，也无法更进一步参与。实际情况也是如此，内部的活动别说讨论和设计文档，就连提交都不是实时同步的。此外，项目在两个平台上的活动，基本只有一名维护者出面在处理。</p>
<p>企业开放内部项目源代码，允许任何人学习和使用，是有社会价值的。但是内外两套工作流，甚至开放可参与的工作流只是个添头，那就不可能形成开源共同体。如果这就是预期的目标，那倒也没事。只是对于辛苦应付这些留下来的缺口进来的简单补丁的维护者来说，他是否会觉得这只是另一种值班呢？无论如何，工作流的统一都有助于减少损耗。不管是干脆只保留内部工作流，托管平台上的所有活动都没有回应保证，还是尝试融合到开放工作流，真正做到开源协同，都比牺牲一部分人，做一些创造出来的边缘工作要好。</p>
<h3 id="Case-Study-Apache-InLong-incubating"><a href="#Case-Study-Apache-InLong-incubating" class="headerlink" title="Case Study: Apache InLong (incubating)"></a>Case Study: Apache InLong (incubating)</h3><p>致力于融合到开放工作流的典型案例是 <a href="https://github.com/apache/incubator-inlong">Apache InLong (incubating)</a> 项目。这个项目是由腾讯捐赠给 Apache 软件基金会的数据流处理平台。</p>
<p>在项目开放初期，也存在只有内部工作流的情形。不过得益于主要维护者的软件工程经验，在明确项目要以开源协同的方式运作以后，经过对维护两套开发流程弊端的分析，得出了要融合工作流的结论。既然是开源协同，那么融合的工作流就是共享工作流了。</p>
<p>一段时间的改造后，原先内部工作流的核心流程被迁移到共享工作流当中，包括问题报告、补丁提交和版本发布。原先内部工作流服务于企业需求的部分则基于共享工作流构建。</p>
<p>企业内部仍然有用户问题报告，但是归结到项目本身缺陷的问题，会脱敏之后报告到 GitHub Issue 上。为了解决紧急问题，企业内部的 fork 版本仍然会打临时补丁快速上线，但是救火之后正式修复的补丁会以 contributing back 的形式提交到开源项目上。最后是版本发布。一开始，只有内部项目在发版。开放源代码之后，就有两个同类项目要分开发版。经过一系列的改进，主要是问题报告和补丁提交的及时同步，最终两个项目能够以较小的同步开销同时发版。换句话说，GitHub 上托管的版本，就是企业内部使用的版本。企业内部可能有一些临时补丁，但是并不构成一个差异化内部版本，并且这些补丁是积极地被推进 contributing back 上游的。</p>
<p>可以看到，确定开源协同开发项目的方向后，共享工作流不是形式主义，而是能切实提高软件工程效率和减少摩擦的方案。</p>
<p>对于企业本身依托开源项目建立的情况，要维持共享工作流也存在很多挑战。这些挑战大多出自一个原因，那就是最佳实践的匮乏导致节外生枝的私下讨论。</p>
<h3 id="Case-Study-TiDB"><a href="#Case-Study-TiDB" class="headerlink" title="Case Study: TiDB"></a>Case Study: TiDB</h3><p><a href="https://github.com/pingcap/tidb/tree/master/docs/design">TiDB</a> 的代码仓库中有专门存放设计文档的目录。理论上，新功能，行为变更，以及其他重要改动，都需要一个设计文档。</p>
<p>我们可以从设计文档的时间线看出这一工作流的变迁。</p>
<ul>
<li>2018 年下半年，共 17 份设计文档。</li>
<li>2019 年全年，共 6 份设计文档。</li>
<li>2020 年全年，共 13 份设计文档。</li>
<li>2021 年至今，共 19 份设计文档。</li>
</ul>
<p>从另一个维度看，2019 年 5 月到 10 月，2020 年 10 月到次年 2 月，一共将近一年的时间里，项目没有提出过任何设计文档。</p>
<p>那么，TiDB 项目在此期间是停止开发了吗？没有。它一直以每个工作日合并 10 个 PR 以上的开发速度在前进。在此期间关于功能设计的讨论，其实是转进了企业的即时通讯工具或内部文档当中了。我们可以看几个例子。</p>
<ul>
<li><a href="https://github.com/tikv/tikv/issues/10540">Raft Async IO</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/25970">SPM Enhancement</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/26085">Cardinality Estimation Enhancement</a></li>
</ul>
<p>这几个功能并不是没有设计，而是只在小范围内通过中文文档做出设计，就开始实现。甚至在 Cardinality Estimation Enhancement 的例子当中，以为 contributor 想了解功能设计和背景，被 assignee 以时间紧迫为由回绝。虽然 assignee 承诺会在完成后进一步披露消息，但是却没了下文。</p>
<ul>
<li><a href="https://internals.tidb.io/t/topic/372/7">Announcing remove required integration test check when merge pr</a></li>
</ul>
<p>另一个例子是 pull request 上的检查项变更。不仅整个过程是在企业内部决策后直接在开源项目上上线，共同体内的其他成员一无所知，而且对于 bad case 的处理依赖于企业内部的群聊，让人摸不着头脑。</p>
<p>其实这些案例，我相信相关成员并不是刻意要伤害开源共同体。设计和开发的需求是天然存在的，持续集成的改动也不是不能做，但是实际推动落实的成员，缺乏开源共同体当中工作的经验，难以站在一家企业之上的视角，以合理的方式开展工作，才导致了这些实际伤害了开源共同体的做法。</p>
<p>我在这两个方向都做过一些改良的工作。对于设计文档，我发起了一个 Public Design 的讨论，并且推动了几个重大改动的公开设计。在此过程中和复数的开发者沟通了公开设计的技巧，以及在此前提下如何高效地推进重要改动的落实。实际上，公开设计并不会损失效率。因为并不是内部讨论完成后拿出来公示，而是从一开始就放在公开渠道讨论。既然是开源协同，补丁提交本身也是公开的，这些材料有什么好隐藏的呢？相反，因为得到了潜在的更多反馈，能够在设计等早期阶段避免缺陷，反而公开设计是更加高效的手段。</p>
<ul>
<li><a href="https://internals.tidb.io/t/topic/399">Discuss: Public Design</a></li>
<li><a href="https://github.com/tikv/pd/issues/3839">Tracking issue for Region Label Feature</a></li>
<li><a href="https://github.com/tikv/rfcs/pull/67">RFC: Substitute RocksDB write stall</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/26020">Tracking issue for heuristic rules enhancement for index selection</a></li>
</ul>
<p>对于持续集成，企业内部把研发和工程效能分成两个竖井，又把开源共同体仅关联到研发的工作上去，是这个问题的根源。组织结构问题不好解，只能先改变工程效能团队的员工的认知。当他以开源共同体成员的身份变更项目基础设施的时候，也通过提交议题，达成共识后实施的工作流来推进。实际上，这样改变以后，关注到项目功能开发的成员与维护基础设施的成员更能坦诚的交换意见，避免意料之外的改变激发矛盾。</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/issues/28947">Integrate UT coverage with CI pipeline</a></li>
</ul>
<h3 id="Case-Study-Taichi"><a href="#Case-Study-Taichi" class="headerlink" title="Case Study: Taichi"></a>Case Study: Taichi</h3><p><a href="https://github.com/taichi-dev/taichi">Taichi</a> 是一个主要面向计算机图形学的并行编程框架，由胡渊鸣博士发明。去年，他作为联合创始人创立了太极图形公司来支持项目的发展。</p>
<p>项目早期基本是胡老师一个人的工作。开放源代码并有 contributor 加入后，画风是这样的。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/1836">[async] Implement basic StateFlowGraph</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/479">Allow ti test_python to take in individual test files</a></li>
</ul>
<p>这两个 pull request 的三位参与者，彼时分别在美国波士顿、日本东京和中国上海。当时也没有成立公司，更不谈有企业内部的即时通讯工具或文档空间。所以你可以看到所有必要的讨论都发生在 GitHub 平台上。</p>
<p>时间拉回到现在，部分项目的开发仍然是有迹可循的。比如有个置顶的 <a href="https://github.com/taichi-dev/taichi/issues/2398">RoadMap</a> 作为当前正在投入的工作的地图，比如 <a href="https://github.com/taichi-dev/taichi/issues/3301">Taichi 编译器前端类型检查</a>有个 tracking issue 来记录工作。</p>
<p>不过，也会出现我在昨天看到的无描述 4000 行改动无评论合并的案例。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/3567">[Mesh] The ti.Mesh class &amp; mesh-for loop implementation</a></li>
</ul>
<p>经过社交媒体的传播，目前这个 pull request 更新了部分描述。其实是一个学术研究相关的功能，在发出论文后希望 contributing back 到上游。由于变更较为复杂，早期设计出于研究原因不便公开，加上持续集成流水线的效率问题，所以采用了一步到位的合并方案。代码 review 私下发生在提交之前。</p>
<p>那么，这些信息昨天凌晨看到的我能够知道吗？答案是不能。</p>
<p>其实这种提交一个大改动的案例并不少见。Apache Flink 项目曾经多次发生过这样的事情，包括 2014 年 7 月合并 streaming 的原型，2019 年合并阿里巴巴内部版本 BLINK 等等。项目接受来自企业或学术团体的 contribution 是很正常的，其他开源项目也有研究室基于项目做出优化策略后 contributing back 的案例。</p>
<ul>
<li><a href="https://lists.apache.org/thread/mc4622swvv1y4dbty5x20rlh3whdjst5">[DISCUSS] A strategy for merging the Blink enhancements</a></li>
<li><a href="https://lists.apache.org/thread/mn1nf4p11t054zmhdglorjt40xoyz7wv">[ANNOUNCE] Contributing Alibaba’s Blink</a></li>
</ul>
<p>开源共同体接受 contribution 的标准做法仍然是公开讨论。只需要说明这件事情，解答潜在的疑问之后决定接受或拒绝 contribution 即可。如果 ti.Mesh 的研究结果是以这样的形式合并到代码仓库的，我想在一开始我就不会有疑惑和疑惑导致的误会。另一方面，公开讨论和 contribute 对开源项目也是一种保护。Apache 项目在接收重要 contribution 时都会考虑引入一个<a href="http://incubator.apache.org/ip-clearance/">知识产权清理</a>流程，确保接收 contribution 不会引入知识产权相关的争端。</p>
<p>Taichi 项目当中缺乏背景信息的还有这些例子。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/3538">[bug] Remove fallback in C++ code</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/3433">[gui] Show f16 image as f32.</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/3279">[Lang] Support more SNode trees for LLVM backends</a></li>
</ul>
<p>当然，必须说明的是 Taichi 项目的大部分 pull request 是有背景信息的。上面这些案例的参与者，我想也不是刻意隐藏信息，而是成立公司之后，自然地在线下或者内部平台讨论。既然已经通过私下讨论得出结论，再刻意搬到 GitHub 上反而就是低效的。对于具备项目假设 contributor 应该有的知识就能理解的补丁，也不需要做作的讨论。</p>
<p>要想避免因为已经私下讨论得出结论，从而把共同工作流的一部分切换成内部工作流的情况，应该从两个方面入手。</p>
<p>第一个是在确定开源协同开发项目的方向后，所有技术讨论都以 GitHub 平台的内容为唯一信源。私下讨论是无法禁止的，只能从技术领袖开始以身作则，推动公开讨论。其实对于大部分企业员工来说，在哪讨论并不重要。真正让他们转向私下讨论的原因，是在 GitHub 上的评论得不到回复，而钉一下或者内部文档 at 有奇效。值得一提的是，Taichi 也有我曾经到的 TiDB 的问题，那就是没有一个活跃的开放式讨论渠道，即没有邮件列表的替代品。有个 Discourse 论坛，但是是面向中文用户而不是全球开发者的。开通了 GitHub Discussion 功能，但是只有唯一一个版本发布的公告。</p>
<p>第二个是作为共同体的领袖，应当积极寻找不同背景的参与者。如果已经形成了私下讨论的习惯，仅仅要求员工改变习惯是很难有效的。因为公开讨论的主要原因，是为了和企业以外的 contributor 交流，以获得有意义的输入和提高生产力。如果员工发现换个地方发言，得到的回应还是同事的回应，并且 GitHub 上的评论还是得不到即时的回复，这件事就推不下去。</p>
<p>前面的例子提到过，当 Taichi 的主要开发者天各一方，没有成立公司之前，这种沟通是自然而然的。实际上，Linux 和 Apache Httpd 也是这样的。除了邮件列表，Linus 很难找到另一个渠道收获他所需要的反馈。Apache Httpd 的早期成员一开始就是在邮件列表上沟通的。只有实际存在组织以外的高水平参与者，开源协同的最佳实践才有意义。对于企业员工来说，也才有直接合理的理由不在内部讨论。毕竟就某个特定的问题，他更希望听一听那个不同背景的共同体成员的意见。</p>
<h2 id="招募新成员"><a href="#招募新成员" class="headerlink" title="招募新成员"></a>招募新成员</h2><p>寻找不同背景的参与者，其实就是作为共同体的领袖为共同体招募新成员。这是企业实践开源协同的另一个难题。除了为企业招募以外，应该如何为共同体招募呢？</p>
<h3 id="End-user"><a href="#End-user" class="headerlink" title="End user"></a>End user</h3><p>第一个要讨论的是用户。不过，用户是开源协同之外的内容。商业产品同样需要自己的用户。大部分用户也不会关心软件是如何实现的。</p>
<p>所以，要讨论用户，其实是要驳斥一些错误的观念。用户能够为你提供使用反馈，能够通过付费或捐赠支持项目开发人员持续投入，但是期待从用户群体中大规模地发现核心 contributor 则是不切实际的。</p>
<p>我听到过很多项目领袖跟我说，他的项目是独特的，因为不像大数据项目那样，用户本身也是开发者。它可能是一个数据库。哎呀，用户都是 DBA 或者数据分析师，根本不知道数据库怎么实现的嘛。它可能是一个机器学习框架。哎呀，用户都只会操作 Python 接口，根本搞不来核心 C++ 代码。</p>
<p>那我就想问了，你咋不去找那些就做数据库的人，就搞机器学习框架的人呢？你给团队招聘的时候知道找这些人，怎么到了给共同体招募新成员，眼里就只看到用户了。</p>
<p>其实我也可以理解。因为开源协同不够普及，大部分人提到 open-source 这个概念，第一印象还是一个市场营销的手段。或者提到“运营开源社区”，就把用户社区那些已有经验都搬过来。在这样的认识下 open-source community 就是开源社区，而不是开源共同体。其中“我们”是唯一的开发者，是懂行的。其他人是只会小修小补的爱好者，或者干脆啥也不懂的用户。</p>
<p>这个误区有点像思维定式。你现在要找的是有能力开发项目的参与者，那就去对应的群体里找就可以了。</p>
<p>当然，如果你就想做用户社区，就没打算搞开源协同，也是一种选择。对于这类需求，我建议研究 MongoDB 的做法。它们搞得挺好，这里就不展开了。</p>
<h3 id="Ecosystem"><a href="#Ecosystem" class="headerlink" title="Ecosystem"></a>Ecosystem</h3><p>抛开用户不谈，开源共同体当中的 contributor 还可以进一步细分。其中有一类 contributor 关注生态互连，另一类关注项目的核心逻辑。</p>
<p>如果项目提供了足够多的扩展点，或者策略替换机制，那么关注生态互连的 contributor 就能够快速参与进来。</p>
<p>例如，Flink/Spark/Presto 等项目都设计了 connector 机制，连来连去就能创造出大量的工作。例如，几乎所有项目都可以搞多语言 SDK 玩玩。TiKV 就有不少于五种编程语言的客户端实现。例如，PostgreSQL 提供 FDW 机制，不仅支持连接外部数据源，更暴露了参与 planning 阶段的计算下推接口。例如，Linux 其实也有丰富的扩展机制，支持多种架构和驱动就是一个例子。</p>
<p>上面这些都是项目本身的机制，更广泛的生态还包括解决方案的整合。例如，从 Netty 的角度看，Flink 就是它的生态的一部分。从 Flink 的角度看，serverless 技术栈 StateFun 又是它的生态的一部分。经常听 database 的开发者说自己的软件直面终端用户，但是其实就互联网业务开发者来说，中间是隔了一层 ORM 框架的。哪怕是数据分析师，大概率也隔了一层可视化框架。另外，数据的同步和搬迁也是应用设计不可缺少的一部分，这就是各种中间件能发挥作用的地方了。</p>
<p>总之，这类 contributor 还可以再细分。一类是关注项目提供的机制替换实现的，大部分可以从有可能提供实现的项目开发者当中寻找。例如项目的部署机制希望支持 Kubernetes 环境，那找一个热衷于写 Kubernetes Operator 或者刚学会跃跃欲试的开发者参与，就很有可能产生正面效果。另一类是关注项目整合形成用户解决方案的。实际上，项目开发者最终基于项目实现盈利，往往就是以某种解决方案出现。只要你发挥想象力，生态整合的可能性就是个乘法，不愁找不到参与者。即使是核心逻辑被单一企业掌控的 MongoDB 项目，其生态也是非常繁荣的。</p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>当然，项目的核心逻辑也是非常重要的。如果项目本身不够坚挺，那么就不会有用户使用，也无法激起 contributor 连接生态的动力。</p>
<p>项目的核心逻辑是一个项目的主要价值。这些逻辑通常由项目的初始成员定义。在企业主导项目的情况下，这些初始成员往往背景单一。同时，出于传统组织观念的影响，初始成员往往以企业当中的项目团队作为自我认同，团队等同于项目，也因此将核心逻辑的开发层层“保护”在看不见的高墙之内。</p>
<p>以项目团队作为自我认同，无怪乎招募新成员的时候，自我认知自动翻译成团队招聘，而想不到还有其他可能性。</p>
<p>反观成功的开源项目，数据湖项目 <a href="http://hudi.apache.org/">Apache Hudi</a> 由 Uber 捐赠给 Apache 软件基金会，在项目快速发展过程中吸引到了阿里巴巴和 T3 出行等企业的员工的参与，并吸纳了上述企业背景的开发者作为项目 PMC 成员。对于后续参与的企业的员工来说，他们在企业当中虽然也有项目团队，但是显然不会觉得项目归企业内的项目团队所有。对于 Uber 来说，来自其他企业的核心 contributor 的声音也不可忽视。这样，Apache Hudi 成功建立了一个开源共同体。</p>
<p>要想为项目招募开发核心逻辑的参与者，我觉得应该做到以下三点。</p>
<p><strong>第一点是改变认知</strong>。上面已经介绍了错误认知的危害和避免错误认知的最终形态。我把这种正确的认知称为“开发者的两顶帽子”。同一个开发者，既是开源共同体的参与者，也是企业的员工。这两个身份虽然从属于同一个人，但是却有着不同的诉求。只有区分开这些不同的诉求，一部分是开源共同体的目标，一部分是企业基于开源项目创造商业价值的目标，才能避免认知混乱导致人为制造出参与的高墙。</p>
<p><strong>第二点是公开讨论</strong>。前面讨论的很详细了，这里再补充一个点。当你真的身处一个开源共同体当中，不做公开讨论才是奇怪的。例如 Apache Hudi 的例子，如果 T3 出行的开发者想要实现某个功能，除了公开讨论寻求共识，别无他法。</p>
<p>公开讨论还有一个额外的好处，那就是方便引用。不少基于开源项目建立起来的企业，运营人员整天发愁哪里有技术内容可以发布，写技术文章好像变成了一个苦差事。其实技术话题公开讨论，天然的就有高质量的内容可以推送，其中悬而未决的议题，也是 contributor 参与的绝佳切入点。例如 <a href="https://twitter.com/engulaio">Engula</a> 项目在社交媒体的输出，基本就是设计文档或者开放式讨论里值得发布的内容。</p>
<p><strong>最后一点是积极招募</strong>。前面分析 Taichi 的例子也提到过，认知改变的假设需要多样化的开源共同体成员来验证，保持公开讨论的做法也需要不同背景的 contributor 参与。除了公开讨论能够吸引到潜在的参与者，积极招募更意味着共同体的领袖要主动思考谁是你要找的人。</p>
<p>对于每个项目来说，这个问题的答案都不一样。但是认为这个问题没有答案，或者说人才都在企业当中了，则是一种傲慢。</p>
<p>同样举数据库的例子，哪怕你有 Oracle 那么大，世界上也还有相当一批人在开发 PostgreSQL 等项目。这些人并不是一辈子就做这一件事的。只要你的项目足够有趣，他们就有可能投入。</p>
<p>另一方面，泛泛而谈数据库这样一个复杂的领域其实是一种懒惰。既然复杂的项目本身会分模块开发，为什么在招募新成员的时候就只想着完全理解整个领域的人呢？如果项目的并发设计不佳，只要是精通该语言并发编程的专家，愿意 contribute 做改进，你管他懂不懂数据库的专业概念。醉心于编译器前端的开发者，也许能解决 SQL Parser 当中经年的性能问题。进入 Apache 孵化器的项目的导师，往往也不是项目所在领域的专家，甚至不是开发者，但是他们能够帮助项目以 Apache 的方式建立起开源共同体。</p>
<p>以这样的方式去寻找潜在的开发核心逻辑的成员，相信你的视野会更加广阔。</p>
<p>其实，这才是“开源共同体”的含义。不止于项目，也不是社区居委会，而是围绕开源项目的发展，基于对项目的认同，形成的多层次合作共同体。</p>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>《大教堂与集市》书评</title>
    <url>/2021/12/14/the-cathedral-and-the-bazaar/</url>
    <content><![CDATA[<p>历时五天，我总算把<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>这本经典的开源文化著作认真读了一遍，真是酣畅淋漓。</p>
<p>本书是作者 Eric S. Raymond 的文集，其中最著名的一篇就是《大教堂与集市》，其他几篇分别是《黑客圈简史》《开垦心智层》《魔法锅》和《黑客的反击》。最有价值的是《大教堂与集市》和《开垦心智层》两章，系统解释了开源软件是如何生产的，开源开发的优势在哪，开源软件的传承是如何做到的。《魔法锅》解答了一些常见的关于开源软件使用价值和销售价值的问题，但是受限于时代背景，对商业化的讨论局限在夸大使用价值的部分，不能很好的指导基于开源软件提供软件服务的商业模式。</p>
<p>在进入具体的内容讨论之前，必须着重提到译者卫剑钒对中译本创造的价值。翻译是对原内容的二次创作，软件开发领域外文著作众多，大部分译本都让原文表意有明显的损失。卫剑钒翻译的《大教堂与集市》，阮一峰翻译的<a href="https://book.douban.com/subject/6021440/">《黑客与画家》</a>，以及云风翻译的<a href="https://book.douban.com/subject/35006892/">《程序员修炼之道（第二版）》</a>是我近一年来读过的本领域最佳译作。</p>
<span id="more"></span>

<h2 id="开源协同的优势"><a href="#开源协同的优势" class="headerlink" title="开源协同的优势"></a>开源协同的优势</h2><p>《大教堂与集市》一章主要讲的就是开源协同的优势。集市模式就是开源协同的模式，本章的要点在于论证这种模式能够生产出高水平的软件，以至于超过任何商业公司闭门造车的软件。原文的论述重点在同行评审的价值，辅以拥有用户的重要性，落点在如何以集市模式领导开源项目。出于讨论流畅性的考虑，我把前两点的顺序调换然后展开。</p>
<h3 id="拥有用户"><a href="#拥有用户" class="headerlink" title="拥有用户"></a>拥有用户</h3><p>对于任何软件来说，获取用户都是一个艰难的生存挑战，持续的用户反馈能够帮助软件不断修正前进方向，没有用户也即意味着软件的死亡。开源软件能够在早期发展阶段吸引到足够的注意力和用户。</p>
<p>一种形式是如原文作者继承 popclient 项目，从而直接继承其用户群。这在商业公司开发的软件当中是不容易做到的，因为涉及到专有软件的所有权转移，总是非常的繁琐且挫败的。大部分商业公司开发的软件，一旦因为种种原因不再维护，往往无法为人所继承而是彻底死亡。</p>
<p>因此，如今的用户对全新的专有软件往往抱有很强的怀疑态度。例如，最近一段时间迸发出来的新兴数据库软件，如果我无法获得它的源码，那么我如何能够自由地探索它呢？成熟的闭源商业软件辅以用户手册或许没有这个烦恼，但是软件的更替是不可避免的，新兴软件刚出世时，往往欠缺文档，功能不全，只有阅读源码甚至加以修改才堪堪能用。这种情况下，开源软件不是比闭源软件更好的问题，而是只有开源软件才能生存下来的问题。</p>
<p>此外，围绕开源软件或软件群形成的开源共同体有内部共通的价值观。如果你制作了一个新的开源软件，在潜在的用户群组里发帖介绍自己是不会被排斥的，如果软件质量不错，还会得到用户的自发传播。例如，我在 GitHub DCO App 异常期间，顺手开发了一个基于 GitHub Actions 的方案并在原 issue 下<a href="https://github.com/probot/dco/issues/162#issuecomment-942926111">评论介绍自己的解决方案</a>。没有回复会认为这是恶意竞争，而是出于解决问题的群策群力。又例如，Engula 项目开发过程中，向 Rust Community 和其他相关主题的资深开源开发者均寻求过意见和建议，其中认可 Engula 项目价值的人，就会自发的传播它。这对于商业软件来说是不可想象的，如果上面的行为替换成一个闭源商业软件，则参与者会认为你是一个销售人员而不是黑客同行，并且对一个完全黑盒的全新解决方案兴趣寥寥。</p>
<p>最后，开源软件不会将自己的用户局限在销售关系以内，这往往能保证软件开发者有更强的主导能力，按照符合软件工程的方式开发高质量软件，而不是在需求爆发的压力下将软件绑定在单一用户的需求上。</p>
<h3 id="同行评审"><a href="#同行评审" class="headerlink" title="同行评审"></a>同行评审</h3><p>同行评审是原文论述的重点，实际上，集市模式的核心价值就在于跨越组织边界的独立的同行评审验证设计和保证正确性。原文将其称为“Linus 定律”，即</p>
<blockquote>
<p>如果有足够多的 beta 测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。</p>
</blockquote>
<p>不过针对这个定律有两点需要解释。</p>
<p>第一点是它所强调的是独立的同行评审实施的简单性和有效性，而不是单纯的“人多力量大”。</p>
<p>开源开发的价值之一就是源代码公开使得任何人都可以分析代码逻辑以定位问题。时至今日，传统的研发组织仍然把开发人员和测试人员区分成两个竖井，测试人员几乎只能完成黑盒测试。可想而知，缺乏分析的现象型 bug 报告往往需要耗费开发人员相当多的时间重新验证、复现和定位。如果让对源代码一无所知的测试人员为 bug 定级，则两类人员之间的冲突会更加尖锐。</p>
<p>开源开发打破了这种困境。由于大家都有真实的源码，开发者和测试者很容易发展出一个共享的表达模式并进行有效的交流。一个现象型 bug 报告和一个直接关联到源码的分析型bug报告，对开发者解决问题的帮助简直是天壤之别。Linus 定律建立在开源开发的基础上，强调的是拥有源码以后加入新的眼睛的成本不在包含商业公司管控带来的限制和摩擦，从而能够从基数足够大的同行评审当中获取高价值的报告。</p>
<p>原文引用<a href="https://book.douban.com/subject/26358448/">《人月神话》</a>的 Brook 定律，提到随着开发人员数目的增长，项目复杂度和沟通成本按人数的平方增加，而工作成果只会呈线性增长。对于这个论点，原文作者是认同的。但是，开源项目所采用的沟通方式，区分成少部分核心开发人员与由 beta 测试者和潜在的贡献者组成的外围人员。外围开发者实际工作在分散而并行的子任务上，他们之间几乎不交流；代码修改和bug报告都会流向核心团队，只有在那个小的核心团队里才会有 Brooks 开销。</p>
<p>这揭示了开源开发的精英领导制内核，也解释了 Linus 定律虽然常被简化成“只要眼睛多，bug 容易捉”，但是却不是简单的“人多力量大”。</p>
<p>第二点是开源软件当中出现 bug 是正常的。这一点过于天经地义以至于当我发现我需要强调它的时候有些震惊。近年来出现的“心脏滴血”和前几天的 Log4Shell 漏洞，导致部分声音认为开源项目的使用是有风险的。</p>
<p>对此，我只能说，这当然啊！软件有 bug 不是正常的事儿么？开源开发不是银弹，任何复杂的软件都会有 bug 存在。Linus 定律成立的案例 Linux 是在高速发展的过程中保持了相对稳定的质量，而不是从来没有 bug 出现。如果你认为开源软件有不可承受的风险，最佳做法是参与其中对它做出改良。</p>
<p>此外，开源软件的许可证往往附带了免责声明，也即这个软件的源代码就这样（AS IS）给你了，没有任何保证（WITHOUT WARRANTIES）。在应用当中整合开源软件之后，保证应用的正确运行与安全性是应用开发者的责任。开源软件会因为安全问题损失声誉，因此作者会尽力提高安全性和正确性，并辅以相应的测试验证，但是这些都是尽力而为，没有保证。</p>
<h3 id="集市模式"><a href="#集市模式" class="headerlink" title="集市模式"></a>集市模式</h3><p>《大教堂与集市》一章的落点在如何以集市模式领导开源项目，这种模式相较传统的管理架构有何不同。</p>
<p>其中很多原则和技巧不是开源特有的，并通过敏捷等理念渗透到商业公司的软件开发当中。例如，“好的软件作品，往往源自开发者的个人需要”，“早发布，常发布，倾听用户的反馈”，以及“想出好主意是好事，从你的用户那里发现好主意也是好事”等等。</p>
<p>其中最重要的一点是关于发布的。开发者在需求列表不能调整和最后期限不能拖延的双重要求下，会完全顾不上质量，整个工作很可能会变成一团乱麻。Linux 通过发布两种不同类型的版本，各自宽松其中一个要求来保证软件质量和进度的协调。</p>
<blockquote>
<p>一种办法是保持最后期限不变而让需求列表灵活一些，允许某些到最后期限时仍未完成的需求被舍弃，这基本上就是“稳定版”核心采取的策略。 Alan Cox（稳定版核心的维护人）以相当规律的时间间隔将核心发布，但并不保证某个特定bug何时被修复，也不保证实验版中的某个特性何时会搬到稳定版中。</p>
<p>另一个办法是设定好想要的需求列表，并在其完成时发布，这基本上是“实验版”核心的策略。 De Marco 和 Lister 引用研究结果，指出这个进度策略即是“好了告诉我”，这不仅能够保证最高质量，而且就平均而言，与“保守”或“激进”的进度安排相比，它的交付时间更短。</p>
</blockquote>
<p>对于与传统的管理架构比较的部分，其理论基础可以参考<a href="https://book.douban.com/subject/26894636">《开放式组织》</a>与<a href="https://book.douban.com/subject/27125968/">《企业的人性面》</a>相关的论述。概括地说，开源的方式给予开发者足够的自由，以吸引高水平的黑客自发地创造价值。这种超越了对安全需要乃至生理需要的追求的模式，激发的是参与者对社会需要和自我实现需要的热忱。</p>
<p>在这里，没有预设的团队和资源，不需要在办公室环境下吞并其他团队的资源或者对其他团队的进攻做出防守。开源开发者是志愿者，是因为兴趣和能力自主选择的，他们会把自己的资源带到工作中，而不需要关心团队之间的领土争端和倾轧。</p>
<p>在这里，参与者凭借其创造的价值赢得权威。也就是说，最有才华的人能够对项目的发展做出最合适的决定。这不同于雇佣关系下被强制调配的人与项目之间的关系，而是对于特定的人，自由选择适合自己的项目，对于特定的项目，自然筛选出最合适的人。</p>
<p>原文还提到一种观点，即传统开发管理能保证艰苦和乏味的工作总能落实。我想这点毫无疑问是错误的。Linux 和 Kubernetes 的文档充足到令人难以置信，反过来只为了领工资才上班的人往往消极对抗撰写文档和测试或调试问题等工作。</p>
<p>开源共同体的目的是制造高质量的软件，在这个共同目标的引领下，不同方面的人才聚拢起来发挥自己的价值，反而是能够找到对传统开发管理认为艰苦和乏味的工作甘之如饴的人才。对于项目维护者来说，认识到这些所谓“无聊”部分的价值，协同参与者完成它们，是项目能够脱颖而出的必要条件。经过二十年来的经验积累，这逐渐成为最有才华的黑客当中的共识。</p>
<p>最后，对于想要实行集市模式的人，这里转述原文提到的“集市模式的必要条件”。</p>
<p>集市从成立伊始，就需要一个可以运行和测试的东西。当开始建设开源共同体的时候，你需要拿出一个像样的承诺。程序此时并不需要特别好，它可以简陋、有错、不完整，文档可以少得可怜。但它至少要做到能运行，且让潜在的合作开发者相信，这个软件在可预见的未来，能演变成一个非常棒的东西。</p>
<p>项目领导人需要能识别出别人的优秀创意，掌握一定水准的设计和编码能力，并且必须具备很好的人际交往和沟通能力。最后一点应该是显而易见的，为了建立一个开源开发共同体，你需要吸引人们，让他们对你做的事感兴趣，让他们乐于看到自己的贡献。一些技巧可能有助于实现这些，但远远不是全部，你的人格特征也很重要。</p>
<h2 id="开源软件的传承"><a href="#开源软件的传承" class="headerlink" title="开源软件的传承"></a>开源软件的传承</h2><p>《开垦心智层》一章讨论开源共同体的发展，以及发展过程中开源软件的所有权及转让的问题。</p>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>原文提到，开源软件的所有权获取有三种形式。</p>
<blockquote>
<p>第一种也是最显然的，就是去创建这个项目，当这个项目在开始时就只有一个维护者而且这个维护者仍然起作用的时候，所有权问题是连提都不该提的。</p>
<p>第二种方式是获取前任对所有权的移交（有点像“接力棒传递”）。这在社区中很容易理解，当项目“所有者”不愿意或者不能在开发和维护中投入必要的时间时，他（她）有义务将项目移交给一个有能力的继任者。</p>
<p>第三种方式是一个项目需要维护但项目所有者已经消失或失去兴趣了。如果你想维护该项目，你的责任是努力找到这个“所有者”，如果找不到，你可以在相关场所（比如 Usenet上专注于该应用领域的新闻组）声明该项目似乎是一个“孤儿”，而你想为之负责。</p>
</blockquote>
<p>我在协助处理 TiDB 里两个合并子项目的工作的时候，实质上就遵循了这里的原则。原来的项目由多名 contributor 参与完成，在当时的 CLA 设置下，要求每位 contributor 都必须和 TiDB 项目签 CLA 才能合并。比起强硬的改变 commit author 绕过 CLA 检查，我建议尝试联系未签署 CLA 的参与者补上。这些参与者被 at 以后很快响应并且解决了问题。</p>
<p>其实参与开源开发的人不是坏人，在项目没有发展出多样性之前，不要擅自以“内部”“外部”这种二元视角界定参与者的属性，也不要假设“外部”是邪恶的。</p>
<h3 id="分化"><a href="#分化" class="headerlink" title="分化"></a>分化</h3><p>原文将分化行为列为开源文化当中的禁忌。分化指的是派生出一个随后不能交换代码的竞争项目，并导致开发者群体的分裂。</p>
<blockquote>
<p>黑客厌恶项目分化的另一个原因是，他们惋惜那些被浪费的重复工作分化后的两个子项目总是有着或多或少平行的演化路线。他们也会注意到分支倾向于分裂合作开发者社区，使得两个子项目的人手都比父项目的人手更少。</p>
</blockquote>
<p>近年来雨后春笋般冒出来的开源项目，在分支和合作问题上起码有两点值得关注。</p>
<p>第一点是对合作的漠视。相当部分项目，号称开源，实则核心成员还是都来自同一个公司团队，规模往往超不出十几人。他们有很强的领地意识，拒绝其他人的参与，或者将其他人的贡献打包进项目整体说成都是该公司的贡献。这样做，使得不同组织的参与者失去动力甚至有种被驱逐出去的意味，实质上只是源码可得的传统项目开发模式。</p>
<p>当然，也有好的案例，且大多来自公司背景不强的项目。例如 <a href="https://github.com/InterestingLab/seatunnel">SeaTunnel</a> 还叫 WaterDrop 的时候，就吸引了不同组织成员的关注和参与，现在又被 Apache 成员关注到，合作进入 Apache 孵化器孵化。</p>
<p>第二点是对分支的痴迷。也就是公司喜欢 fork 出来搞个魔改版本，从不考虑 contributing back 还以为自己占了便宜。且不说这种行为禁锢了原本可以参与共同体的成员，代码分化带来的兼容性问题魔改版本从来不能解决。回过头来把魔改版本抛头换面又煞有介事的“开源”，应该被整个黑客社会所唾弃。</p>
<p>如果说还有一点，那就是那些所谓的“开源技术公司”，如果试图对开源共同体实施某种形式的管控，让商业公司凌驾于志愿者之上，那么这样的项目实际上更容易分化。Elastic 和 <a href="https://github.com/opensearch-project/OpenSearch">OpenSearch</a> 就是一个典型的例子。</p>
<blockquote>
<p>对于相对开放的民主制度而言，它的一个主要优势在于，绝大多数潜在的革命者发现通过在系统中工作比攻击该系统更容易让自己向目标前进。但如果既有政党联合起来“提高门槛”，导致那些较小的不满意团体觉得更难实现自己目标的话，这种优势就很容易被侵蚀破坏。</p>
<p>准入门槛不高的开放过程鼓励参与而非分裂，因为参与者能从中获得成果，而不用付出分裂所需的高昂成本。尽管这种成果可能不像分裂所得成果那样令人印象深刻，但其成本较低，且大多数人都能接受这种折衷。</p>
</blockquote>
<h3 id="冲突与解决"><a href="#冲突与解决" class="headerlink" title="冲突与解决"></a>冲突与解决</h3><p>原文提到，项目当中的冲突与解决主要围绕三个问题展开</p>
<ol>
<li>谁来负责做设计决策？</li>
<li>如何决定哪个贡献者应该被授予荣誉，如何授予？</li>
<li>如何保持项目团队和产品不被分裂为多个分支？</li>
</ol>
<p>第一个问题由上述所有权问题回答。关于分支的问题在上一节已经讨论过了。现在看第二个问题。</p>
<p>无论采用独裁者模型还是委员会模型，黑客的荣誉都跟他创造的价值相关。也就是说，黑客的声誉在礼物文化的大背景下，由他的贡献即赠与开源共同体的礼物的价值所决定。对于独裁者模型来说，独裁者本人需要能够践行这样的规则，否则高水平的参与者就会选择离开。对于委员会模型来说，还有一个额外的问题是委员会自身应该避免冲突。原文质疑委员会模型难以避免冲突</p>
<blockquote>
<p>在这种形式中，我们很难看到内部边界，并因此很难避免冲突，除非委员会内部享有极高水平的和谐与信任。</p>
</blockquote>
<p>但是，今天的软件复杂度越来越不支持独裁者模式。如果独裁者本人已经把部分决策权交给参与者，那么他在运行上就类似于委员会的模式。即使独裁者名义上拥有最终决定权，他与维护某一模块的核心成员仍然需要保持高水平的信任以减少项目当中的摩擦。</p>
<p>结合如今一部分商业公司创建或大规模参与开源项目的背景，如果项目建立的是同侪共同体（community of peers），也就是说成员的角色与个体相关，而不是与他在某个组织的职位相关，在这种情况下依然把委员会的人员增加与企业员工入离职挂钩，这种组织形式就是非常危险的。</p>
<p>具体地说，部分项目照猫画虎地搬来了 Apache 软件基金会式的同侪共同体设计，在决定项目 PMC 成员和 committer 人选时，却变成了公司同事入职，“理应”有 commit 权限，就稀里糊涂的成了什么 committer 或 PMC 成员。一旦离职，则完全不理会项目的发展，甚至出于不愉快恶意捣乱项目的日常事务。这就是没有基于项目的需要和个体对项目的认可和贡献选择委员会成员的弊病。</p>
<p>这是说缺乏多样性的项目中，单一公司的员工需要避嫌吗？当然不是。实际上，成为大力投资该项目的公司的雇员，能够尽可能多的时间投入到项目发展上，公司的员工确实有更大的可能性成为核心成员。但是必须注意的是他的推举应该是客观的，基于项目的需要和个体对项目的认可和贡献来选择。只有这样，才能努力做到委员会内部有极高水平的和谐与信任，这才是这种组织形式下项目长久发展的根基。</p>
<h2 id="开源与商业模式"><a href="#开源与商业模式" class="headerlink" title="开源与商业模式"></a>开源与商业模式</h2><p>《魔法锅》一章的主题是开源与商业模式，着重讨论了反公地模型，软件的使用价值和销售价值，以及当时存在的开源相关的商业模式。</p>
<h3 id="反公地模型"><a href="#反公地模型" class="headerlink" title="反公地模型"></a>反公地模型</h3><p>我曾多次听到有人拿“公地悲剧”来类比开源协同的开发模式，认为后者也会如前者一样失败。</p>
<p>所谓的公地悲剧，指的是假设一个村庄里的所有人都可以不受限制地在一片公共的草地上放牧，如果没有一个共识来抑制过度放牧，出于自身利益的考虑，每个人都会尽可能多的放牧，以期在公地资源耗尽之前从中获取最大价值。</p>
<p>但是，Linux 项目持续三十年，长寿的开源项目比比皆是，这种类比显然是有谬误的。原文从公地悲剧两个必要条件来反驳，一是过度使用，二是供应不足。</p>
<p>公地悲剧的一个必要条件是所有人都放牧会使得草地退化，但是开源软件一旦制造出来，不会因为被过度使用而损失价值。反过来，广泛的使用会提升开源软件带来的价值。这一点很好理解。</p>
<p>公地悲剧的另一个必要条件是没有人会修缮草地，因为公地奖励“搭便车”行为，即你修缮了草地别人就可以无偿分享你的成果，而你的付出别人并不承担，结果是付出比不上被分摊后的收益，于是所有人都不付出。</p>
<p>在开源开发中不会遇到这种情况。这是因为参与者不仅需要解决方案，他们还需要问题被及时解决。因此解决这个问题本身带来的收益就足够偿还成本，而等待别人解决问题则完全无法预期它会在何时被解决。</p>
<p>这部分解释了解决方案必然会被生产出来的问题，但是其创造者为何会无偿发布这个补丁，还需要进一步的讨论。</p>
<p>一方面，很多情况下开发者无法为其确定一个公允的市场价格。另一方面，坐等在补丁上不会有任何收益，反而会带来额外的成本，因为你现在要在上游发布新版本时重复合并这个补丁。由于上游对该补丁的存在并不知晓，这种重复合并甚至有可能是多次重做。毫无疑问，这是非常挫败的。由此看来，只要你需要上游的更新，无偿发布补丁就是最优策略。</p>
<p>但是，这里还有一个问题，如果补丁有足够的差异性，补丁作者为什么不将其闭源以获取其销售价值？对于 GPL 许可的项目来说，项目本身的演化需要与其他各方分享，这不是个问题。但是软件结合的形式有很多，GPL 对软件即服务等方式难以产生约束，还有以其他宽容开源协议如 APL 等许可的项目，这些情形正是当下开源与商业的讨论焦点。</p>
<h3 id="软件的使用价值和销售价值"><a href="#软件的使用价值和销售价值" class="headerlink" title="软件的使用价值和销售价值"></a>软件的使用价值和销售价值</h3><p>在讨论这个焦点之前，我们先看看软件的使用价值和销售价值。</p>
<p>软件的使用价值是它作为一个工具的经济价值，软件的销售价值是它作为一个可买卖商品的价值。大部分软件是作为内部系统被生产出来的，原文认为，这个比例达到九成以上。开发者的薪资实际是出于维护软件的使用价值的目的支付的。</p>
<p>如果你创造的软件主要用于内部系统，而你的薪资也来自于维护它的使用价值，那么通过闭源来保护销售价值是没有意义的，因为你不会将它用于销售。这种情况下，通过开源协同来提高软件本身的开发效率和质量，就是有收益的。</p>
<p>值得注意的是，只要软件的开发在隶属于不同组织的参与者之间共享工作流，采用开源协同的开发方式就没有额外的成本，因为公司为了用上这个软件，总是要付出开发成本的。这个共享工作流的前提条件也是《魔法锅》一文成书时未曾想到的，居然还有人为了形式开源而给同一套代码区分出两套工作流。</p>
<p>原文提到两个常见的反论意见。一个是通过闭源代码保护商业机密。这是无稽之谈，主要是代码设计糟糕。通常来说，你应该将机制开源，编写通用的逻辑，而将商业知识相关的策略单独实现。当然，后者并没有什么开源的必要。</p>
<p>另一个是说闭源能够保护软件安全。这也是谬论。除了上面商业机密泄露的场景，对于纯粹的骇客攻击行为，二进制照样能被破解，开放源码只是多了一种破解的手段。</p>
<p>类似近几天的 Log4Shell 漏洞，难道黑客不读代码就找不到这个问题了吗？如果公司内重新实现日志框架，且不说要达到 log4j2 的水平要付出多大成本，以及生态兼容性的种种问题，难道重新实现的软件就没有其他安全问题吗？</p>
<p>即使不说分析源码的破解手段并不比破解二进制的手段轻松多少，可靠的安全性也依赖于算法及其事先经过彻底的同行评审。这么看来，开源软件反而更容易修复安全问题。Log4Shell 通过同行评审发现后通过必要的 private 邮件列表上报，在上游修复后进行披露，正是这种安全同盟的一般做法。</p>
<h3 id="直接收费的问题"><a href="#直接收费的问题" class="headerlink" title="直接收费的问题"></a>直接收费的问题</h3><p>当然，上面这些讨论仍然没有覆盖当前这波开源浪潮下新出现的商业公司群体，这些公司创造开源软件，并希望基于它们创造的开源软件获利。</p>
<p>原文对直接收费类型的许可证做出了批驳，指出希望在源代码可得的前提下添加某种收费或变相收费的条款，会遭到黑客的反感，从而失去开源共同体的支持。这是因为这类许可证违背了三个开源共同体的共识。</p>
<p>第一个与对等性有关。大多数开源开发者并不反对别人利用他们的礼物获利，只是不能要求有任何人站在一个特权地位上牟利。MongoDB 的 SSPL 在理念上或许沿袭了 GPL 的一些理念，只是它对形成派生作品的描述“形成服务”太过笼统，得不到广泛的支持。但是 MongoDB Inc. 自己并没有按照 SSPL 的要求开放它的整个服务栈的源代码，这种对等性的破坏遭到了黑客的唾弃。实际上，MongoDB 的核心代码几乎只由其公司雇佣的员工开发和评审。</p>
<p>第二个与非有意后果有关。原文提到，对商业使用或销售进行限制并收费的许可证有着令人扫兴的效果。特别是这条规定给某些分发行为笼上了一层法律阴影，而这些活动正是黑客非常愿意鼓励的事。还是 SSPL 的例子，由于“形成服务”太过笼统，几乎所有黑客都倾向于不分发该软件以避免潜在的法律风险。原文认为，黑客很少在这一点上让步。实际上，这也是 OSI 拒绝承认 SSPL 是开源许可证的主要原因。</p>
<p>第三个与保持礼物文化相关，这也是最关键的一个原因。如果许可证在法律上就禁止产生分支，那么黑客们绝对不会认同这样的条款。原文解释到，虽然黑客们不赞成分支，但是分支是“最后一招”。如果维护者不能胜任或者背叛开源文化，可以通过分支来保护礼物的传递。Elastic 与 OpenSearch 就是活生生的例子，以 AWS 的工程师为首的开发者在 Elastic 转向更加封闭的时候基于开源版本分支并独立发展，保持新分支的开源属性。</p>
<h3 id="开源的商业未来"><a href="#开源的商业未来" class="headerlink" title="开源的商业未来"></a>开源的商业未来</h3><p>《魔法锅》随后介绍了当时作者所看到的的若干种基于开源软件的商业模式。这里不需要展开，因为它们都统一在同一个模型下。这个模型就是基础架构和中间件开放，应用和服务收费的模型。</p>
<p>开源基础架构，并利用同行评审的价值，协同跨越组织的参与者创造出类别杀手，做到这点的收益实在太大了。类别杀手指的是即好到没人再想使用其他备选的高质量开源原创项目，例如 Linux 和 Kubernetes 等。</p>
<p>Google 愿意开放 Kubernetes 的源代码，很大一部分原因就是为了联合其他商业公司以及整个开源共同体形成事实标准的垄断，而要做到这一点，开源协同的方式是最高效的。Kubernetes 形成垄断后，越是早期参与项目的组织，越是投入资源大的组织，越能够获得某种程度上的原厂品牌效应，并积累足以应付软件在使用上的种种问题的开发者团队。这些组织通过提供应用级别的定制和维护服务收取报酬。</p>
<p>原文认为应用非常倾向于继续封闭，这种封闭尤其可能出现在自成一体的垂直市场当中，其网络效应也较弱。这其实就是针对特定场景开发的插件或者是针对具体业务接入基础架构的实施。时过境迁，如今的软件复杂度已经不是当年一个全栈工程师从购买服务器到整个网站都能负责开发的年代，雇佣业务实施团队将越来越常见。</p>
<p>这些插件某种意义上也可以算作中间件。实际上，应用和中间件之间的差别会随着时代的发展而变化。原文认为数据库是中间件，但是如今却更被认为是某种基础软件。中间件走向闭源还是开源，取决于软件失效的代价，代价越高，走向开放的市场的压力就越大。</p>
<p>举个例子，AWS 的不少服务是闭源的，但是它们的客户端是开源的。这些客户端就是中间件，如果它们的维护更封闭，那么失效的可能性就会越高。广泛的用户会倾向于使用开源的替代品。一个案例是 AWS S3 的 Rust 客户端 rusoto 和官方后来提供开源版本。</p>
<p>Confluent 依靠提供 Apache Kafka 的服务盈利，整个商业模型包括三个部分。</p>
<p>第一部分是实施，也就是帮助客户业务与 Apache Kafka 对接，乃至于设计整个业务消息平台。这是传统上所说的“外包”工作，由于软件复杂度日益升高，这类工作所需的软件开发技能也越来越丰富，相应的雇佣薪资也就水涨船高。这种模式也被称为订阅，在一个订阅周期内，客户能够获得实施工程师的支持，商业公司在提供工单响应的保障。实施包括支持私有化部署，也包括帮助客户对接云服务。</p>
<p>第二部分是提供基于开源软件的云服务，也就是云上的 Apache Kafka 资源，客户按照使用的节点数或访问量交费，这种模式实际上是商业公司通过出租商业地产盈利。一方面，CPU 和内存等资源本身是成本，用户无论如何也要为这些成本付费。另一方面，商业公司在资源之上提供了消息平台的抽象，屏蔽了部署和运维软件的复杂度，并以此来赚取差价。对于无力自行维护的企业来说，购买云服务就是最优选择。</p>
<p>值得一提的是，这种部署的附加值是工程师水平和硬件成本的函数，云厂商往往能够获取更廉价的硬件成本，因此独立服务提供商最好追求部署和运维本身的开销下降，这种运维和部署的策略是商业机密和盈利的基础。另一方面，可以通过维持云中立，避免供应商锁定等优势，利用云厂商之间的竞争激发用户的优先选择意愿。</p>
<p>第三部分是专有软件，例如 ksqlDB 等。只不过 ksqlDB 的位置更像是接近基础架构的中间件，被 Apache Flink 和 Materialize 等项目挤压了不少生存空间。反观 Apache Pulsar 和 Apache RocketMQ 就没有将类似功能做成专有软件以期销售，避免被其他项目分化用户。</p>
<p>对于哪些软件不适合通过闭源获取商业价值，《魔法锅》一文介绍了应该考虑开放源码的软件，时至今日仍然是正确的</p>
<ol>
<li>可靠性、稳定性、可扩展性非常重要。</li>
<li>除了独立的同行评审，没有其他便捷易行的方法验证设计和实现的正确性。</li>
<li>该软件对客户的业务非常关键，因此客户期望避免供应商锁定。</li>
<li>该类软件受网络效应主导，即你无法实现压倒性的市场控制力。</li>
<li>关键方法属于公共知识。</li>
</ol>
<p>开源与闭源在几乎所有层面上都是并存的，并且呈现出一种动态发展的趋势。</p>
<p>起初，Windows 垄断了操作系统的市场。当 Linux 出现以后，服务端操作系统的份额开始逆转，并且出现 RedHat 等商业公司。原文称为中间件的数据库，起初被 Oracle 主宰，如今它也承受着 PostgreSQL 的冲击，海量提供 PostgreSQL 服务的商业公司也能生存下来。今天，云原生技术和软件即服务的概念改变了软件生产和使用的格局，越来越多的商业公司创造开源软件或参与到其开发当中，目的就是推出下一个类别杀手，并取得之后的软件服务战争的优势。</p>
<p>实际上，最好的商业价值获取方式仍然依赖创造性的垄断，这也是知名商业著作<a href="https://book.douban.com/subject/26297606/">《从 0 到 1》</a>的观点。只不过，软件的复杂度以及开源开发应对这种复杂度在生产力上的显著优势，使得你无法在一个很大的范围内实现垄断。但是你仍然可以找到合适的垂直领域，或者就是为客户做实施——这也许是最垂直的一种方式了。</p>
<p>如今，想要创造局部垄断的一种新方式，是通过开源协同的集市模式创造出一个类别杀手，在此过程中获得某种程度上的原厂品牌效应，并积累足以应付软件在使用上的种种问题的开发者团队。进一步的，将原本的市场格局改变，在不改变固有需求的情况下改变产生商业价值的位置。以操作系统为例，原本商业公司以创造出商业操作系统为竞争优势，Linux 出现后，如何基于 Linux 提供更好的服务，或者看到 RedHat 如今的上云策略，提供海量 Linux 服务器资源的运维和应用的部署服务。</p>
<p>改变不利于自己的商业格局，并在环境有利于自己的时候做好下一次颠覆的准备，才是开源时代的商业未来。我也相信这种形式，能够促使企业家真正成为创新的先锋，而不是被长时间垄断所麻痹，不思进取乃至阻止社会生产力的进步。</p>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>大图书馆</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
</search>
