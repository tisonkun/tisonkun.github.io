<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>开源共同体参与者的动机</title>
    <url>/2022/01/20/contributors-motivation/</url>
    <content><![CDATA[<p>本文整理自我在开源社举办的 COSCon’21 活动上的主题分享<a href="https://www.bilibili.com/video/BV1Tg411K7KS/">《Why Contributors Stay and Grow》</a>的第一部分。</p>
<span id="more"></span>

<p>正文开始之前，简单讲讲题目中的两个名词。</p>
<p>一个是相比起开源社区，我现在倾向于使用<strong>开源共同体</strong>来指代 open-source community 的概念。这个词借鉴自科学共同体，科学共同体是由科学观念相同的科学家所组成的集合体，也即科学活动的主体。我认为开源软件的开发以及围绕开源软件开展的活动更加贴近这类共同体的概念，而不应与街道社区的概念混淆。关于这个词的详细阐述，可以参考<a href="https://opensourceway.community/posts/community_leadership_development/what-is-open-source-community/">《根本就没有什么所谓的“开源社区”》</a>一文。</p>
<p>另一个是相比起贡献者，我现在倾向于使用<strong>参与者</strong>来指代 contributor 的概念。因为我认为 contributor 参与到开源共同体当中是以他们亲力亲为的行为来支持共同体发展，这是一种赢得声誉的方式，而不是近义于奉献的贡献。关于这个词的翻译，我还不够满意，做出贡献本身也是中立的，只是容易被误会成无私奉献。</p>
<p>开源运动持续吸引新的参与者加入，围绕开源软件建立起来的生态也越来越繁荣复杂。在这样的背景下，形形色色的参与者的动机也各有不同，我将这些动机分成三类。</p>
<h2 id="直接利益"><a href="#直接利益" class="headerlink" title="直接利益"></a>直接利益</h2><p>一开始，自由软件运动当中的黑客虽然能够销售自己编写的软件，但是由于软件本身以自由软件协议许可，所以这类直接利益实际上非常有限，对于参与者来说也不是主要的动机来源。</p>
<p>随着开源运动的影响力日渐增长，针对性的运营岗位和运营预算的出现，导致参与开源软件的开发或者以其他形式为开源共同体做出贡献能够实际获得直接利益。例如，提交补丁赢得马克杯或者文化衫等小礼物，参加改进开源软件的挑战赛赢取奖金，或者有偿为开源软件撰稿及宣传等等。这类动机下参与到开源共同体的人，都可以归类到直接利益激励之下。</p>
<p>这类参与行为的特点是成果可以明确衡量。例如，提交多少个补丁，反馈了多少个问题，挑战赛下每个题目的积分以及是否被解决，稿件是否交付，宣传的效果包括文章阅读量，视频播放量，植入链接点击转化率等等。</p>
<p>我并不反对这种参与动机，因为无论是出于何种理由，参与到开源共同体的建设当中，支持它的发展，都是实质的贡献。只是对于发放直接利益的运营人员，或者认为如此运营非常有效的决策者，需要提醒一句不要高估了这种参与的价值。</p>
<p>实际上，面对各个开源项目推出的五花八门的活动，有不少人会专门盯着这些消息，计算其中门槛低，收益高的活动去参与。例如，开源项目刻意放出诸如修复 linter 等机械化的待办项，完成一个或几个就可以兑换主题小礼品。例如，为了挑战赛的奖金，选择一个与开源项目勉强挂钩的自己熟悉的主题参赛。事成之后，也就把项目完全抛诸脑后，物色下一个“送财童子”。</p>
<p>求仁得仁。既然提供直接利益的衡量标准就是数字化指标，那么如此运营最终也就会得到相应的指标。但是，发展开源共同体需要有责任心的参与者。这样的活动如果不是根据共同体发展的实际需要顺势而为，而是刻意为之，例如故意留下缺陷找人修复，那么为此而来的参与者就不会尊重这个项目，而有责任心的参与者和维护者，也不会重视这样的活动。到头来只是劳民伤财，甚至培养出核心参与者和活动参与者之间的矛盾，真是得不偿失。</p>
<p>直接利益的激励方式也能够正向的结果。如同上一段提到的，带来问题的活动是刻意为之，如果活动本身是顺应共同体发展而举办的，就不会有这种问题。</p>
<p>第一类，比如 <a href="https://pingcap.com/zh/blog/how-to-join-in-the-tidb-performance-challenge-program">TiDB 性能挑战赛</a>根据 TiDB 对表达式模块发展的需要，把标准化的任务发布出来并利用宣传渠道和直接利益激励鼓励参与。虽然参与的人大部分也没有持续投入，但是这个活动本身确实解决了 TiDB 的实际问题，且有部分后来非常活跃的参与者是从这个契机加入进来的。</p>
<p>第二类，比如各个开源项目每年参与 <a href="https://summerofcode.withgoogle.com/">GSoC</a> 等活动的主题。这类主题一般是把项目重要而不紧急的工作借力第三方渠道发布出来，利用第三方对自身品牌的需要和投入，吸引相应的参与者合作开发，最终由第三方支付直接利益报酬。这类活动比起标准化的任务，通常更具有独特性，参与其中的成员也更有可能留存在共同体当中持续贡献。</p>
<p>第三类，比如 Perl 共同体的 <a href="https://www.perlfoundation.org/grants.html">Grants</a> 流程。这是从近二十年前开始的一个拨款项目。类似于其他非盈利组织，Perl 基金会接受社会各界的捐助。不同于 Apache 软件基金会和 Linux 基金会，Perl 基金会专门有一部分款项是提供给为 Perl 共同体做出贡献的参与者的。任何人都可以提出拨款请求，说明自己想要完成的项目，预计投入的时间精力和估算的应得报酬。只要拨款委员会认同，就可以成立一个新的工作项。申请人需要落实工作，定期汇报并在完成工作后由委员会验收确认发放拨款。</p>
<p>不得不说，Perl 共同体的运营能力首屈一指。我在 Perl IRC 聊天室里曾经多次听到核心成员包括 Larry Wall 谈论如何优化 marketing 的事，这在其他开源共同体当中是少见的。一个典型的例子是 Perl 6 项目在 2008 年收到了一笔二十万美元的捐款，而后来 Perl 6 的核心开发者 @jnthn 也多次为自己的工作申请拨款。从上面提供的 Grants 网页当中探索，你就可以发现 Perl 共同体是如何利用这一机制推动项目发展的。这种自发捐赠为参与者提供直接利益激励，以达到维持软件迭代开发的手段，在如今以 <a href="https://en.wikipedia.org/wiki/The_DAO_(organization)">DAO</a> 等形式继续探索，有志于这个方向的人，不如看看 Perl 共同体二十年来都是如何运作的。</p>
<h2 id="组织驱动"><a href="#组织驱动" class="headerlink" title="组织驱动"></a>组织驱动</h2><p>另一类参与开源共同体的动机是组织驱动。组织驱动的意思是参与者受雇于某个组织，这个组织的存续和发展依赖于开源共同体的存续和发展，在这种情况下，组织有动力通过支付报酬和挂钩绩效等方式，推动其雇员参与到开源共同体当中。</p>
<p>根据组织动机的来源，这类参与动机又可以继续细分。</p>
<p>第一类是组织的业务发展依赖于开源软件，为了保证这个依赖的稳定供应，组织投入人员参与维护，并赢得话语权以推动有利于组织发展的工作。</p>
<p>典型的是发起该项目的公司，例如 PingCAP 之于 TiDB 或谷歌之于 Kubernetes 等等。进一步推广，任何基于开源项目提供商业服务或解决方案的公司，例如 Tetrate 之于 Istio 或 DataStax 之于 Apache Pulsar 等等，都有动力发动其雇员全职参与开源软件的开发和维护，甚至直接雇佣开源软件的核心维护者。</p>
<p>除去这类销售基于开源软件的商业产品的公司，另一类不可忽视的是核心业务建立在开源软件之上的公司。前段时间的 Log4Shell 事件和 Faker.js 删库事件，提醒了采用开源软件构建自己核心业务的公司，不应该把开源软件彻底当成免费的午餐，而应该按照合理的软件供应链安全视角看待开源软件的使用。软件采购本身可能是免费的，但是维护和保障却不是。无论是自己投入员工积极维护，还是购买开源软件服务供应商的服务，都是可行的策略。这两种应对策略，也分别直接或间接地参与了开源共同体的发展。</p>
<p>关于开源软件供应链的详细讨论，可以参考<a href="https://zhuangbiaowei.github.io/opensource/2021/05/12/about-OSS-Supply-Chain.html">《我所理解的开源软件供应链安全》</a>和<a href="https://zhuangbiaowei.github.io/opensource/2022/01/15/Talking-again-about-OSS-Supply-Chain.html">《再谈开源软件供应链安全》</a>两篇文章。</p>
<p>第二类是组织通过发起或参与开源项目，来赢得自己的品牌。品牌对于人员招聘和漏斗转换都有不可忽视的作用。谁不愿意为了一个伟大的目标而工作呢？谁不想要在一个技术实力强劲的组织当中开发代码锻炼自己呢？谁不倾向于选择一个品牌文化上更值得信任的组织的产品呢？这方面的例子不胜枚举，尤其是个体价值崛起的今天，年轻人在选择就业的时候，相当一部分倾向于选择能够参与令人兴奋的开源项目的工作。</p>
<p>第三类是组织通过发起或参与开源项目，来定义行业的标准。典型的例子是 Kubernetes 的初始成员，合力把 Kubernetes 做成了容器调度的标准，从而使自己的前期投入都获得了巨大的回报，同时打击了下注给其他解决方案的竞争对手。</p>
<p>另一个例子是世界上大规模使用 C++ 来开发项目的公司，往往都在 C++ 委员会当中有一席之地。谷歌、苹果、微软和 IBM 等公司都是如此。如果能够参与到行业标准的定义，对于保证自己的业务能够持续的受到整个开源共同体工作的增益至关重要。又例如 Java 委员会当中对模块化标准的讨论，对预先编译标准的讨论，都牵扯到组织内部数百万行乃至更多的代码在新的软件开发部署形势下是要痛苦地迁移或兼容上游，甚至完全重写，还是能平滑地过度。</p>
<p>开源共同体当中参与者的动机，占比最大的我认为就是组织驱动类型的。</p>
<h2 id="自我驱动"><a href="#自我驱动" class="headerlink" title="自我驱动"></a>自我驱动</h2><p>虽然组织驱动类型的占比最高，但是支撑开源软件长久的存续和发展，赋予开源共同体灵魂的核心参与者，往往是自我驱动的。</p>
<p>自我驱动分成两个阶段。第一个阶段是对开源软件的认同和责任带来的动力，典型的是开源软件作者希望它能够产生价值，为更多人所用。</p>
<p>不谈 Linux 一类广为人知的项目，我在上周录制某个播客的时候提到的 <a href="https://inlong.apache.org/">Apache InLong (Incubating)</a> 项目就是如此。项目的主要作者出于对项目的认同和责任，在它从某大公司捐赠给 Apache 软件基金会之后，积极思考如何避免公司内部的使用跟开源软件的开发分化成两套工作流，定义出了统一的开发和发布流程，避免了某些 KPI 开源项目管生不管养的窘境。</p>
<p>软件的作者毕竟是特殊的一个或少数的几个人。随着软件的发展并逐渐为人所知，越来越多的参与者加入进来，喜欢这个项目，或者把职业生涯都绑定在这个项目及其所代表的领域上，这样的人就有成为核心维护者的潜力。</p>
<p>例如，Apache Flink 的 PMC @wuchong 就在长年参与项目的过程中，把自己和项目紧密地绑定在了一起。现在你提及中国乃至世界范围内的 Flink 专家，都很容易能够听到他的名字。这是他从 2016 年参与至今，从 Flink SQL 到 Flink CDC 跨越多个项目的持续参与，积极解答大量用户问题所积累的贡献赢得的声誉。</p>
<p>例如，Netty 的核心维护者 Norman Maurer 在项目发起的三年以后与它结缘，认同它的价值并把自己的职业生涯的相当一部分建立在 Netty 项目之上。从 红帽到苹果，公司变了，核心技术栈却不变。Norman 一直维护 Netty 项目至今，并为 Netty 著书推广。</p>
<p>数不胜数的例子，是开源项目的开放属性带给软件作者和核心参与者跨越职业生涯不同阶段的参与可能性，以及长期参与带来的认同感和责任感。开源软件就是自己的价值所在，这样的自我驱动推动着参与者以年为单位投入到开源共同体当中。</p>
<p>第二个阶段是对开源文化的认同带来的动力。我在 COSCon’21 上讲到自我驱动的时候，幻灯片展示的是三本与开源文化相关的书籍，<a href="https://book.douban.com/subject/26314527/">《若为自由故》</a>、<a href="https://book.douban.com/subject/25930025/">《只是为了好玩》</a>以及<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>。</p>
<p>这里，我把开源运动和自由软件运动的文化并起来讲，虽然它们的关注点略有不同，但是在创造出好的软件并造福大众的这一点上是一致的。RMS 相信自由软件是软件本来就该有的属性；Linus 认为开发开源软件能够选择自己愿意共事的伙伴，并且在 GPLv2 “我赠与你源代码，你回馈我相关的修改”的理念下共同开发；ESR 相信开源软件的开发模式能够创造出更加优秀的软件。他们对开源文化的认同已经固化到自己的认知当中，我想终其一生也不会改变。</p>
<p>对于一个或几个开源项目的认同带来的自我驱动，能够让参与者在相当长的一段时间内持续地投入自己可观的精力。对于开源文化的认同带来的自我驱动，将影响参与者一生的价值判断，以至于在相当广泛的范围内践行自己受开源文化影响的理念。</p>
<p>我认为，分析开源共同体参与者的动机，以发展开源共同体的目的来看，首先要关注组织驱动类型的动机。这种类型的占比最大，且能够提供成建制的投入，帮助开源共同体壮大自身。当然，不是所有的开源软件都要成为类别杀手，不是所有的开源软件都要不断壮大，作为实用工具和胶水层的开源项目也是支撑起整个开源生态不可缺少的部分。</p>
<p>对于所有的开源共同体来说，必须发展的是由自我驱动类型的动机参与的成员。他们未必是一开始就完全是自我驱动的，项目本身的价值，参与过程的反馈，声誉对参与者社交需要、尊重需要和自我实现需要的满足，以及开源文化熏陶下的思想转变，这些契机有可能让一个潜在的核心参与者觉醒，并产生自我驱动的动机。发现这样的人，并适当引导成为共同体的核心成员，能够极大地增强共同体的生命力和号召力。</p>
<p>直接利益的动机可以作为辅助手段使用，但是应该顺应实际需要，且不必抱有太高的期待。</p>
]]></content>
      <tags>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>Engula 开源共同体观察报告</title>
    <url>/2021/12/05/engula-community-observation/</url>
    <content><![CDATA[<p>Contributor 参与开源共同体的过程一定会问两个问题，第一个是我能为你做什么，第二个是我该怎么做到它。本文以观察报告的形式总结了我在参与 <a href="https://engula.io/">Engula</a> 开源共同体期间的体会，以及 Engula 现有的部分切入点，可以作为想要参与的同学的参考。</p>
<p>Engula 的设计目标是一个弹性、自适应、可扩展、平台无关的 serverless 存储引擎。基于 Engula 可以实现高可靠且高性价比的数据处理逻辑，例如数据库。Engula 从今年八月份开始以开源协同的方式发起，所有代码以 Apache 2.0 协议授权，使用 Rust 语言开发。</p>
<span id="more"></span>

<p>“好的软件作品，往往源自开发者的个人需要。”这句话对于 Engula 而言也是成立的。因为看到了云原生时代单机系统演进为集群系统的趋势，深感于云数据库等数据处理逻辑在新时代下重复实现存储引擎的冗余，Engula 将存储系统的基本功能模块化后就云环境做了针对性设计，从而支持后来的开发者在实现云环境的数据处理逻辑时，能够有开箱即用的存储系统功能，例如共识、复制、缓存、压缩等等，以及针对不同功能的不同资源配置。</p>
<p>今年十月份，Engula 发布了<a href="https://engula.io/posts/demo-1">概念验证报告</a>。目前概念验证阶段已经结束，共同体成员正在主分支上以发布第一个原型版本为目标快速迭代。</p>
<h2 id="Engula-开源共同体的沟通"><a href="#Engula-开源共同体的沟通" class="headerlink" title="Engula 开源共同体的沟通"></a>Engula 开源共同体的沟通</h2><p>讨论具体的项目内容之前，我想先介绍一下 Engula 开源共同体的沟通手段。这样，在讲到具体的参与切入点的时候，你也能知道应该以什么方式与其他成员沟通。</p>
<p>目前，Engula 所有正式的讨论和开发都发生在 GitHub 上。<a href="https://github.com/engula/engula">项目代码</a>不用说当然托管在 GitHub 的代码仓库里。工作项以 issue 记录，代码评审基于 pull request 来做。</p>
<p>值得一提的是，Engula 主仓库开启了 GitHub Discussion 功能。这是一个进行开放式讨论或者提问解答的小型论坛，取代了其他开源项目常见的邮件列表或者 Discourse 论坛的功能。类似于 Apache 孵化项目一开始只有一个 dev 邮件列表，目前 Engula 的 Discussion 论坛也只有开放讨论形式的 General 目录和问答形式的 Q&amp;A 目录。虽然 General 目录下的讨论主题很泛化，比如 Journal 或 Cache 等，但是我认为这些并不起到目录的作用。也就是说，如果你有关于 Journal 的问题要问，或者灵感要分享，不是一定要在那个主题下回复，而是完全可以另起一个主题来讨论。实际上，我更倾向于类似邮件列表体验的大量简短且能收敛的讨论，而不是一个大而全什么都聊的主题。后者很容易丧失焦点并且难以输出价值。</p>
<p>另外，作为非正式沟通和即时通讯需要的补充，Engula 共同体创建了 <a href="https://engula.zulipchat.com/">Zulip 聊天室</a>。这跟 Rust 共同体的选型是一样的，并且由于是开源项目，Zulip Cloud 提供了免费的支持保存所有聊天记录的标准服务。需要注意的是，正式的讨论和开发仍然需要记录在 GitHub 上，其他所有渠道的讨论都是辅助性的。关注共同体运营的同学可以看看<a href="https://github.com/engula/engula/discussions/141">有关即时通讯工具选型的讨论</a>，后续我也会针对开源共同体的沟通发布一篇文章。</p>
<h2 id="Engula-v0-2"><a href="#Engula-v0-2" class="headerlink" title="Engula v0.2"></a>Engula v0.2</h2><p>“早发布，常发布，倾听用户的反馈。”这是开源软件开发的最有效方式。对于 Engula 这样新发起的项目来说，发布第一个可用版本，将允许参与者在一个最小可行的基础上持续开发。否则所有设计都不过是思想实验，拿不出可行的软件，参与者的热情也将被消磨殆尽。</p>
<p>由于 Engula 在概念验证阶段使用了 0.1 的版本号，因此目前正在开发的第一个原型是 v0.2 版本。该版本的开发在 <a href="https://github.com/engula/engula/issues/57">RoadMap v0.2</a> 上追踪，预计将于今年十二月底发布。下面具体介绍目前的进展。</p>
<h3 id="存储引擎内核"><a href="#存储引擎内核" class="headerlink" title="存储引擎内核"></a>存储引擎内核</h3><p>v0.2 版本计划包含的主要内容就是存储引擎内核，包括底层的 Journal 和 Storage 抽象，这两者的上层封装 Kernel 抽象，以及存储引擎的用户接口 Engine 抽象。</p>
<p>在过去的一个半月里，共同体成员针对这些抽象做了不少讨论和原型设计。目前，这些实现正在朝着一个可发布的状态迭代，包括基于内存的实现，基于本地文件的实现，以及基于 gRPC 协议的实现。项目的发起人 @huachaohuang 正在总结之前的讨论，沉淀出反应 v0.2 设计的设计文档。相关的主题和工作项如下。</p>
<ul>
<li><a href="https://github.com/engula/engula/issues/57">Roadmap v0.2</a></li>
<li><a href="https://github.com/engula/engula/issues/65">Roadmap v0.2 - Journal</a></li>
<li><a href="https://github.com/engula/engula/discussions/70">Discussion: Journal</a></li>
<li><a href="https://github.com/engula/engula/issues/68">Roadmap v0.2 - Storage</a></li>
<li><a href="https://github.com/engula/engula/issues/145">Roadmap v0.2 - Kernel</a></li>
<li><a href="https://github.com/engula/engula/issues/73">Roadmap v0.2 - Engine</a></li>
<li><a href="https://github.com/engula/engula/discussions/55">Discussion: API</a></li>
<li><a href="https://github.com/engula/engula/pull/132">docs: rewrite the design document</a></li>
</ul>
<p>主题讨论是开放式的，工作项则是相对确定的。欢迎熟悉存储引擎开发的同学参与到讨论中来，review 抽象的设计。对于上面工作项里具体的待实现内容，也欢迎想要参与 Engula 的同学一起开发。</p>
<h3 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h3><p>项目发起之初，我们就开始讨论<a href="https://github.com/engula/engula/discussions/32">如何高效地开发 Engula 项目</a>。对于正在朝着第一个发布版本努力的 Engula 来说，我们并不需要复杂高端的开发流程，而是适合当下需要的简洁有效的手段。</p>
<p>目前有一个<a href="https://github.com/engula/engula/issues/144">关于版本发布的工作项</a>正待解决，我先引用之前的讨论回复了<a href="https://github.com/engula/engula/discussions/32#discussioncomment-1561701">开源项目发布的整体关注点</a>和 <a href="https://github.com/engula/engula/discussions/32#discussioncomment-1561991">v0.2 版本的极简发布策略</a>。如果你有相关的项目发布经验，也欢迎参与到这个工作项当中来，一起发布 v0.2 版本。我想在版本发布之后，会总结一个版本发布手册，也确保任何人都能够从代码仓库开始复现发布产物。</p>
<p>项目开发所需要的持续集成流水线已经基于 GitHub Actions 搭建起来了。对于托管在 GitHub 上的开源项目来说，这是一个非常方便的持续集成实现。有时间我会展开讲讲相关的知识和最佳实践。持续集成的另一面是如何在本地进行验证，我在<a href="https://github.com/engula/engula/issues/150">这个议题</a>下有相关的回复。如果你有高效的开发实践，欢迎加入分享。</p>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>上面提到，Engula v0.2 发布将是一个可用版本。它设计上提供两种使用方式，一种是作为三方库内嵌使用，这类似于 RocksDB 的用法，另一种则是作为服务提供，用户使用客户端与存储服务交互。</p>
<p>对于后一种使用方式，Engula 需要提供命令行工具以简化部署、启停、基础交互等操作。最基础的，需要有一个二进制文件来启动基于 gRPC 协议的 Engula 服务。进一步的，类似 CockroachDB 或 Docker 的命令行工具，优雅的实现支持不同操作一行命令完成。</p>
<p>目前，Engula 使用 <a href="https://github.com/clap-rs/clap">clap-rs</a> 库来封装自己的命令行工具。设计哲学方面则参考自 <a href="https://clig.dev/">Command Line Interface Guidelines</a> 文档。欢迎 CLI 爱好者一起讨论 Engula 的需要，打造一个让人爱不释手的命令行工具。</p>
<h3 id="集群服务部署"><a href="#集群服务部署" class="headerlink" title="集群服务部署"></a>集群服务部署</h3><p>原本的 v0.2 版本计划中，包括实现 Engula 部署到集群环境中的功能。但是基于开发周期的考虑，第一个原型版本只要在本地环境可以使用就应该发布。所以集群服务部署的内容被延迟到下一个开发周期当中实现和交付。v0.2 版本仍然会交付直接在本地环境启动 Engula 服务的能力，但是集群部署或者说与云环境集成的部署能力，将不会包含在 v0.2 版本当中。</p>
<p>关于集群服务部署的话题，前几天有参与者问我有什么相关材料可以学习，我在这里也做一个回答。目前看来，Engula 服务在集群上部署的时候，直接打交道的应该 Kubernetes 或者 YARN 一类的集群管理系统，而不是重新实现一遍 Kubernetes 直接跟物理机或容器打交道。</p>
<p>在此前提下，我能想到的两种实现集群服务部署的方向，一个是实现资源申请和调度的抽象，另一个是在主要支持 Kubernetes 平台部署的前提下，利用 Operator 等平台提供的机制进行部署。我倾向于后者。</p>
<p>前者实际上是为 Engula 服务实现了一套自己的集群管理逻辑，把 Kubernetes 或 YARN 当成资源提供方，申请到资源后转换成自己的资源抽象，并实现调度和部署。这样做的好处是有一层抽象隔开了 Engula 资源管理逻辑和不同的集群环境，实质是一个双层资源调度，能够提供额外的定制空间。缺点是设计实现极其复杂，并且为了用上底层集群环境的功能，实际上做到最后会变成底层集群环境接口的超集。如果做成简单的抽象，则会损失很多底层集群环境本来能够提供的能力。</p>
<p>后者基于 Kubernetes Operator 的能力，把 Engula 服务作为定制资源调度起来。这种设计下，Engula 存储引擎内核对集群服务部署是无感知的，完全由 Operator 来决定最终的 Engula 服务的拓扑结构。资源管理和集群管理都由 Operator 切面来完成，而 Engula 存储引擎内核的各个模块则像运行在多个物理机上一样，通过发现服务相互连接和通信。</p>
<p>关于 Kubernetes Operator 的相关材料，推荐阅读以下内容。</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">Operator pattern</a></li>
<li><a href="https://www.redhat.com/en/topics/containers/what-is-a-kubernetes-operator">What is a Kubernetes operator?</a></li>
<li><a href="https://github.com/cncf/tag-app-delivery/blob/main/operator-wg/whitepaper/Operator-WhitePaper_v1-0.md">CNCF Operator White Paper</a></li>
</ul>
<p>同时，虽然倾向于不实现另外一套集群管理逻辑，但是无论如何集群服务部署要跟集群管理系统打交道，Engula 服务层面也会有应用集群的管理逻辑。推荐阅读以下材料掌握一些基础知识。</p>
<ul>
<li><a href="https://doc.akka.io/docs/akka/current/typed/cluster-concepts.html">Cluster Specification</a></li>
<li><a href="https://kubernetes.io/docs/concepts/architecture/">Cluster Architecture</a></li>
<li><a href="https://blog.cloudera.com/resource-localization-in-yarn-deep-dive/">Resource Localization in YARN: Deep Dive</a></li>
</ul>
<h2 id="Engula-开源共同体的发展"><a href="#Engula-开源共同体的发展" class="headerlink" title="Engula 开源共同体的发展"></a>Engula 开源共同体的发展</h2><p>开源共同体的核心是开源软件，因此它的发展肯定也离不开软件本身的演进。这一点在上面已经讨论了不少。针对围绕软件形成的共同体的运行，我之前做过一个 <a href="https://github.com/tisonkun/engula.github.io/blob/85350e76644a7d28049dfc7cb32e2dad03f84abf/docs/posts/community-project.md">The Engula Community Project</a> 的提案，里面有我对打造一个新的开源共同体的思考，欢迎阅读。</p>
<p>由于这个提案本身不是一种硬性的承诺，其中的提议也需要共同体成员认可和实际执行才有效，所以我不再计划把它发布到 Engula 的网站上，而是针对每一个关键的提议，以 contributor 文档或共识的方式逐个落实到 Engula 开源共同体当中。</p>
<p>我希望 Engula 能够成为发源于本土的优秀开源共同体，不仅作为一个 serverless 存储引擎创造技术价值，也是开源协同模式下健壮成长的标杆。</p>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>Engula</tag>
      </tags>
  </entry>
  <entry>
    <title>《开放式组织》书评</title>
    <url>/2021/12/05/open-organization/</url>
    <content><![CDATA[<p>本文部分启发自在 <a href="https://alc-beijing.github.io/alc-site/">ALC Beijing</a> 录制播客时讨论的内容，仅引用我个人的观点。播客内容应该近期会在前面链接的网站上发布。</p>
<p><a href="https://book.douban.com/subject/26894636">《开放式组织》</a>这本书单看它本身，讲的是红帽公司的组织管理经验。这是一个将商业价值建立在开源项目之上的公司审视公司内部的组织形式的著作，并且主要关注在红帽这个案例上。这样，不管是在经验的普遍性上，还是在开放式组织这种形式跨越组织，尤其是建立商业公司和开源社区之间的联系这方面的讨论上，都有所欠缺。</p>
<span id="more"></span>

<p>从理论到实践，从企业审视内部到跨越组织边界，连接商业公司和开源社区，这样一个广义上的“开放式组织”阅读主题，我推荐以下几本书共读。</p>
<ul>
<li><a href="https://book.douban.com/subject/27125968/">《企业的人性面》</a></li>
<li><a href="https://book.douban.com/subject/34834429/">《协同》</a></li>
<li><a href="https://book.douban.com/subject/26976995/">《社区运营的艺术》</a></li>
<li><a href="https://book.douban.com/subject/35531548/">《用户共创》</a></li>
</ul>
<p>《企业的人性面》我认为是《开放式组织》背后的理论基础，成书于 1960 年，历久弥新。《协同》是国内学者关注“内破部门墙，外拓企业边界”的研究跨越组织边界合作的当代著作。《社区运营的艺术》和《用户共创》均出自 Ubuntu 社区经理 Jono Bacon 之手，讨论了开源社区这一开放式组织的运行方式与最佳实践。这几本书都是阅读《开放式组织》的有益补充。</p>
<h2 id="为什么要理解开放式组织这种形式？"><a href="#为什么要理解开放式组织这种形式？" class="headerlink" title="为什么要理解开放式组织这种形式？"></a>为什么要理解开放式组织这种形式？</h2><p>这个问题也是计划中的“开源协同”系列文章里会展开讨论的问题，这里做简略的回答。这个问题在《开放式组织》里没有直接讨论，而是作为已知假设。然而，这个问题却是想在国内推行开放式组织这种管理模式首先要回答的问题。</p>
<p>本书涉及这个问题的一句话</p>
<blockquote>
<p>我们发现，开发开源软件的最佳方法同样也非常适用于管理整个公司。</p>
</blockquote>
<p>也就是说，开放式组织就是开发开源软件时协调开发团队或者说开源社区的组织管理手段。我喜欢将开放式组织这种组织管理手段简称为“开源协同”。开源软件在开源协同的生产力加持下，在不同领域攻城略地，击溃了专有软件的统治。如果企业想要基于开源软件打造商业价值，那么它就必须了解开源软件。在这种情况下，传统的控制管理模型会导致企业和开源社区激烈的摩擦。要想获得生产力的提升，企业必须成为开放式组织。</p>
<p>这种摩擦来自于时代发展带来的对于组织管理的颠覆。《协同》当中提到的“强个体的价值崛起”，以及《用户共创》当中提到的“社区成员为社区工作，而不是为商业公司工作”都是这一点的佐证。如今，开源社区有能力依靠其同侪社区当中强大的个体打造高价值的软件，其力量足以支持 Linux 赢下服务端操作系统，支持 Rust 成为富有竞争力的系统级编程语言，支持 PostgreSQL 成为世界前列的数据库软件。开源社区及其成员无需依赖于企业尤其是单一企业的控制而生存。因此，他们可以坚持为社区工作，而不是为商业公司工作。</p>
<p>在这种情况下，如果坚持传统的控制管理模型，试图将社区成员驯化成免费劳动力，必将破坏可能的跨越组织边界的合作的信任基石，回退到商业公司雇佣一批员工实现一个本身即是产品的软件。前文说到，开源软件得益于开源协同的生产力加持，正在不同领域中击溃专有软件的统治。在这一背景下，仍然希望聚集起一批员工写出足以媲美开源软件的专有软件，是不太现实的。绝大部分情况下，你无法聚拢起比拟开源社区的专家团队。<a href="https://book.douban.com/subject/2265341/">《维基经济学》</a>当中提到，“唯一有资质做出新发现的人可能在他的组织范围之外”，这将是越来越常见的情况。</p>
<p>《开放式组织》并没有过多的讲这部分内容，因为红帽已经走过了这个阶段。要想跟 Linux 社区达成最好的协同，乃至形成某种意义上的“原厂”品牌，必须以开放式组织的形式运作。本书更多的是讲在已经要运行一个开放式组织的前提下，如何发挥这一组织形式最大的生产力。其实作者 Jim 已经在第一章中提到过，他一开始也试图以传统的控制管理模型来管理红帽公司，但是开放式组织的力量已经不可阻挡，正如开源社区这一开放式组织的力量也不会以商业公司的意志为转移一样。于是他开始学习、理解并运用开放式组织的形式来释放红帽公司员工的生产力。</p>
<h2 id="如何点燃工作热情？"><a href="#如何点燃工作热情？" class="headerlink" title="如何点燃工作热情？"></a>如何点燃工作热情？</h2><p>开放式组织具体的管理策略和<a href="https://book.douban.com/subject/30356081/">《奈飞文化手册》</a>所介绍的准则多有共通之处，其理论基础则都很可能来自《企业的人性面》当中提到的企业管理的 Y 理论。</p>
<p>点燃工作热情是这类组织要面临的第一个挑战。《奈飞文化手册》写到，“成年人最渴望的奖励，就是成功”。《开放式组织》在本章中也提到</p>
<blockquote>
<p>你需要一个能让大家时刻铭记在心的目标，而不只是停留在追求利润这个层面上，这是吸引顶尖人才的唯一方法。</p>
</blockquote>
<p>如果利用马斯洛的需求层次理论来分析，这是要求激发员工对尊重和自我实现的需要的追求。传统的控制管理模型压抑员工的安全需要乃至生理需要的满足，主要使用金钱和职位来激励员工，但是这种激励不能持续。不仅仅是因为员工得到满足后激励作用就会消失，更因为商业公司无法持续用金钱和职位激励每一位员工。与之相反，开放式组织不会压迫员工的生理需要和安全需要，而是激发新时代高价值的强个体的热忱和渴望，也即点燃工作热情来发掘被压抑而无法释放的生产力。</p>
<p>值得注意的是，本章名为“构建充满热情的工作环境”，对于如何做到上面提到的激发热忱和渴望，书中的论调也是</p>
<blockquote>
<p>对于管理者而言，如今最重要的任务就是建立一个启发思考、培育积极的投入精神，并且推崇无限热情、想象力和主动性的工作环境。</p>
</blockquote>
<p>也就是说，组织管理要做的是构建环境。虽然需要关注个体在环境中的发挥来校正对环境状况的认识，但也不用过分纠结某一个人的热情是否点燃。一个人没有热情，是很难点燃出热情的，根本就不可燃。管理者能做的是破除环境当中压抑了人原本的热情的限制条件，释放原本就存在的工作热情。</p>
<p>这一思路也出现在《企业的人性面》当中，书中对比纠结个体，试图利用一致的模式创造标准化人才的“制造”手段，提出了人才的“栽培”方法。</p>
<blockquote>
<p>个人将成长为他可以成为的样子，只要为他们创造适当的成长环境。</p>
</blockquote>
<p>也就是说，开放式组织基于对个人价值的认可和个人能力的信任，致力于创造出能点燃员工工作热情，积极投入工作的环境。</p>
<h2 id="如何提高员工的参与度？"><a href="#如何提高员工的参与度？" class="headerlink" title="如何提高员工的参与度？"></a>如何提高员工的参与度？</h2><p>首先自己要参与，而不是作为一个局外人去提升其他员工的参与度。《开放式组织》当中写到，“想要得到，就先要付出”，就是对每个希望提高员工参与的成员提出的建议。</p>
<p>《企业的人性面》当中花了一整章的篇幅讨论何为参与以及如何参与。根本是要树立诚信，员工能够真正地参与到事务活动和决策中来，整个旅程没有破坏安全感和信任的坏例子。</p>
<p>假模假样的号召参与，实际并不采纳意见等仍然遵循控制管理模型的做法，并不能够瞒天过海，反而是失掉员工的信任，进而整个提高参与度的努力都会失败。</p>
<h2 id="何为精英领导制？"><a href="#何为精英领导制？" class="headerlink" title="何为精英领导制？"></a>何为精英领导制？</h2><p>本书的第四章、第五章和第六章都聚焦在如何做决策这个议题上，而开放式组织从开源社区当中借鉴到的决策方式，自然是精英领导制。</p>
<p>《开放式组织》很有价值的一点在于对比了精英制度和民主制度，并明确地指出了精英制度不同于民主制度的要点。</p>
<blockquote>
<p>精英制度是指根据提出的最佳方案做决定的方式；才能是选择的唯一标准，而非地位、偏见或特权。在一个公民公司里，最优的行动方案是在公开、充分、信息量足够的辩论之后胜出的方案。精英就是每一个有思想、有知识的人，每一个在真正理解之后得出的好想法都会得到重视。毫无才华的吹牛皮之人不会得到尊重。实施了精英制度之后，参与性民主必然将权利转移至最低一级人群的说法也将不攻自破。</p>
</blockquote>
<p>许多开源社区做得不好的一点，就是太强调平等乃至于变成平均主义。其实社区成员积累社会资本，应该是一个 earn authority 的过程，积极主动的 contribution 获得别人的尊重，而不是凑人头投票决策。</p>
<p>Linus 多次表示自己他只以技术论高低，PostgreSQL 社区和 Apache 社区推选新的 Committer 时是核心成员闭门会决议后公示，都是反对民粹的体现。开源社区的公平是基于 contribution 赢得权威的精英领导制，遵守 earn authority by contribution, not by position 的原则。近年来不少开源社区的维护者不堪民粹道德绑架的压力频频爆出“开源世界的暗面”，就是没有形成健康的精英领导制的认知。</p>
<p><a href="https://www.bilibili.com/video/BV1454y1E7xp">Linus Torvalds: 我不在乎政治正确，我只在乎技术本身</a></p>
<p><a href="https://www.bilibili.com/video/BV19f4y1F7QQ">荣耀还是负担？开源大神们居然这么累</a></p>
<h2 id="开放式组织是不是未来唯一的或者最高级的组织形式？"><a href="#开放式组织是不是未来唯一的或者最高级的组织形式？" class="headerlink" title="开放式组织是不是未来唯一的或者最高级的组织形式？"></a>开放式组织是不是未来唯一的或者最高级的组织形式？</h2><p>最后，我想讨论一下这个问题。因为在我讨论开源项目和开放式组织的话题的时候，经常会有人举单一反例，以开源项目和开放式组织如果不是普适的那么就是错的这种无厘头逻辑，来搅乱讨论的氛围。</p>
<p>对于这个问题的答案，我只能说不是。开放式组织是一种选择。控制管理模型也有适合它的军队或教会等组织，前面已经讨论过需要理解开放式组织的原因。现在仍然有专有软件领跑某个领域，仍然有技术领先的源码可得的专有软件开放 API 或允许带有限制的修改，如果你的商业模式适用于这些形式，大可不必采用开放式组织的形式。</p>
<p>但是，软件复杂度将不断提高，基础软件乃至其部分再也无法仅凭一个人或一个公司的全体员工来编写。开源社区这种跨越组织边界，凝聚不同背景专家共同开发的形式，将会生产出高质量的软件，成为事实标准并击溃专有软件。这样的事情正在持续不断的发生。所以至少这个领域的企业，应当理解和采取开放式组织的形式。这种形式也是当前开源社区唯一成功的组织形式。</p>
<h2 id="红帽公司的管理原则"><a href="#红帽公司的管理原则" class="headerlink" title="红帽公司的管理原则"></a>红帽公司的管理原则</h2><ol>
<li>因为想来，所以加入我们。</li>
<li>贡献是决定性因素，但不是交换条件。</li>
<li>不论由谁提出，只要是最好的想法就能胜出。</li>
<li>我们鼓励并且期待开放、坦诚、充满热情的辩论。</li>
<li>我们欢迎反馈意见，本着“早发行，勤发行”的精神做出改变。</li>
</ol>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>大图书馆</tag>
        <tag>组织管理</tag>
      </tags>
  </entry>
  <entry>
    <title>高效参与开源的诀窍</title>
    <url>/2021/12/05/effective-open-source-participant/</url>
    <content><![CDATA[<p>大部分人参与开源社区会面临的一个巨大挑战，那就是缺乏时间。本文试图提供一种方式，帮助想要参与开源社区的同学高效利用有限的时间。</p>
<p>在一个开源社区里，maintainers 需要关注的范围比 contributors 要大得多。本文分别讨论这两类人群适用的参与开源社区的技巧，以减少过程中的摩擦，提高时间的利用率。</p>
<span id="more"></span>

<h2 id="Contributors"><a href="#Contributors" class="headerlink" title="Contributors"></a>Contributors</h2><h3 id="第一步要加入社区"><a href="#第一步要加入社区" class="headerlink" title="第一步要加入社区"></a>第一步要加入社区</h3><p>参与开源社区的第一步就是加入社区。加入社区的方式有很多，可以订阅邮件列表，关注开发活动，参与技术或非技术讨论，等等。很多希望参与开源社区的人迟迟迈不出第一步就是忽略了自己首先要加入社区，跟社区建立起联系。</p>
<p>一个典型的错误做法是完全不顾开源社区是开发开源项目的主体，一头钻进技术细节里，暗搓搓地做一个“大功能”，然后希望社区尽快合并这个补丁，让自己得到荣誉。</p>
<p>Linux Foundation 有一篇博文明确反对了这种做法。</p>
<blockquote><p>Some organizations make the mistake of developing big chunks of code in house and then dumping them into the open source project, which is almost never seen as a positive way to engage with the community. The reality is that open source projects can be complex, and what seems like an obvious change might have far reaching side effects in other parts of the project. Any significant change is likely to require some community discussion before it moves to implementation to make sure that there are no side effects and that the solution is aligned with the broader goals for the project. While you discuss it with the community, it can help to focus on the problem, rather than a specific solution, before you invest too much time in the creation of a body of code.</p>
<footer><strong>Linux Foundation</strong><cite><a href="https://www.linuxfoundation.org/tools/participating-in-open-source-communities/">Participating in Open Source Communities</a></cite></footer></blockquote>

<p>一个现实的例子，前几天有人问我，自己做了一个 Flink StateBackend 的实现，提交给社区是不是就能当 PMC 了。这个问题属实把我整不会了。从来没有在社区当中亮相的人，突然出现并提出自己实现了一个“大功能”，在其他成员眼里跟民科没什么不同。绝大部分情况下，这种实现跟上游社区的开发节奏是脱节的，很难合回去。也就是说，闭门造车的形式自我感动地开发项目，即使花费了时间，大概率还是白忙一场。</p>
<p>刚开始接触 Flink 社区的时候，我就按照项目文档的提示订阅了 users 和 dev 两个邮件列表。实话说，最初的三个月，我基本看不懂他们在说什么。当时的我尽可能地读每一封邮件，从邮件里面引用的链接一个个点进去了解背景，混沌当中建立起对项目的初步印象。直到四个月后第一次提交代码，这个祛魅的过程才算完成。从此以后，我逐渐能够轻松地参与到技术讨论，也掌握了 review 的沟通习惯。</p>
<p>最近，我在跟人介绍 Engula 项目的时候，也是先发<a href="https://github.com/engula/engula/discussions">讨论区</a>和<a href="https://discord.gg/AN6vgVXaHC">聊天室</a>的链接。新成员可以阅读过往的讨论，挂在聊天室里，观察社区讨论问题和推进工作的方式，了解已有的设计实现和结论。参与闲聊或者回复感兴趣的话题，找到自己愿意投入的工作。只有这样，才能进一步深入参与开源社区，而不是接触了好几年，却始终迈不出第一步。</p>
<h3 id="找到感兴趣的问题"><a href="#找到感兴趣的问题" class="headerlink" title="找到感兴趣的问题"></a>找到感兴趣的问题</h3><p>要想利用有限的时间创造更多价值，最好的方法是找到一个感兴趣的问题，然后持续投入进去直到解决。</p>
<p>一个典型的错误做法是强迫自己做着不感兴趣的工作。这种情况下，由于内心是抗拒的，即使投入再多的时间，也几乎不会有产出。</p>
<p>可能有人会不理解，开源社区的 contributor 都是自愿参与，如果不想做某个工作，不是不做就可以了吗。其实不然，社区成员身处其中很容易感受到无形的社交压力。</p>
<p>一种情况是不懂得拒绝。知乎上有个问题，<a href="https://www.zhihu.com/question/475269038/answer/2045981148">如何优雅地拒绝开源项目的 PR 邀请</a>，讲的就是这种情况。我在回答里分享了一个自己拒绝 Flink 社区成员里的 PR 邀请的案例。另一种情况是错误估计难度，即自以为能搞定这个工作，做的过程里发现不对，又不好意思改口说自己搞不定。应对这些情况的方法非常简单，直截了当地说明情况即可，解放自己避免浪费时间。</p>
<p>另外一个难题是自己往往对比较有挑战性的工作感兴趣，但是从一个刚接触项目的 contributor 到能够完成一个复杂任务之间有一道坎。</p>
<p>要跨过这道坎，同样需要积极采取行动，而不要独自纠结。首先可以考虑从简单的工作入手，比如阅读项目文档时发现的拼写错误。一个简单的贡献能带你走完整个 contribution 流程。一回生二回熟，做其他有挑战性的工作也就不会在流程上踩坑。其次可以保持和 maintainers 的交流，以了解现有逻辑的设计背景和演进过程。只有对工作涉及的逻辑有充分的了解，才能写出高质量的代码。高质量的代码也意味着更少的返工和不必要的争论，也就避免了时间的浪费。</p>
<h3 id="建立与其他成员的联系"><a href="#建立与其他成员的联系" class="headerlink" title="建立与其他成员的联系"></a>建立与其他成员的联系</h3><p>随着参与的深入，总有你一个人无法完成的工作。开源协同的价值就在于跨越所属组织的边界合作开发项目。合作的基础是成员之间的信任，也就是良好的关系。</p>
<p>开源社区是围绕开源软件建立起来的。但是并不只有软件本身带来技术价值，人与人的连结带来认同感和归属感，这些也能满足社区成员的需要。此外，相互信任的基础能很大程度提升价值创造的效率，例如减少浪费在同步和对齐上的时间。因此，建立并保持与其他项目成员的关系至关重要。</p>
<p>做到这一点的方式就是充分的沟通。同样，这需要以开放的心态对待平时的交流。不要把所有事情都憋在心里。不要纠结于想清楚所有细节再开始沟通，其他成员一时间内往往没办法追上你所想的所有细节。我的建议是，当你有一个初步的想法，也做了力所能及的调研，就可以整理一下，发布到社区当中征求意见。</p>
<p>我给 Engula 项目做了一个<a href="https://github.com/engula/engula.github.io/pull/15">社区计划</a>。老实说，内容并不成熟，但是我一个人干想也得不出结论，所以在经过几轮自我 Review 以后，就先抛出来征求意见。另一个例子是 Engula 的 maintainer @huachaohuang 想为 contributor 提供开发文档，于是就发起了一个<a href="https://github.com/engula/engula/discussions/84">关于 Dev Guide 的讨论</a>。正好我对这个话题也早有想法，当我看到发出来的讨论以后，发现他也在关注这个话题。于是我花了一个小时把自己的想法写下来，经过讨论以后提 PR 推进主分支。</p>
<p>沟通协作的过程里冲突在所难免。我在好几个项目里都别人讨论甚至争论过很多次技术问题，给别人的行为提过意见，也夸赞过好的做法。开源社区解决冲突的方式比较朴素，一般是有话直说，尽量客观地达成共识，按照流程约定做出决策。不用整那么多弯弯绕浪费时间。</p>
<p>举一个现实的例子，曾经有人跟我抱怨提上去的 PR 被 maintainer 挑战了，问我应该怎么回复。怀疑 maintainer 是不是有偏见，抱怨很难跟 maintainer 沟通，大量的时间精力浪费在纠结这些臆想出来的问题，自然是筋疲力竭，感觉在开源社区里寸步难行。</p>
<h3 id="适合参与开源协同的工作"><a href="#适合参与开源协同的工作" class="headerlink" title="适合参与开源协同的工作"></a>适合参与开源协同的工作</h3><p>最后，关注到相当一部分 contributors 的公司员工的身份。这显然会影响到他们参与社区的动力和能力。</p>
<p>主要的挑战是，如果工作期间不允许参与开源社区，同时工作本身已经消耗了太多的时间精力，那么 contributors 对参与开源社区也只能是有心无力。这其实是很长一段时间里开源社区的参与在国内发展缓慢的原因。大量的开发者都在过度工作，下班只想躺平休息，没有动力再谈什么开源贡献。</p>
<p>不过，随着时间的发展，情况也在发生着变化。越来越多的公司采用更加灵活合理的工作时间，尤其是以研发为核心竞争力的公司。如果你所在的公司仍然要求超负荷工作，燃烧生命赚血汗钱，那么是时候找份新工作了。时代已经变了，就让这些公司被无情的淘汰吧。</p>
<p>另一个方向是考虑在工作期间参与开源社区。如果你确实喜欢某个开源项目，那么最佳策略就是找一份允许你全职投入这个项目的工作。这样的工作岗位如今并不少见。尤其是随着企业级解决方案越来越倾向于采用开源组件，企业对熟悉开源软件的人才的需求只会日益增加。如果找不到全职投入开源项目的工作，与之相关的工作也是备选方案。</p>
<p>不过，即使这份工作允许你全职投入开源项目，也并不意味着你能够参与开源社区。特别是当你的老板认为参与开源社区不能为公司创造价值的时候。面对这个问题，首先你可以问问你的老板，说不定他不这么觉得，那就省事儿了。如果你的老板确实难以理解，那你就得像兜售一个技术方案一样向他宣传参与开源社区的价值了。我在其他的文章里对这一点已经有不少讨论，你可以看看。</p>
<p>普适的时间管理手段这里就不展开介绍了，各种相关书籍和 GTD 方法论都很值得一看。</p>
<h2 id="Maintainers"><a href="#Maintainers" class="headerlink" title="Maintainers"></a>Maintainers</h2><h3 id="发展新成员"><a href="#发展新成员" class="headerlink" title="发展新成员"></a>发展新成员</h3><p>Maintainers 比起 contributors 需要关注的更多的事情。随着开源项目日渐复杂，开源社区逐渐成长，单靠一个人的力量很难处理好所有的事务。这个时候，就需要 maintainer 适时地发展项目维护的队伍。</p>
<p>首先需要理清 maintainer 头衔的定位。实际上，大部分项目的维护是个苦力活，而 maintainers 就是一群承担这些工作的社区成员。Maintainers 可能会拥有合并 PR 的权限，在社区治理中能投票做决策，确定项目发展的方向。但是，这种权限并非特权。在一个健康的社区里，任何社区成员都可以做技术讨论，也可以就社区发展话题提出自己的观点。对于技术观点，客观上更加合理的方案理应被采纳。对于社区发展话题，maintainers 也一定会考虑建设性的提议。</p>
<p>可能有不少人把成为 maintainer 当成参与开源社区的目标，这是很好的。如果你理解了 maintainer 的职责，通过 contribution 积累了足够的信誉，成为 maintainer 为开源社区服务，这个头衔是一个显式的认可。不过，大可不必过分纠结于 maintainer 头衔。这只是对 contribution 认可形式的其中一种，而不是唯一一种。</p>
<p>Maintainers 的职责并不轻松，所以 Python 社区和 Apache 软件基金会下的项目社区都会有一个询问 contributor 是否愿意成为 maintainer 的流程。也存在 contributor 拒绝邀请的情况，因为就像前面提到的，健康的开源社区里，只要提议是合理的，就能凭借其客观的优势胜出。成为 maintainer 并不意味着在方案选择上有特权。</p>
<p>对于 contributor 的感谢，也可以通过宣传渠道发布。比起一个模糊的 maintainer 头衔，作为技术人员，我会更在意这个人实际在开源社区里实际完成的事情。</p>
<p>基于上面的认识，我们引出下一个观点。Maintainers 发展新成员，必须是有选择性的。</p>
<p>这种选择性的主要依据是维护项目的需要，而不是追求数量或者过分在意 diversity 等等。这可以类比到开发软件的目的是提供技术价值，而不是代码行数或者所采用的编程语言的数量。</p>
<p>一个典型的错误案例是出于自己同时是公司员工的身份，被命令将 maintainers 的人数发展到某个数字。这种指标只关注数字而不关注具体的人，而且往往定得脱离实际。公司员工迫于指标压力很容易降低 maintainers 的标准，逮到一个算一个的凑人头，或者为了 diversity 对不同背景的 contributor 采取不同的标准。这样发展出来的 maintainers 不仅不能分担项目维护的职责，还很有可能因为不胜任而产生新的问题。</p>
<p>另一个典型的错误经常出现在个人项目上，当个人项目发展壮大，唯一的 maintainer 想要发展新成员时，很容易陷入到要找一个自己的分身的误区。 也就是说，新的 maintainer 必须和自己一样能够关注到项目的方方面面。这是不对的。没有两个人完全相同。只要一个 contributor 有足够的信誉，并且能在项目或社区的维护的某个方面上承担职责，他就是一个好的 maintainer 人选。</p>
<p>不过，这里讲到的信誉是一个非常主观的概念，提名 maintainer 的倾向每个项目也各有不同。</p>
<ul>
<li>Perl 社区最初由 Larry Wall 独裁。近年来，随着他逐渐淡出核心成员圈子，Perl 社区的治理实际上已经变成由 28 人组成的 core team 负责。</li>
<li>PostgreSQL 社区由 7 人组成的 core team 和 28 位 committers 处理所有工作。</li>
<li>ASF 治下的项目有一套比较固定的<a href="http://www.apache.org/foundation/how-it-works.html#roles">治理模型</a>。具体到每个项目，例如 <a href="https://pulsar.apache.org/en/contributing/#becoming-a-committer">Apache Pulsar</a> 和 <a href="https://flink.apache.org/contributing/how-to-contribute.html">Apache Flink</a> 会有自己具体的要求和倾向。</li>
<li>Spring Project 社区的 committers 都是 Pivotal 公司或 VMWare 公司的员工。但是它显然也是诞生于开源协同的作品。</li>
<li>Linux Kernel 基本上还是由 Linus 独裁。同时，海量的驱动和架构支持有各自的 maintainer 进行维护。参考 <a href="https://www.kernel.org/doc/html/latest/process/maintainers.html">Linux Kernel Maintainers 页面</a>。</li>
<li>Netty 社区没有明确的规则。Trustin Lee 发起项目并独自维护了三年。随后，Norman Maurer 和 Scott Mitchell 等少数几个人持续参与，成为 maintainer 并共同维护 Netty 项目至今。</li>
</ul>
<p>如果让我对 maintainer 提一个基础要求，我会希望他在项目或社区中做出了卓越的贡献，并且当前的 maintainers 团队乐于和他一起工作。</p>
<h3 id="结构化流程"><a href="#结构化流程" class="headerlink" title="结构化流程"></a>结构化流程</h3><p>除了增加项目维护的人员，另一个基本的减少时间浪费的手段就是结构化流程。我们分点介绍其内涵。</p>
<p><strong>第一点是直觉大于文档</strong>。对于托管在 GitHub 上的项目来说，help wanted 和 good first issue 标签是一个众所周知的约定。合理标记 issue 能让 contributor 按照过往的经验快速找到切入点。我在<a href="https://github.com/pingcap/community/issues/516">修订 TiDB 社区的治理方案</a>的时候，也是以跟 GitHub 开箱即用的功能亲和为主要目标之一。如果参与一个开源项目有太多新东西要学，那么 maintainers 就有的是要解释的东西了。大部分人效率最高的路径是完全凭直觉做事，并取得好的结果。所以如无必要，请勿设立复杂的规则。</p>
<p><strong>第二点是文档大于口述</strong>。直觉毕竟只能解决部分问题，对于特殊的或者需要强调的内容，明确记录下来作为文档绝对是个好主意。</p>
<p>不过文档首要的还不是记录流程，而是项目的目标或者叫定位。这是每个对项目感兴趣的人都会问的问题，高水平的 contributor 尤甚。他们不仅仅是想在开源社区里做简单的工作，更想成为一个伟大的或富有价值的项目的缔造者。如果你想为你的项目吸引到高水平的开发者，那么最好是确定一个清晰且令人振奋的目标，并将它展示在最显眼的地方。例如，Apache Flink 的定位是数据流上的有状态计算，其中有状态这点是开源世界里开创性的工作。例如，PostgreSQL 的定位是世界最先进的开源关系型数据库。例如，Elixir 语言的目标是构建可扩展和可维护的应用。</p>
<p>其次是约定俗成的文档，包括 README 和 CONTRIBUTING 等等。其中一般包含项目的简介，开始使用的方法，参与贡献的基本流程，和指向更多文档的链接。大部分 contributor 会尝试寻找和阅读这些文档。如果他们能从其中解决自己的问题，就不需要 maintainer 花时间说明了。至少，在有人提问的时候，直接发一个文档的链接，也能省不少事儿。</p>
<p>另一个值得强调的是 Code of Conduct 即行为准则。提名新的 maintainer 之前最好确保被提名人知悉和理解社区行为准则。行为准则通常是一些涉及平等、尊重和避免冒犯的原则。虽然大多数开源社区很少遇到严重违反行为准则的情况，但是 maintainers 应该对此保持敏感。这类问题一旦处理不当，很容易演变成政治斗争，甚至导致社区分裂或项目停摆。</p>
<p>最后是设计文档。Contributors 要深度参与技术贡献需要了解相关代码的设计背景和演进过程，设计文档就是最好的参考材料。良好的代码质量有助于避免 contributor 阅读源码时受挫，但是项目固有的复杂度还是需要设计文档来辅助解释。如果代码质量和设计文档都缺位，想要深度参与技术贡献的 contributor 就不得不指望 maintainer 花费大量的时间解释和指导了。这点对于 maintainer 自己也是一样的。当你想要做一个新的功能，如果没有好的技术文档，你也得懵圈，也得拉人反复对齐。</p>
<p><strong>第三点是避免私下讨论</strong>。有关项目和社区的讨论，唯一的信源应该是一个公开的渠道。例如，ASF 治下的项目要求所有有效的讨论都应该发生在邮件列表上。例如，大部分托管在 GitHub 上的项目隐含了讨论应该发生在 GitHub 平台上。社区成员可能还会通过其他的沟通渠道辅助交流，例如即时通信软件。但是这些辅助渠道的讨论需要被抄送到唯一信源上才实际生效。这样，contributor 才能在无需了解诸多渠道的前提下有能力获取所有有价值的信息。</p>
<p>这些公开讨论的内容以及表现出来的做事方式，就是社区当中的“活文档”。模仿是人类的天性，如果你希望别人遵循某种做事方式以减少冲突，那么最好以身作则，再带动更多的人跟随。前面讨论 contributor 的参与技巧时候说过，加入社区并首先观察别人是怎么做的，是一种避免浪费时间的好方法。那么与之相对的，maintainer 也要在项目维护和日常交流方面为此提供方便。</p>
<blockquote><p>Open Communications: as a virtual organization, the ASF requires all communications related to code and decision-making to be publicly accessible to ensure asynchronous collaboration, as necessitated by a globally-distributed community.</p>
<footer><strong>Apache Software Foundation</strong><cite><a href="https://www.apache.org/theapacheway/index.html">BRIEFING: THE APACHE WAY</a></cite></footer></blockquote>

<p><strong>第四点是考虑自动化</strong>。结构化的流程更容易自动化。当你的流程越来越结构化，那么是时候考虑自动化它了。显然，无需 maintainer 亲自动手的自动化流程能够减轻项目维护的压力。</p>
<p>同样，最好的自动化是符合直觉的。GitHub 平台提供了一系列自动化的支持。尤其是 <a href="https://github.com/features/actions">GitHub Actions</a> 发布以后，自动化的灵活性得到了进一步的提升。利用项目代码托管的平台提供的开箱即用的能力做自动化，能够最大程度的避免各种冲突。</p>
<p>自动化还应该建立在现有的成熟流程上，而不应该凭空生造一个流程。好的案例包括提交文档变更后自动部署文档页面，利用 merge bot 提高 pull requests review 和 merge 的效率等等。</p>
<p>其中，后者的采用是有两面性的。许多代码提交极其活跃的开源社区也仍然不需要引入自动化流程。当然，测试基本是自动化的，至少有脚本。不过 review 和 merge 还是可以人工完成的。我比较认同 merge bot 的地方是有些实现了排队合并功能以及 roll up 打包测试功能。这两个功能在保证合入主分支的代码是基于最新的主分支测试过的前提下，减少了需要进行测试的次数和人为协调的负担。但是，有些 merge bot 强制要求 review 和 merge 走非常严格的审批流程，把这个过程变得复杂不堪，这是我非常反对的。所以在引入 merge bot 之前，请确保你清楚地知道它如何改善协作效率，并保留回滚的能力。</p>
<p>另一个典型的错误案例是 stale bot 的自动关闭功能。真的，没人喜欢这个功能。开发者来到社区是为了和人建立联系，共同开发好的软件，而不是为了被机器人支配。应对 issue 或 PR 的积压问题，首先应该尽可能的及时处理。其次，大部分积压的 issue 是无效的内容，例如愿望清单和模糊的想法，这些只需要快速关闭即可。对于低优先级的 bug issue 的积压，既然问题是实际存在的，也不是 wontfix 的情形，凭什么关掉呢？如果当前的 maintainers 积极主动地处理 issue 和 PR 还是处理不过来，那么是时候寻找一个新的 maintainer 了。</p>
<blockquote><p>Users SHALL NOT log feature requests, ideas, suggestions, or any solutions to problems that are not explicitly documented and provable.</p>
<footer><strong>Collective Code Construction Contract</strong><cite><a href="https://rfc.zeromq.org/spec/42/#24-development-process">Development Process</a></cite></footer></blockquote>

<p>流程自动化的标杆案例包括 <a href="https://github.com/kubernetes/test-infra/tree/master/prow">Kubernetes 社区</a>和 <a href="https://github.com/rust-lang/homu">Rust 社区</a>。在学习这两个社区的做法的时候，需要强调的是</p>
<ol>
<li>请关注这两个社区为流程自动化投入了多少人力。</li>
<li>请关注这两个社区是在什么时候引入了何种自动化逻辑。</li>
<li>请关注这两个社区的成员如何利用自动化流程。</li>
<li>请关注这两个社区在流程自动化上的异同。</li>
<li>请关注这两个社区推行流程自动化时的讨论，尤其是争议。</li>
<li>请勿货物崇拜，直接照抄它们的方案。否则你会死得很惨。</li>
</ol>
<p>既然 Rust 社区都不抄 Kubernetes 社区的方案，你为啥贸贸然就要抄？</p>
<h3 id="日常事务"><a href="#日常事务" class="headerlink" title="日常事务"></a>日常事务</h3><p>前面讲的是一些整体的做法，回到每个 maintainer 身上，实际的项目维护工作其实是日常事务。</p>
<p><strong>最常见的问题是开发的风险控制</strong>。开源项目通常会有自己的版本发布周期。有时候你希望下个版本能交付某几个关键功能或改进，而这些工作并不都是由你一个人完成。尤其是，你之所以想交付这些变更，是因为公司的要求，而开发团队包括并非公司员工的成员。这个时候就需要你做好项目的风险控制。</p>
<p>从公司员工的角度，我介绍过开源项目和商业公司独立运营的协同模型。运用这个模型，可以把商业上紧急的需求实现在 fork 仓库上，交付 hotfix 应对紧急情况。稍后，把改动 contribute back 到开源项目当中。这样就可以把商业要求和软件开发的工程要求隔离开来，避免向开源社区倾倒粗糙的补丁。<a href="https://github.com/streamnative/pulsar">Stream Native</a> 就在公司组织下有 Apache Pulsar 的 fork 仓库。我没有仔细研究过他们的具体做法，但是显然他们把一些公司关心的内容都放在 fork 仓库上记录。让上帝的归上帝，凯撒的归凯撒。这是好文明。</p>
<p>如果评估出来更合适的做法是把改动直接做在上游，那么我会建议在需要严格控制风险的情况下，直接由公司员工组成开发团队。当然，这些员工得靠自己的努力在开源社区当中赢得信誉，而不是只根据职位就被允许直接提交代码。如果同样的需求已经有其他团队在做，那么沟通就是必要的。如果信得过这个团队，保持关注并提供帮助即可。否则，可以尝试接管项目开发。Flink 社区的 <a href="https://issues.apache.org/jira/browse/FLINK-16654">FLIP-85</a> 提案是我和 Uber 的工程师分别独立提出的。经过几轮邮件列表上的讨论，最终由阿里的工程师主导实现。我参与了 review 和提供了部分参考实现。</p>
<p>上面讲的是一个好的案例。其实对于一个活跃的开源社区来说，PR 冲突的情况不会太少，种类也很多。</p>
<p>TiDB 社区发生过一起有名的 <a href="https://github.com/pingcap/tipb/pull/208">Xuanwo 事件</a>。完全相同的两个补丁，后提交的反而先被合入，导致先提交的被迫关闭。尤其是这个事件发生在并不繁忙的仓库上，并且两个补丁提交的时间相差一个月。这是一种非常典型的情况，需要 maintainers 保持对项目范围内发生的活动的关注。</p>
<p>Flink 社区有不少经典的乐子。<a href="https://issues.apache.org/jira/browse/FLINK-10052">FLINK-10052</a> 作为我从 2019 年就和 @lamberken 配合修复完成并经过生产环境验证的高严重性问题，在过去的三年里提交的三个补丁都因为缺乏响应最终没有合并。这也导致不少用户被迫手动打补丁。<a href="https://issues.apache.org/jira/browse/FLINK-11937">FLINK-11937</a> 是另一个例子。两家员工提供了不同的方案，其中一方缺少社区话语权，无力单独推进合并，另一方有能力但是无意推进，也不允许其他人推进。同样的案例还有 <a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-44%3A+Support+Local+Aggregation+in+Flink">FLIP-44</a> 和 <a href="https://lists.apache.org/thread/snlsb5z9lcogdo7359dcwr4hn5qpymlo">Queryable State</a> 等等。</p>
<p>Flink 的例子其实证明了商业公司需要通过 fork 仓库的来应对商业需求。另外也可以看到这些讨论的发起人是如何被 stale bot 二次伤害的。</p>
<p>从开源协同的角度，contributor 不是程序，而是真实的人。上面提到的沟通手段，去掉公司员工的背景也同样适用。商业公司要做风险控制，开源社区也是一个组织，也可以做风险控制。只不过，开源社区是一个开放式组织。在这个环境下控制风险的手段不是管控，而是协同。前面讲到的文档和结构化的流程在这里同样可以起作用。信息在 contributor 之间自由流通，就不会有 FUD 产生的伤害。平时保持和其他 contributor 的联系，就能知道当前的工作最应该找谁一起做。</p>
<p>大部分情况下，contributor 是能够自我驱动和自我激励的。他们爆发出的创造力不可小觑。单就时间上的风险而言，如果你在开发文档里明确写下开发周期和发布模型，contributor 是乐于见到自己参与或主导开发的工作随新版本一起发布的。越是自我驱动参与开源社区的 contributor 越重视积累信誉。这个过程中，如果你作为 shepherd 指导或参与进去，只需要切实地关注和解决开发团队成员遇到的困难，并在需要时帮助他们管理好进度。</p>
<p>其他的沟通技巧和 maintainer 的最佳实践这里不再展开。Open Source Guides 提供了这个话题非常有益的补充，推荐延伸阅读。</p>
<ul>
<li><a href="https://opensource.guide/best-practices">Best Practices for Maintainers</a></li>
<li><a href="https://opensource.guide/leadership-and-governance">Leadership and Governance</a></li>
<li><a href="https://opensource.guide/building-community/#growing-your-community">Building Welcoming Communities</a></li>
</ul>
<h2 id="Have-fun"><a href="#Have-fun" class="headerlink" title="Have fun"></a>Have fun</h2><p>不论是 contributor 还是 maintainer 你都已经通过参与开源社区为社会创造出了价值。时不时想想你为什么要参与或维护这个项目，回顾这个项目已经取得的成就。你已经做得很好了。</p>
<p>软件都有自己的生命周期，开源软件也不例外。开源社区的工作也不是你生活的全部。如果你找到了新的乐趣，完全可以把项目交给其他 maintainers 维护，或者直接归档。如果开源项目的维护已经超出你的能力范围或者消耗了太多的时间精力，也可以休息一段时间甚至放弃对项目的维护。作为开源社区成员的你没有义务非得维护这个项目或者响应别人的请求。你把自己的工作自由的提供给其他人利用，已经创造了非常客观的价值。</p>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>企业如何实践开源协同</title>
    <url>/2021/12/05/open-source-collaboration-enterprise-perspective/</url>
    <content><![CDATA[<p>随着开源概念的红火，越来越多的企业将内部项目公开托管到 GitHub 等平台，也有越来越多依托开源项目建立起来的企业。对于这些企业来说，它们的目标不只是开放项目源代码，更希望能够形成开源共同体，打造围绕项目的软件生态。</p>
<p>然而，其中大部分项目由于成员背景的单一性，最终都终结于仅源码可得的形态。对于这些新兴项目来说，初始成员从属于同一企业是既定事实。在这样的前提下，企业应该如何实践开源协同，形成开源共同体呢？</p>
<span id="more"></span>

<h2 id="共享工作流"><a href="#共享工作流" class="headerlink" title="共享工作流"></a>共享工作流</h2><p>从开发者的角度出发，根本问题是要共享工作流。共享工作流，即项目开发的核心流程只有一套，所有 contributor 无论背景都基于这套核心流程工作。</p>
<p>对于企业内部项目开放源代码的情况，要做到这一点并不容易。项目往往在企业内部已经有一套成熟的工作流。如果在设计开源方案的时候，没有把共享工作流考虑在内，即使代码公开，大部分开发流程也会保持在企业内部。如果 contributor 不是企业员工，则根本无法参与。</p>
<h3 id="Case-Study-OceanBase"><a href="#Case-Study-OceanBase" class="headerlink" title="Case Study: OceanBase"></a>Case Study: OceanBase</h3><p>这个问题的典型案例是 <a href="https://github.com/oceanbase/oceanbase">OceanBase</a> 项目。</p>
<p>OceanBase 项目的源代码托管在 GitHub 和 Gitee 两个平台上，同时接受问题报告和补丁提交。通常来说，一个项目只会有唯一的问题报告和补丁提交方式。例如，Linux 采用 Bugzilla 记录问题，邮件列表提交和评审补丁。GitHub 上有 Linux 的镜像，但是是只读的。其他的例子包括 GCC 和 PostgreSQL 等，都会有唯一的工作流，其他代码仓库只是镜像。OceanBase 两边都接受问题报告和补丁提交，反而是对两边的反馈都不重视。</p>
<p>可以猜测，它的核心流程既不是 GitHub 上的工作流，也不是 Gitee 上的，而是企业内部的工作流。这种情况下，能从开放可参与的平台上提交的大概率就只有简单的拼写错误或者代码重构补丁。因为即使是资深的开发者，缺少必要的信息和充分的讨论，也无法更进一步参与。实际情况也是如此，内部的活动别说讨论和设计文档，就连提交都不是实时同步的。此外，项目在两个平台上的活动，基本只有一名维护者出面在处理。</p>
<p>企业开放内部项目源代码，允许任何人学习和使用，是有社会价值的。但是内外两套工作流，甚至开放可参与的工作流只是个添头，那就不可能形成开源共同体。如果这就是预期的目标，那倒也没事。只是对于辛苦应付这些留下来的缺口进来的简单补丁的维护者来说，他是否会觉得这只是另一种值班呢？无论如何，工作流的统一都有助于减少损耗。不管是干脆只保留内部工作流，托管平台上的所有活动都没有回应保证，还是尝试融合到开放工作流，真正做到开源协同，都比牺牲一部分人，做一些创造出来的边缘工作要好。</p>
<h3 id="Case-Study-Apache-InLong-incubating"><a href="#Case-Study-Apache-InLong-incubating" class="headerlink" title="Case Study: Apache InLong (incubating)"></a>Case Study: Apache InLong (incubating)</h3><p>致力于融合到开放工作流的典型案例是 <a href="https://github.com/apache/incubator-inlong">Apache InLong (incubating)</a> 项目。这个项目是由腾讯捐赠给 Apache 软件基金会的数据流处理平台。</p>
<p>在项目开放初期，也存在只有内部工作流的情形。不过得益于主要维护者的软件工程经验，在明确项目要以开源协同的方式运作以后，经过对维护两套开发流程弊端的分析，得出了要融合工作流的结论。既然是开源协同，那么融合的工作流就是共享工作流了。</p>
<p>一段时间的改造后，原先内部工作流的核心流程被迁移到共享工作流当中，包括问题报告、补丁提交和版本发布。原先内部工作流服务于企业需求的部分则基于共享工作流构建。</p>
<p>企业内部仍然有用户问题报告，但是归结到项目本身缺陷的问题，会脱敏之后报告到 GitHub Issue 上。为了解决紧急问题，企业内部的 fork 版本仍然会打临时补丁快速上线，但是救火之后正式修复的补丁会以 contributing back 的形式提交到开源项目上。最后是版本发布。一开始，只有内部项目在发版。开放源代码之后，就有两个同类项目要分开发版。经过一系列的改进，主要是问题报告和补丁提交的及时同步，最终两个项目能够以较小的同步开销同时发版。换句话说，GitHub 上托管的版本，就是企业内部使用的版本。企业内部可能有一些临时补丁，但是并不构成一个差异化内部版本，并且这些补丁是积极地被推进 contributing back 上游的。</p>
<p>可以看到，确定开源协同开发项目的方向后，共享工作流不是形式主义，而是能切实提高软件工程效率和减少摩擦的方案。</p>
<p>对于企业本身依托开源项目建立的情况，要维持共享工作流也存在很多挑战。这些挑战大多出自一个原因，那就是最佳实践的匮乏导致节外生枝的私下讨论。</p>
<h3 id="Case-Study-TiDB"><a href="#Case-Study-TiDB" class="headerlink" title="Case Study: TiDB"></a>Case Study: TiDB</h3><p><a href="https://github.com/pingcap/tidb/tree/master/docs/design">TiDB</a> 的代码仓库中有专门存放设计文档的目录。理论上，新功能，行为变更，以及其他重要改动，都需要一个设计文档。</p>
<p>我们可以从设计文档的时间线看出这一工作流的变迁。</p>
<ul>
<li>2018 年下半年，共 17 份设计文档。</li>
<li>2019 年全年，共 6 份设计文档。</li>
<li>2020 年全年，共 13 份设计文档。</li>
<li>2021 年至今，共 19 份设计文档。</li>
</ul>
<p>从另一个维度看，2019 年 5 月到 10 月，2020 年 10 月到次年 2 月，一共将近一年的时间里，项目没有提出过任何设计文档。</p>
<p>那么，TiDB 项目在此期间是停止开发了吗？没有。它一直以每个工作日合并 10 个 PR 以上的开发速度在前进。在此期间关于功能设计的讨论，其实是转进了企业的即时通讯工具或内部文档当中了。我们可以看几个例子。</p>
<ul>
<li><a href="https://github.com/tikv/tikv/issues/10540">Raft Async IO</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/25970">SPM Enhancement</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/26085">Cardinality Estimation Enhancement</a></li>
</ul>
<p>这几个功能并不是没有设计，而是只在小范围内通过中文文档做出设计，就开始实现。甚至在 Cardinality Estimation Enhancement 的例子当中，以为 contributor 想了解功能设计和背景，被 assignee 以时间紧迫为由回绝。虽然 assignee 承诺会在完成后进一步披露消息，但是却没了下文。</p>
<ul>
<li><a href="https://internals.tidb.io/t/topic/372/7">Announcing remove required integration test check when merge pr</a></li>
</ul>
<p>另一个例子是 pull request 上的检查项变更。不仅整个过程是在企业内部决策后直接在开源项目上上线，共同体内的其他成员一无所知，而且对于 bad case 的处理依赖于企业内部的群聊，让人摸不着头脑。</p>
<p>其实这些案例，我相信相关成员并不是刻意要伤害开源共同体。设计和开发的需求是天然存在的，持续集成的改动也不是不能做，但是实际推动落实的成员，缺乏开源共同体当中工作的经验，难以站在一家企业之上的视角，以合理的方式开展工作，才导致了这些实际伤害了开源共同体的做法。</p>
<p>我在这两个方向都做过一些改良的工作。对于设计文档，我发起了一个 Public Design 的讨论，并且推动了几个重大改动的公开设计。在此过程中和复数的开发者沟通了公开设计的技巧，以及在此前提下如何高效地推进重要改动的落实。实际上，公开设计并不会损失效率。因为并不是内部讨论完成后拿出来公示，而是从一开始就放在公开渠道讨论。既然是开源协同，补丁提交本身也是公开的，这些材料有什么好隐藏的呢？相反，因为得到了潜在的更多反馈，能够在设计等早期阶段避免缺陷，反而公开设计是更加高效的手段。</p>
<ul>
<li><a href="https://internals.tidb.io/t/topic/399">Discuss: Public Design</a></li>
<li><a href="https://github.com/tikv/pd/issues/3839">Tracking issue for Region Label Feature</a></li>
<li><a href="https://github.com/tikv/rfcs/pull/67">RFC: Substitute RocksDB write stall</a></li>
<li><a href="https://github.com/pingcap/tidb/issues/26020">Tracking issue for heuristic rules enhancement for index selection</a></li>
</ul>
<p>对于持续集成，企业内部把研发和工程效能分成两个竖井，又把开源共同体仅关联到研发的工作上去，是这个问题的根源。组织结构问题不好解，只能先改变工程效能团队的员工的认知。当他以开源共同体成员的身份变更项目基础设施的时候，也通过提交议题，达成共识后实施的工作流来推进。实际上，这样改变以后，关注到项目功能开发的成员与维护基础设施的成员更能坦诚的交换意见，避免意料之外的改变激发矛盾。</p>
<ul>
<li><a href="https://github.com/pingcap/tidb/issues/28947">Integrate UT coverage with CI pipeline</a></li>
</ul>
<h3 id="Case-Study-Taichi"><a href="#Case-Study-Taichi" class="headerlink" title="Case Study: Taichi"></a>Case Study: Taichi</h3><p><a href="https://github.com/taichi-dev/taichi">Taichi</a> 是一个主要面向计算机图形学的并行编程框架，由胡渊鸣博士发明。去年，他作为联合创始人创立了太极图形公司来支持项目的发展。</p>
<p>项目早期基本是胡老师一个人的工作。开放源代码并有 contributor 加入后，画风是这样的。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/1836">[async] Implement basic StateFlowGraph</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/479">Allow ti test_python to take in individual test files</a></li>
</ul>
<p>这两个 pull request 的三位参与者，彼时分别在美国波士顿、日本东京和中国上海。当时也没有成立公司，更不谈有企业内部的即时通讯工具或文档空间。所以你可以看到所有必要的讨论都发生在 GitHub 平台上。</p>
<p>时间拉回到现在，部分项目的开发仍然是有迹可循的。比如有个置顶的 <a href="https://github.com/taichi-dev/taichi/issues/2398">RoadMap</a> 作为当前正在投入的工作的地图，比如 <a href="https://github.com/taichi-dev/taichi/issues/3301">Taichi 编译器前端类型检查</a>有个 tracking issue 来记录工作。</p>
<p>不过，也会出现我在昨天看到的无描述 4000 行改动无评论合并的案例。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/3567">[Mesh] The ti.Mesh class &amp; mesh-for loop implementation</a></li>
</ul>
<p>经过社交媒体的传播，目前这个 pull request 更新了部分描述。其实是一个学术研究相关的功能，在发出论文后希望 contributing back 到上游。由于变更较为复杂，早期设计出于研究原因不便公开，加上持续集成流水线的效率问题，所以采用了一步到位的合并方案。代码 review 私下发生在提交之前。</p>
<p>那么，这些信息昨天凌晨看到的我能够知道吗？答案是不能。</p>
<p>其实这种提交一个大改动的案例并不少见。Apache Flink 项目曾经多次发生过这样的事情，包括 2014 年 7 月合并 streaming 的原型，2019 年合并阿里巴巴内部版本 BLINK 等等。项目接受来自企业或学术团体的 contribution 是很正常的，其他开源项目也有研究室基于项目做出优化策略后 contributing back 的案例。</p>
<ul>
<li><a href="https://lists.apache.org/thread/mc4622swvv1y4dbty5x20rlh3whdjst5">[DISCUSS] A strategy for merging the Blink enhancements</a></li>
<li><a href="https://lists.apache.org/thread/mn1nf4p11t054zmhdglorjt40xoyz7wv">[ANNOUNCE] Contributing Alibaba’s Blink</a></li>
</ul>
<p>开源共同体接受 contribution 的标准做法仍然是公开讨论。只需要说明这件事情，解答潜在的疑问之后决定接受或拒绝 contribution 即可。如果 ti.Mesh 的研究结果是以这样的形式合并到代码仓库的，我想在一开始我就不会有疑惑和疑惑导致的误会。另一方面，公开讨论和 contribute 对开源项目也是一种保护。Apache 项目在接收重要 contribution 时都会考虑引入一个<a href="http://incubator.apache.org/ip-clearance/">知识产权清理</a>流程，确保接收 contribution 不会引入知识产权相关的争端。</p>
<p>Taichi 项目当中缺乏背景信息的还有这些例子。</p>
<ul>
<li><a href="https://github.com/taichi-dev/taichi/pull/3538">[bug] Remove fallback in C++ code</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/3433">[gui] Show f16 image as f32.</a></li>
<li><a href="https://github.com/taichi-dev/taichi/pull/3279">[Lang] Support more SNode trees for LLVM backends</a></li>
</ul>
<p>当然，必须说明的是 Taichi 项目的大部分 pull request 是有背景信息的。上面这些案例的参与者，我想也不是刻意隐藏信息，而是成立公司之后，自然地在线下或者内部平台讨论。既然已经通过私下讨论得出结论，再刻意搬到 GitHub 上反而就是低效的。对于具备项目假设 contributor 应该有的知识就能理解的补丁，也不需要做作的讨论。</p>
<p>要想避免因为已经私下讨论得出结论，从而把共同工作流的一部分切换成内部工作流的情况，应该从两个方面入手。</p>
<p>第一个是在确定开源协同开发项目的方向后，所有技术讨论都以 GitHub 平台的内容为唯一信源。私下讨论是无法禁止的，只能从技术领袖开始以身作则，推动公开讨论。其实对于大部分企业员工来说，在哪讨论并不重要。真正让他们转向私下讨论的原因，是在 GitHub 上的评论得不到回复，而钉一下或者内部文档 at 有奇效。值得一提的是，Taichi 也有我曾经到的 TiDB 的问题，那就是没有一个活跃的开放式讨论渠道，即没有邮件列表的替代品。有个 Discourse 论坛，但是是面向中文用户而不是全球开发者的。开通了 GitHub Discussion 功能，但是只有唯一一个版本发布的公告。</p>
<p>第二个是作为共同体的领袖，应当积极寻找不同背景的参与者。如果已经形成了私下讨论的习惯，仅仅要求员工改变习惯是很难有效的。因为公开讨论的主要原因，是为了和企业以外的 contributor 交流，以获得有意义的输入和提高生产力。如果员工发现换个地方发言，得到的回应还是同事的回应，并且 GitHub 上的评论还是得不到即时的回复，这件事就推不下去。</p>
<p>前面的例子提到过，当 Taichi 的主要开发者天各一方，没有成立公司之前，这种沟通是自然而然的。实际上，Linux 和 Apache Httpd 也是这样的。除了邮件列表，Linus 很难找到另一个渠道收获他所需要的反馈。Apache Httpd 的早期成员一开始就是在邮件列表上沟通的。只有实际存在组织以外的高水平参与者，开源协同的最佳实践才有意义。对于企业员工来说，也才有直接合理的理由不在内部讨论。毕竟就某个特定的问题，他更希望听一听那个不同背景的共同体成员的意见。</p>
<h2 id="招募新成员"><a href="#招募新成员" class="headerlink" title="招募新成员"></a>招募新成员</h2><p>寻找不同背景的参与者，其实就是作为共同体的领袖为共同体招募新成员。这是企业实践开源协同的另一个难题。除了为企业招募以外，应该如何为共同体招募呢？</p>
<h3 id="End-user"><a href="#End-user" class="headerlink" title="End user"></a>End user</h3><p>第一个要讨论的是用户。不过，用户是开源协同之外的内容。商业产品同样需要自己的用户。大部分用户也不会关心软件是如何实现的。</p>
<p>所以，要讨论用户，其实是要驳斥一些错误的观念。用户能够为你提供使用反馈，能够通过付费或捐赠支持项目开发人员持续投入，但是期待从用户群体中大规模地发现核心 contributor 则是不切实际的。</p>
<p>我听到过很多项目领袖跟我说，他的项目是独特的，因为不像大数据项目那样，用户本身也是开发者。它可能是一个数据库。哎呀，用户都是 DBA 或者数据分析师，根本不知道数据库怎么实现的嘛。它可能是一个机器学习框架。哎呀，用户都只会操作 Python 接口，根本搞不来核心 C++ 代码。</p>
<p>那我就想问了，你咋不去找那些就做数据库的人，就搞机器学习框架的人呢？你给团队招聘的时候知道找这些人，怎么到了给共同体招募新成员，眼里就只看到用户了。</p>
<p>其实我也可以理解。因为开源协同不够普及，大部分人提到 open-source 这个概念，第一印象还是一个市场营销的手段。或者提到“运营开源社区”，就把用户社区那些已有经验都搬过来。在这样的认识下 open-source community 就是开源社区，而不是开源共同体。其中“我们”是唯一的开发者，是懂行的。其他人是只会小修小补的爱好者，或者干脆啥也不懂的用户。</p>
<p>这个误区有点像思维定式。你现在要找的是有能力开发项目的参与者，那就去对应的群体里找就可以了。</p>
<p>当然，如果你就想做用户社区，就没打算搞开源协同，也是一种选择。对于这类需求，我建议研究 MongoDB 的做法。它们搞得挺好，这里就不展开了。</p>
<h3 id="Ecosystem"><a href="#Ecosystem" class="headerlink" title="Ecosystem"></a>Ecosystem</h3><p>抛开用户不谈，开源共同体当中的 contributor 还可以进一步细分。其中有一类 contributor 关注生态互连，另一类关注项目的核心逻辑。</p>
<p>如果项目提供了足够多的扩展点，或者策略替换机制，那么关注生态互连的 contributor 就能够快速参与进来。</p>
<p>例如，Flink/Spark/Presto 等项目都设计了 connector 机制，连来连去就能创造出大量的工作。例如，几乎所有项目都可以搞多语言 SDK 玩玩。TiKV 就有不少于五种编程语言的客户端实现。例如，PostgreSQL 提供 FDW 机制，不仅支持连接外部数据源，更暴露了参与 planning 阶段的计算下推接口。例如，Linux 其实也有丰富的扩展机制，支持多种架构和驱动就是一个例子。</p>
<p>上面这些都是项目本身的机制，更广泛的生态还包括解决方案的整合。例如，从 Netty 的角度看，Flink 就是它的生态的一部分。从 Flink 的角度看，serverless 技术栈 StateFun 又是它的生态的一部分。经常听 database 的开发者说自己的软件直面终端用户，但是其实就互联网业务开发者来说，中间是隔了一层 ORM 框架的。哪怕是数据分析师，大概率也隔了一层可视化框架。另外，数据的同步和搬迁也是应用设计不可缺少的一部分，这就是各种中间件能发挥作用的地方了。</p>
<p>总之，这类 contributor 还可以再细分。一类是关注项目提供的机制替换实现的，大部分可以从有可能提供实现的项目开发者当中寻找。例如项目的部署机制希望支持 Kubernetes 环境，那找一个热衷于写 Kubernetes Operator 或者刚学会跃跃欲试的开发者参与，就很有可能产生正面效果。另一类是关注项目整合形成用户解决方案的。实际上，项目开发者最终基于项目实现盈利，往往就是以某种解决方案出现。只要你发挥想象力，生态整合的可能性就是个乘法，不愁找不到参与者。即使是核心逻辑被单一企业掌控的 MongoDB 项目，其生态也是非常繁荣的。</p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>当然，项目的核心逻辑也是非常重要的。如果项目本身不够坚挺，那么就不会有用户使用，也无法激起 contributor 连接生态的动力。</p>
<p>项目的核心逻辑是一个项目的主要价值。这些逻辑通常由项目的初始成员定义。在企业主导项目的情况下，这些初始成员往往背景单一。同时，出于传统组织观念的影响，初始成员往往以企业当中的项目团队作为自我认同，团队等同于项目，也因此将核心逻辑的开发层层“保护”在看不见的高墙之内。</p>
<p>以项目团队作为自我认同，无怪乎招募新成员的时候，自我认知自动翻译成团队招聘，而想不到还有其他可能性。</p>
<p>反观成功的开源项目，数据湖项目 <a href="http://hudi.apache.org/">Apache Hudi</a> 由 Uber 捐赠给 Apache 软件基金会，在项目快速发展过程中吸引到了阿里巴巴和 T3 出行等企业的员工的参与，并吸纳了上述企业背景的开发者作为项目 PMC 成员。对于后续参与的企业的员工来说，他们在企业当中虽然也有项目团队，但是显然不会觉得项目归企业内的项目团队所有。对于 Uber 来说，来自其他企业的核心 contributor 的声音也不可忽视。这样，Apache Hudi 成功建立了一个开源共同体。</p>
<p>要想为项目招募开发核心逻辑的参与者，我觉得应该做到以下三点。</p>
<p><strong>第一点是改变认知</strong>。上面已经介绍了错误认知的危害和避免错误认知的最终形态。我把这种正确的认知称为“开发者的两顶帽子”。同一个开发者，既是开源共同体的参与者，也是企业的员工。这两个身份虽然从属于同一个人，但是却有着不同的诉求。只有区分开这些不同的诉求，一部分是开源共同体的目标，一部分是企业基于开源项目创造商业价值的目标，才能避免认知混乱导致人为制造出参与的高墙。</p>
<p><strong>第二点是公开讨论</strong>。前面讨论的很详细了，这里再补充一个点。当你真的身处一个开源共同体当中，不做公开讨论才是奇怪的。例如 Apache Hudi 的例子，如果 T3 出行的开发者想要实现某个功能，除了公开讨论寻求共识，别无他法。</p>
<p>公开讨论还有一个额外的好处，那就是方便引用。不少基于开源项目建立起来的企业，运营人员整天发愁哪里有技术内容可以发布，写技术文章好像变成了一个苦差事。其实技术话题公开讨论，天然的就有高质量的内容可以推送，其中悬而未决的议题，也是 contributor 参与的绝佳切入点。例如 <a href="https://twitter.com/engulaio">Engula</a> 项目在社交媒体的输出，基本就是设计文档或者开放式讨论里值得发布的内容。</p>
<p><strong>最后一点是积极招募</strong>。前面分析 Taichi 的例子也提到过，认知改变的假设需要多样化的开源共同体成员来验证，保持公开讨论的做法也需要不同背景的 contributor 参与。除了公开讨论能够吸引到潜在的参与者，积极招募更意味着共同体的领袖要主动思考谁是你要找的人。</p>
<p>对于每个项目来说，这个问题的答案都不一样。但是认为这个问题没有答案，或者说人才都在企业当中了，则是一种傲慢。</p>
<p>同样举数据库的例子，哪怕你有 Oracle 那么大，世界上也还有相当一批人在开发 PostgreSQL 等项目。这些人并不是一辈子就做这一件事的。只要你的项目足够有趣，他们就有可能投入。</p>
<p>另一方面，泛泛而谈数据库这样一个复杂的领域其实是一种懒惰。既然复杂的项目本身会分模块开发，为什么在招募新成员的时候就只想着完全理解整个领域的人呢？如果项目的并发设计不佳，只要是精通该语言并发编程的专家，愿意 contribute 做改进，你管他懂不懂数据库的专业概念。醉心于编译器前端的开发者，也许能解决 SQL Parser 当中经年的性能问题。进入 Apache 孵化器的项目的导师，往往也不是项目所在领域的专家，甚至不是开发者，但是他们能够帮助项目以 Apache 的方式建立起开源共同体。</p>
<p>以这样的方式去寻找潜在的开发核心逻辑的成员，相信你的视野会更加广阔。</p>
<p>其实，这才是“开源共同体”的含义。不止于项目，也不是社区居委会，而是围绕开源项目的发展，基于对项目的认同，形成的多层次合作共同体。</p>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>开源共同体的治理模型</title>
    <url>/2022/01/06/open-source-governance/</url>
    <content><![CDATA[<p>随着越来越多新的要素进入开源领域，如何建立一个高效的开源共同体，如何维护一个富有价值的开源共同体，逐渐成为每个参与者或多或少关注的问题。</p>
<p>Apache 软件基金会为每个项目提供了基础的治理原则，并在项目孵化到顶级项目的过程中通过孵化器导师的帮助建立起开源项目的治理模型，但是这一模型对每个具体项目在特定时期未必是最优的。同时，其他不在 Apache 软件基金会治理的项目，虽然拥有灵活设计治理模型的自由，却也时常陷入不知道该如何开始的窘境。</p>
<p>本文从开源治理的目的出发，介绍一个开源共同体什么时候需要考虑设计治理模型，然后讨论开源治理的原则，结合实例分析如何设计开源共同体的治理模型。这里所说的开源共同体，主要指的是围绕单一项目或单一主题项目群形成的开源共同体。</p>
<span id="more"></span>

<h2 id="开源治理的目的"><a href="#开源治理的目的" class="headerlink" title="开源治理的目的"></a>开源治理的目的</h2><p>讨论开源治理的首要问题是，对于特定的开源共同体，当前阶段下是否需要治理。这个问题的解答可以从<a href="https://book.douban.com/subject/26976995/">《社区运营的艺术》</a>一书中对相同问题的讨论得到。书中认为，需要开源治理的主要原因包括</p>
<ul>
<li>社区规模激增</li>
<li>冲突越来越多</li>
<li>资源多</li>
<li>商业利益</li>
</ul>
<p>总的来看是两个问题。其之一是参与者和资源增加以后，维持开源共同体高效运转的挑战；其之二是不同背景的成员加入，不同要素进入之后，维护开源共同体的核心价值，也就是生产满足目标用户的高质量软件。</p>
<h3 id="建立高效的开源共同体"><a href="#建立高效的开源共同体" class="headerlink" title="建立高效的开源共同体"></a>建立高效的开源共同体</h3><p>开源共同体围绕开源软件而建立，其主要目的就是制造高质量软件，以满足目标用户的需要。这意味着生产代码、撰写文档、解答问题和市场营销都是开源共同体工作内涵的一部分。</p>
<p>项目启动阶段，尤其是功能尚未丰富的时候，交付核心功能是第一要务。这个阶段，往往项目参与者不过几个人甚至就是一个人的工作，也不会有太多的关注者和用户。这个阶段是不需要引入复杂的治理模型的，简单的项目创始人掌握所有权力并决策所有事务即可。没有核心开源软件创造价值而沉迷于设计治理模型，只不过是空中楼阁。唯一跟治理模型沾得上边的，就是留心并记录这个阶段当中软件开发的流程和决策惯例及案例。</p>
<p>随着项目核心功能的实现和迭代，产生的价值能够吸引到目标用户使用，更多的参与者被项目吸引或用户需求所推动着了解项目。同时，开源项目的成长也带来了对资源的需求，例如持续集成的基础设施，沟通渠道的维护，直接支持项目开发的资金捐赠的处理，围绕开源软件的活动和宣传的运营和开销，等等。新成员的加入带来沟通成本的提高，丰富的资源需要一定的流程和负责人维护才能合理得到使用。这个时候，设计一个治理模型以维持开发效率和决策效率，就是有必要的了。</p>
<p>治理模型通常体现为一个或几个治理机构及其职责和沟通方式。在维持高效的开源共同体的话题上，这些治理机构主要解决以下问题。</p>
<ul>
<li>批准或拒绝新成员加入。特别地，你可能为成员定义不同的身份，例如一般成员、开发者或其他贡献者，等等。</li>
<li>解决冲突。</li>
<li>明确项目价值，落实开源共同体的核心价值观。</li>
<li>修改流程。</li>
<li>如果开源共同体日渐复杂化，治理机构可能需要派生出新的治理机构。</li>
<li>决定方向。</li>
</ul>
<h3 id="维护开源共同体的核心价值"><a href="#维护开源共同体的核心价值" class="headerlink" title="维护开源共同体的核心价值"></a>维护开源共同体的核心价值</h3><p>如同前文所述，开源运动热火朝天引得越来越多新的要素进入这个领域，政治要素和资本要素就是其中不可忽视的两个。许多开源共同体都有商业赞助商和投资者。这些赞助商的员工当中往往有不少是开源共同体的参与者，通过参与做出对赞助商有利的贡献。有时候开源共同体只有一个赞助商，它可能就是一开始创立项目的企业。这种情况下，赞助商和投资者会主动寻求建立某种治理模型，以明确自己为开源共同体做出的投资所能得到的回报的预期。</p>
<p>例如，《社区运营的艺术》提到，Linux 发行版 Fedora 和 OpenSuSE 对应的赞助商 RedHat 和 Novell 在各自的开源共同体当中都通过制度保证了足够多的席位以推行任何他们想要推行的主张，而 Ubuntu 对应的赞助商 Canonical 仅在所有七名成员中保留一个席位且其他成员多数不是为该公司工作的。国内首个开源基金会开放原子开源基金会，其技术指导委员会的席位为主要捐赠人每家预留一位。TiDB 设计的技术委员会成员，必须是 PingCAP 员工、PingCAP 社区伙伴员工或社区项目代表。</p>
<ul>
<li><a href="https://www.oschina.net/news/119227/openatom-foundation-technical-oversight-committee">揭秘开放原子开源基金会 TOC 设计</a></li>
<li><a href="https://github.com/pingcap/community/blob/06051f58b4e448a6d73ff63423c8adeb8f47f7ab/toc/README.md">TiDB Community Technical Oversight Committee</a></li>
</ul>
<p>反之，Apache 软件基金会则强调 Community of Peers 即共同体由个人组成，而非组织。Kubernetes 虽然会展示成员的组织关系，但是治理模型当中也不体现赞助商或投资者的特权。</p>
<ul>
<li><a href="https://www.apache.org/theapacheway/index.html">BRIEFING: THE APACHE WAY</a></li>
<li><a href="https://www.apache.org/foundation/how-it-works.html#hats">INDIVIDUALS COMPOSE THE ASF</a></li>
<li><a href="https://www.kubernetes.dev/community/values/#community-over-product-or-company">Community over product or company</a></li>
</ul>
<p>《社区运营的艺术》提到，一般的志愿者社区，比如开源项目，赞助和投资方应该不参与治理机构。</p>
<blockquote>
<p>我这样说并不是因为商业赞助是不可信的，而是因为与志愿者关联的社区往往是建立在所有成员的贡献之上的，而这些成员积极贡献的目的，就是保证他们的辛勤工作有助于同侪和社区的未来。</p>
</blockquote>
<p><a href="https://book.douban.com/subject/35531548/">《People Powered》</a>当中进一步解释了这个论点。</p>
<blockquote>
<p>你的社区受到两个因素的驱动，一个是成员自身的利益，另一个支持社区获得更大的成功。除组织内部社区等极少数外，你的社区成员为社区工作，而不是为你工作。这常常使那些坚持“如果公司成功，社区也将从中受益”的公司受挫。这句话没错，但不重要。这不是大多数社区成员的想法，也不是社会经济运作的方式。</p>
</blockquote>
<p>为了应对赞助和投资方的提案，协调开源共同体当中各方的需求以达到共同体利益最大化，避免分化，需要设计一个相应的治理模型。</p>
<h2 id="开源治理的原则"><a href="#开源治理的原则" class="headerlink" title="开源治理的原则"></a>开源治理的原则</h2><p>不同开源软件的特点，开源共同体的成员组成和所处阶段的差异，都会影响治理模型的设计。我在 <a href="https://mp.weixin.qq.com/s/POhfL4zrrmUHZUWGNWQbpw">夜天之书 #18 Evolving Governance</a> 和 <a href="https://mp.weixin.qq.com/s/QokLLyPMPpa7cVW-54DwCA">夜天之书 #25 Evolving TiDB Governance</a> 里已经讨论了特定开源共同体的治理模型设计权衡。</p>
<p>本文尝试从开源治理的原则出发，讨论根本的设计思路。开源治理的原则总的来说是以下两条。</p>
<ul>
<li>开源共同体利益至上</li>
<li>摈除丑陋的形式主义</li>
</ul>
<h3 id="责任感"><a href="#责任感" class="headerlink" title="责任感"></a>责任感</h3><p>要想落实“开源共同体利益至上”的原则，必须保证治理机构的成员对开源共同体有一种真正切身的责任感。</p>
<p>与其说开源治理是制定一系列规则并任其自动运行，不如说是找到具备领导能力且愿意为共同体发展承担责任的优秀人才。开源共同体当中常见的角色 Committer 抛开其提交代码的权限，词源本意即“做出承诺的人”。</p>
<p>开源软件由志愿者开发，在志愿者环境中是无法强制一个人参与的。有些志愿者能够每天都投入到共同体工作中，而其他志愿者仅在情绪不错时参与工作。后者的贡献值得感谢，但是他们通常不能承担治理责任，也不具备领导能力。对于围绕开源共同体做出的重大决策以及合并补丁和发布版本等核心活动，掌握权限的核心成员必须维护开源共同体利益，必须显示出强烈的责任感和使命感。换句话说，核心成员要对自己的行为负责，当开源共同体为了完成某些任务而全力以赴时，核心成员必须腾出时间来为之工作。</p>
<p>《社区治理的艺术》提到，责任感是宝贵财富，它相当于你在社区得到的承诺宣言。一些成员会有这样的责任感，而另一些则没有。有责任感的人是宝贵的资源，你可以委以重任，但是不可以利用他们的责任感。</p>
<p>例如，我在多次和 Apache Flink 的 PMC Chair Stephan Ewen 沟通的过程中，都能感受到他对项目的热忱。这种热忱支持着他十多年来投入到项目的开发、发布和宣传当中。即使自己所创办的基于 Apache Flink 提供服务的公司已经被收购从而财富自由，即使面对诸多邀约有不少早期成员开始投入新的项目，他却始终坚持发展 Apache Flink 以满足用户的需求。例如，Linus 在 2022 年伊始就在<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=278218f6778bc7d6f8b67199446c56cec7ebb841">合并提交到 Linux 项目的补丁</a>。例如，Apache SkyWalking 的创始人吴晟和 ClickHouse 的创始人 Alexey Milovidov 都以快速处理开源项目当中的评论、议题和补丁著名。</p>
<p>项目的创始人通常是对项目抱有最高责任感的人。因此，在设计治理模型的时候，直接把创始人排除在外是不可接受的。《大教堂与集市》当中讨论“Locke 及土地所有权”的时候也提到过这个模型。然而，不少形式化开源的项目，指派了一个或几个所谓的“社区运营专员”来架设治理模型，往往就把创始人反而排除在外。这是彻底的形式主义，也是错误分工带来的恶果。</p>
<p>Zoom.Quiet 对此有过评论，</p>
<blockquote>
<p>这其实才是最大的天劫。项目开始时，大家的目标是不言而明的，因为是小团队多年的相同愿望。但是，有新人进来时，才发现没有之前多年的共事根本无法简单说清。所以，有所谓专家或布道师来接替创始团队来解释时，核心成员如果不认同，嘴又笨，直接表现就是不活跃了。看起来，是更加专业的专家替代了土领导，可其实，社区已经空心化了。毕竟不是谁都有 Linus 的嘴炮能力。</p>
</blockquote>
<p>不得不感慨，Linux 能成功，Linus 功不可没。《时代周刊》做过一个有些极端的评论，但不无道理。</p>
<blockquote>
<p>有些人生来就注定能领导几百万人，有些人生来就注定能写出翻天覆地的软件。但是只有一个人两样都能做到，这就是林纳斯。</p>
</blockquote>
<p>创始人的缺位会给开源治理留下很深的阴影。例如，Rust 项目的创始人 Graydon Hoare 并没有坚持做 Rust 项目，核心成员 Brian Anderson 和 Niko Matsakis 还有 Alex Crichton 等等都不在最高治理机构 Core Team 里。同时，Core Team 的人员更替并不谨慎，导致部分成员难以服众。这是前不久 <a href="https://github.com/rust-lang/team/pull/671">Moderation Team 和 Core Team 矛盾</a>的深层原因之一。</p>
<p>核心成员的传承也要基于责任感。例如 Apache 软件基金会现任董事会成员 Justin Mclean 和吴晟，都非常关注孵化器当中新项目的加入和成长，关注 ASF 项目面临的法务挑战，关注 Apache License 的采用情况，等等。例如 2020 年新加入 PostgreSQL 的 Core Team 的成员都是经年参与 PostgreSQL 共同体的志愿者。</p>
<p>可以说，只有核心成员对开源共同体有切身的责任感，才能践行“开源共同体利益至上”的原则，其他成员也才能信任这样的治理机构能够领导和鼓励共同体向前发展。</p>
<h3 id="精英领导制"><a href="#精英领导制" class="headerlink" title="精英领导制"></a>精英领导制</h3><p>这里提到的精英领导制是一种组织管理体系，成员在共同体当中受到的尊敬和能够承担的职责，取决于他所做的贡献，而不是金钱、社会阶层和家庭关系。换句话说，就是“唯才是举”的理念。</p>
<p>要想落实“开源共同体利益至上”的原则，强调精英领导制是有益的。当然，对于这个词感到陌生的人，可以多谈论一些平等性，多提供一些成员如何通过自身的努力，去建立声望的例子。</p>
<p>精英领导制强调了对开源共同体的贡献是赢得权威的唯一方式。这种贡献的衡量与个人所绑定，与其所属的组织无关。避开资本要素的影响，使得开源共同体能够最大限度的接纳新的参与者，并通过对参与者贡献的衡量和他们与其他核心成员共同工作的方式来选拔新的核心成员。</p>
<p>不同于彻底的独裁治理模型，精英领导制实际上暗示着项目由多人共同治理，而加入治理机构的核心成员必须通过其贡献和工作方式赢得其他核心成员的认同。这种方式在 Linux 项目当中也被部分采用。虽然 Linus 仍然是名义上的独裁者，但是 <a href="https://www.kernel.org/doc/html/latest/process/maintainers.html">Linux 的维护者列表</a>早就突破了一千人。当然，他们并不享有和 Linus 一样的权利，但是他们获得对应职责的基础，也是对相应模块的贡献。</p>
<p>这样，我们就确定了项目所有权的分配方式，即完全通过贡献来衡量。衡量者是现有的核心成员。建立项目自然是最大的贡献之一，持续参与，软件重大改进，催化参与热情与质量，完善文档，代表共同体或项目发声，都是值得考虑的因素。</p>
<p>例如，PostgreSQL Core Team 现在和过去的成员做出的贡献在其 <a href="https://www.postgresql.org/community/contributors/">Contributor 页面</a>上展示。</p>
<table>
<thead>
<tr>
<th align="left">核心成员</th>
<th align="left">主要贡献</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Peter Eisentraut</td>
<td align="left">构建系统，软件移植，文档及其国际化，持续的代码贡献。</td>
</tr>
<tr>
<td align="left">Andres Freund</td>
<td align="left">JIT 机制，逻辑解码，数据复制，性能和可扩展性，修复 bug 和 review 补丁。</td>
</tr>
<tr>
<td align="left">Magnus Hagander</td>
<td align="left">完成向 Win32 系统的移植，鉴权机制，维护项目网站和基础设施。</td>
</tr>
<tr>
<td align="left">Jonathan Katz</td>
<td align="left">项目推广，版本发布新闻稿，维护网站，作为其他 PG 相关委员会成员的贡献。</td>
</tr>
<tr>
<td align="left">Tom Lane</td>
<td align="left">所有方面。其中包括评估缺陷和修复，性能改进，新功能落地。同时是优化器模块的责任人。</td>
</tr>
<tr>
<td align="left">Bruce Momjian</td>
<td align="left">维护项目 TODO 列表，处理补丁，代表项目在会议上发言。</td>
</tr>
<tr>
<td align="left">Dave Page</td>
<td align="left">pgAdmin 的作者，维护项目网站和基础设施，以及安装包。</td>
</tr>
<tr>
<td align="left">Josh Berkus</td>
<td align="left">项目推广，用户群组推广，性能测试，调优和文档撰写。</td>
</tr>
<tr>
<td align="left">Marc G. Fournier</td>
<td align="left">协调员，管理项目网站，邮件列表，文件服务器和代码仓库，等等。</td>
</tr>
<tr>
<td align="left">Thomas G. Lockhart</td>
<td align="left">文档撰写，实现数据类型尤其是时间类型和几何类型，SQL 标准适配。</td>
</tr>
<tr>
<td align="left">Vadim B. Mikheev</td>
<td align="left">重大功能实现，包括 WAL 和 MVCC 等功能。</td>
</tr>
<tr>
<td align="left">Jan Wieck</td>
<td align="left">数据复制系统 Slony 的作者，实现了一系列重大功能。</td>
</tr>
</tbody></table>
<p>可以看到，代码贡献是主轴，但也包括了维持项目运转和扩张的其他多层面的贡献。</p>
<p>精英领导制还有另一层含义，就是任何人都可以参与到技术讨论，技术实现和共同体决策当中来。虽然核心成员承担决策的职责，但是他们并不形成寡头政治。也就是说，核心成员的身份及其承担的职责是一种权力，而非特殊的权利。在一个健康的开源共同体当中，任何成员都可以做技术讨论，提交补丁，也可以就共同体发展话题提出自己的观点。技术最优的方案应当获胜，共同体利益最大化的决策应当通过。</p>
<p>精英领导制也并非是完美的。<a href="https://book.douban.com/subject/35586814/">《精英的傲慢》</a>一书当中提到，无论怎样强调“唯才是举”，精英的成功与天赋和运气等因素都是有关的。过分强调精英领导制，会助长赢得权威的人认为一切都是自己所应得的，对于没有赢得权威的人，则会感到屈辱和被排除在外。</p>
<p>《精英的傲慢》主要讨论的是社会问题，但是对于开源共同体这样一个特殊的群体，也是有启示的。我们前面强调了权力而非权利，即从根本上结构了共同体当中赢家与输家的关系。不过，不同身份的存在仍然有潜在的冲突风险，因此在选拔核心成员的时候，也要注重他对于权威的认知和个人的品质。</p>
<p>例如，<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>一书当中提到了谦逊的价值。</p>
<blockquote>
<p>谈吐柔和也是有用的，如果某人希望成为一个成功项目的维护者，他必须让社区信服他良好的判断力，因为维护者的主要工作是判断他人的代码。谁愿意将代码贡献给一个明显不能正确判断自己代码质量的人？或者一个试图从项目中沽名钓誉的人？潜在的贡献者希望项目领导人在客观采用他人代码时，能够谦逊而有风度地说：“是的，这个的确比我的代码好，就用这个了。”然后将荣誉给予应得之人。</p>
</blockquote>
<p>最后，由精英领导制建立起来的治理机构应当能够自省，以永远保持质量，代表开源共同体的前进方向。这不意味着要对每个成员限制任期，如果有人能把开源共同体治理得很好，应该允许他们一直干下去。但是，根据核心成员参与共同体各项活动的程度，工作情况的综合评价来判断是否应该取消某位成员的资格。</p>
<p>例如，PostgreSQL 共同体将在每年的 pgCon 峰会上发布新一年的 Committer 名单，不再活跃的成员将被移出。</p>
<h3 id="坦诚沟通"><a href="#坦诚沟通" class="headerlink" title="坦诚沟通"></a>坦诚沟通</h3><p>开源共同体要想高效运转，坦诚的沟通是必不可少的。</p>
<p>例如，前文提到的取消核心成员资格这样的决策，如果没有事前沟通，不仅当事人基本不可接受，而且其他成员将笼罩在无形监视的阴影下。例如，前文提到的 Rust 共同体 Moderation Team 和 Core Team 的冲突，没有任何关于细节内容的披露，每个人都在说那里有一些问题，是什么问题不方便说，谁牵扯其中不方便说，后续要如何处理不方便说。这样的表现只会让人对这两个治理机构都丧失信心，无法信任他们做出的决定是公平的。</p>
<p>坦诚沟通依赖相应的渠道。Apache 软件基金会要求所有讨论都发生在邮件列表上，因而是公开可追溯的。我在设计 Engula 共同体的沟通渠道时，根据项目的特点，把 Single Source of Truth 设置成 GitHub 平台，包括 issue 和 pull request 以及 discussion 论坛。所有其他渠道沟通的结果，都必须回到唯一的渠道上再次确认。通过这样的设计，能够支持全球性开源共同体的异步协作，并且保证所有信息都是公开的，也就消除了关于决策缘由的顾虑。</p>
<p>实行坦诚沟通的好处不必多说，绝大部分人都希望得到真实的信息，收获真实的反馈。真实的信息帮助共同体成员为最大化共同体利益努力，真实的反馈帮助共同体成员正确地行事。不过在设计治理模型的时候，关于沟通有两个点需要强调。</p>
<p>第一个是坦诚不代表攻击性。<a href="https://book.douban.com/subject/35102294/">《不拘一格》</a>一书中强调坦诚沟通的重要性，但也提示组织管理者需要警惕“有才华的混蛋”。</p>
<blockquote>
<p>如果周围全是聪明人，你可能就有危险了。有时候，有才华的人听到的赞美之词太多，就会觉得自己真的比其他人更优秀。如果有他们认为不明智的想法，他们可能会报以嘲笑；如果有人发言不够清晰，他们可能会翻白眼；他们还会侮辱那些他们认为天赋不如自己的人。换句话说，这些人就是浑蛋。</p>
<p>如果你在团队中倡导坦诚的文化氛围，就必须把这样的人剔除出去。许多人可能会认为“这个人确实很聪明，没有他不行”，但是，不管这样的人有多么出色，如果让他留在团队里，你营造坦诚氛围所付出的努力就不会有太好的效果。浑蛋对整个团队的效率有很大的影响，他们可能会将你的组织从内部撕裂。因为他们老是喜欢中伤同事，然后丢下一句：“我这是坦诚。”</p>
</blockquote>
<p>对于开源共同体而言，这就意味着需要切实践行行为准则（Code of Conduct），对这类攻击性行为说“不”。</p>
<p>额外多说一句，不少共同体从 GitHub 或者推崇的其他项目当中拷贝了行为准则，但是核心成员可能都不知道行为准则当中写了什么。这是不可接受的。我在撰写 Engula 共同体的参与者文档的时候强调了行为准则的重要性，并认为如果一个人想要成为核心成员，必须了解和实践行为准则。否则任何的文档不过是一纸空文。</p>
<p>第二个是必要的隐私渠道，包括安全问题报告、违反行为准则报告以及选拔成员讨论等等。安全问题不必多说。后面两者涉及到对人的评判，在得到合适的结论之前不应该全部披露。</p>
<p>这是因为，根据精英领导制的精神，唯才是举的评判应该来自于现有的核心成员团队，而不是民粹主义式的公投。一个开源项目会发展成什么样子，取决于核心成员是什么样的。他们是最有话语权的一群人，应该对项目抱有切身的责任感。如果核心成员团队被腐化了，或者他们本来就抱持着其他目的，那么这个项目就完蛋了。核心成员承担项目所有权，为项目的发展负责。如果其他成员认为核心成员违背了开源共同体的核心利益，标准做法是发起分支。</p>
<p>不过，决议的内容应该公示并向共同体成员解释原因。这就意味着秘密推举新的核心成员是不可接受的，同样，以莫须有的罪名惩罚共同体成员也是不可接受的。</p>
<h3 id="适应性"><a href="#适应性" class="headerlink" title="适应性"></a>适应性</h3><p>适应性体现的是“摈除丑陋的形式主义”的原则。也就是说，治理模型的设计应该倾向于适应开源共同体的发展，而不是做空中楼阁的设计。</p>
<p>大多数开源共同体需要应对三类问题，即综合治理，确定方向以及专业化治理。综合治理指的是围绕共同体的综合性话题做出决策，例如如何加入共同体，资源和基础设施的维护，工作流程，治理的改变等等。确定方向指的是围绕共同体的目标、愿景和当前焦点做出决策，例如开发软件所要解决的问题，目标用户，以及当前所要关注的特性集等等。专业化治理适用于开源共同体成长到一定规模以后，针对特定的专业知识领域需要专业的治理。例如，用户文档体积膨胀，而恰好有技术写作人才的参与。例如，Rust 的 Reddit 频道有自己的组织体系。例如，针对代码补丁的评审和缺陷的评估解决，也是专业化治理的一类。</p>
<p>对于一个刚起步的开源共同体来说，所有方向上的问题只需要一个治理机构来处理就够了。因为此时并没有太多的事情要处理，同时你也没有太多的成员能够参与到治理当中来。</p>
<p>不少设计开源共同体治理模型的人，盲目参考 Apache 软件基金会，或者 Kubernetes 等项目的玩法，货物崇拜式的对其治理模型进行像素级拷贝，最终发现并不适合自己项目的情况，而饱尝苦果。这其中最典型的就是引入多余的设计。预设具体的参与路径或治理细则，往往会导致无端的“运营成本”。随着项目的演进，参与情景的改变，预设前提不再生效，需要频繁修改，而并没有人实际践行。也就是说，所有设计和修改的付出都白费了。</p>
<p>《社区运营的艺术》提到，在理想的世界里我们不需要把治理放在首位，更不用说设置附加的分委会。每增加一层治理，你的社区就会丧失一些让大家易于理解的简单灵活性。只有在绝对必要时，你的社区才应设置附加的治理。</p>
<blockquote>
<p>只有当现有的治理机构不能扩展或满足社区需求时，附加的治理才是必须的。然而，有些社区不太明白这个道理，决意设计空洞的委员会：无非就是使新委员会的成员感到很特别。</p>
<p>…他们希望有一个治理委员会。在他们眼中，治理委员会能带来各种有趣的东西：对项目的控制感、权利和权力。不仅如此，他们认为一个社区之为社区，真正的社区委员会是必不可少的。</p>
<p>胡说。</p>
<p>此类委员会的成立根本没有理由。社区委员会的存在是为了解决问题，但是如果整个社区相对比较小，就没那么多问题需要解决。创建这个委员会，你实际上增加了官僚主义的风险。</p>
</blockquote>
<p>一个典型的例子就是单一项目阶段切分出许多模块团队，并为之建立起复杂的治理层级。我在此前讨论 TiDB 和 TiKV 的治理经验和教训的时候已经提到过，这种方式不过是割裂开源共同体而已。这种分割主要的缺点是很难切得恰到好处，出现问题讨论和修复带来的治理开销太大。如果不修订，实际情况一般是团队成员权限不足，核心团队不停兜底。</p>
<p>例如，早期 TiDB 将代码分成 DDL 和 Planner 还有 Execution 三个部分，那么数据库权限的问题谁来处理呢？一般性的并发实用函数，数据格式等等问题，谁来解呢？后来又把 DDL 团队泛化成 SQL Infra 团队以期兜底，但是实际上他们还是只处理部分问题。例如，TiDB 的 telemetry 模块目前就是无人负责的。</p>
<p>实际上，代码的关联是普遍存在的。哪怕是 Apache Flink 这样可以区分成 Runtime 和 DataStream API 以及 Flink SQL 的项目，也不需要单独区分出若干个团队来分散治理。Apache Hadoop 200 多名 Committer 完全依靠工作流程和负责任的态度，以相同的权力推进代码的演进。PostgreSQL 的 28 名 Committer 也没有再细分。</p>
<p>区分团队的项目，往往与不同的资源和关注点关联。例如，Apache 软件基金会下的每个项目都有自己的项目管理委员会，这其实就是某种意义上的团队区分，但是没人会觉得这增加了形式主义，因为不同的项目之前确实是不同的。</p>
<p>例如，Rust 共同体区分了若干个团队。虽然我对其中的 Release Team 保持怀疑，因为 PostgreSQL 可以很简单地由核心成员担任，ASF 项目通常也由志愿者根据发布手册担任特定版本的发布负责人，但是其他的团队区分是很清晰的。例如对于一门语言，编译器和标准库分开是没有问题的。中央资源库有独立的维护人员也是合理的，他们完全不需要关心编译器和标准库的问题。不过，我相信在真正出现这些团队独立的志愿者之前，也不需要分化出特定的团队。换句话说，因人设岗在开源共同体当中非常常见。同时，一个志愿者负责多项工作也是正常的，比如 Nick Cameron 就同时是编译器团队和开发工具团队的成员。</p>
<p>不要在没有人的时候首先架设出复杂的治理机构，因为没有人实际担任这些角色，空洞的治理体系是可笑的。同样，复杂的治理机构无法拯救空心化的开源共同体。比如，TiDB 有 60 余名 Committer 或 Maintainer 成员，但是真正处理 community 事务的人是不足的。前面提到的 Execution 团队的活跃成员全是 PingCAP 公司同一部门的员工，经过公司组织调整后工作重点改变，也就导致对应模块的治理立即缺失。空心化的开源共同体无法响应参与者，因为实质的有价值的回应来自于人与人的沟通，而非机械化的流程。</p>
<p>出于关注点不同的团队划分，还有一个值得考虑的问题是应当采用虚拟组织或者实际组织。Kubernetes 设计的 SIG 和 WG 就区分了这一点。SIG 作为实际与权限相关的团队，前面已经讨论过了。我在分析 TiDB 的治理模型的时候讨论过 WG 模型在 Kubernetes 共同体当中的采用情况。</p>
<blockquote>
<p>Kubernetes 社区的影响力和专注于社区运营的人数保证你的 WG 有人关注，有人推送，有人宣传，再不济任务结束或者生命终结可以回收。另外，Kubernetes 的 WG 都是非常 General 的，例如可靠性工作组，命名工作组，策略工作组，等等。TiDB 和 TiKV 对 WG 的理解基本停留在功能特性小组的层面。这种需求通过项目内的功能设计提案和 tracking issue 等形式发起和追踪即可。</p>
</blockquote>
<p>Rust 共同体当中也有同样的设计，例如最近 Nick Cameron 大力推进的异步编程工作组，这一工作需要协同编译器和标准库以及三方库等多方努力才能在 Rust 生态当中提供一个统一且高效的异步编程抽象和灵活适应不同负载的多种实现。</p>
<p><a href="https://github.com/engula/engula/discussions/245">Engula 共同体考虑未来发展</a>的时候，讨论了区分不同团队的思路。我在主题下回复的建议就是针对不同的模块关注点，可以尝试组织起不与权限挂钩的兴趣小组，针对特定的主题，可以组织起工作组。对于权限本身的区分，由于共同体规模并不大，适当扩充核心成员即 Maintainer 的人数达到复数即可。否则，在接口不稳定的情况下，跨越当下设定的模块的变更非常可能发生。另外，对于讨论中区分出来的日志、存储和计算引擎三个模块之外，部署逻辑、异步实用工具等等实际存在的功能又该归属到哪个团队呢？还是前面提到的，“切分主要的缺点是很难切得恰到好处，出现问题讨论和修复带来的治理开销太大。如果不修订，实际情况一般是团队成员权限不足，核心团队不停兜底”。</p>
<p>那么，什么时候应该考虑扩大治理机构的规模呢？这里提供几个方向性指标。</p>
<p>第一个是遇到瓶颈。</p>
<p>如果开源共同体当中的事务变多或变复杂，导致当前的核心成员团队无法处理，那么就有可能要考虑扩大治理机构规模。例如，Linux 的 1000 多名拥有部分提交权限的维护者，为 Linus 分担了大量与具体驱动或架构相关的模块的补丁审查。例如，C++ 委员会面临方向统合上的问题，于是成立方向委员会来应对。</p>
<p>不过，并非遇到的所有瓶颈都需要通过扩大治理机构来解决。比如，流程事务繁多可能是流程文档不足或者流程本身有形式主义的问题，通过改进流程或取消流程即可解决瓶颈。另外，PostgreSQL 绝大部分工作是由 7 名 Core Team 成员和 28 名 Committer 处理的，如果你的核心成员有同样的能力，那么可能也不需要刻意扩大规模。</p>
<p>我在参与 Engula 共同体的过程中也不断重复这一观点，即“如无必要，勿增实体”。如果当前项目创始人足以处理所有事务，那么就不需要形式主义地扩充成员，更不需要设计复杂的治理机构。大多数人认为治理既不酷也不有趣。我们的目的是，在保持想要达到的质量和客观性的同时，将治理的基础设施和文件的数量保持尽可能少。</p>
<p>第二个是关注点分离。</p>
<p>如果一个无关权限的兴趣小组或者工作组最终围绕特定领域形成了一个大的子共同体，这个子共同体可能需要一些特定的知识，而这些知识是核心成员所不知道的。这个时候，就可能需要把独立出这部分决策权。例如，Rust Team 有 Community 团队，Kubernetes 有 Community 团队，甚至你把整个 Linux 共同体视作一个整体，Linux Foundation 也是一个独立的团队。</p>
<p>关注点分离强调的是事后追认，也就是真的有分离的需求的时候，追认事实，而不是事先设计出空中楼阁式的团队，期待有人自告奋勇加入。这样做，最可能的结果是吸引到沽名钓誉的人工于心计地获得头衔。</p>
<p>另外，关注点分离也强调权限的独立。除非明确需要层级结构，例如 PostgreSQL 的 Core Team 对整个开源软件负责，因此它需要决策 Committer 团队的人员组成，否则你并不需要把所有的子共同体组织成一个层级结构，网络结构也是可行的。例如，Linux Foundation 实际上与 Linus 控制的开源软件共同体并没有层级关系。例如，StreamNative 公司建立的 Apache Pulsar 中文社区也不需要对 Apache Pulsar 的 PMC 负责。这种独立往往发生在分地区和语言成立的本地用户组上，或者围绕同一开源软件但是面向不同目标的群体之间。</p>
<p>总的来说，所有这些情况都超出了现有治理机构在时间、知识或技能方面的管理能力。事务的多少是判断是否扩大治理机构的正当理由。如果你只有少数几个特定领域的清楚，当前的核心成员努力一下就能处理完，那就不应该成立一个独立挂钩权限的团队。但是如果核心团队定期且重复地抽到一些请求，那么就有必要考虑成立新团队应对瓶颈了。当然，这不是唯一的解法。</p>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
  <entry>
    <title>《大教堂与集市》书评</title>
    <url>/2021/12/14/the-cathedral-and-the-bazaar/</url>
    <content><![CDATA[<p>历时五天，我总算把<a href="https://book.douban.com/subject/25881855/">《大教堂与集市》</a>这本经典的开源文化著作认真读了一遍，真是酣畅淋漓。</p>
<p>本书是作者 Eric S. Raymond 的文集，其中最著名的一篇就是《大教堂与集市》，其他几篇分别是《黑客圈简史》《开垦心智层》《魔法锅》和《黑客的反击》。最有价值的是《大教堂与集市》和《开垦心智层》两章，系统解释了开源软件是如何生产的，开源开发的优势在哪，开源软件的传承是如何做到的。《魔法锅》解答了一些常见的关于开源软件使用价值和销售价值的问题，但是受限于时代背景，对商业化的讨论局限在夸大使用价值的部分，不能很好的指导基于开源软件提供软件服务的商业模式。</p>
<p>在进入具体的内容讨论之前，必须着重提到译者卫剑钒对中译本创造的价值。翻译是对原内容的二次创作，软件开发领域外文著作众多，大部分译本都让原文表意有明显的损失。卫剑钒翻译的《大教堂与集市》，阮一峰翻译的<a href="https://book.douban.com/subject/6021440/">《黑客与画家》</a>，以及云风翻译的<a href="https://book.douban.com/subject/35006892/">《程序员修炼之道（第二版）》</a>是我近一年来读过的本领域最佳译作。</p>
<span id="more"></span>

<h2 id="开源协同的优势"><a href="#开源协同的优势" class="headerlink" title="开源协同的优势"></a>开源协同的优势</h2><p>《大教堂与集市》一章主要讲的就是开源协同的优势。集市模式就是开源协同的模式，本章的要点在于论证这种模式能够生产出高水平的软件，以至于超过任何商业公司闭门造车的软件。原文的论述重点在同行评审的价值，辅以拥有用户的重要性，落点在如何以集市模式领导开源项目。出于讨论流畅性的考虑，我把前两点的顺序调换然后展开。</p>
<h3 id="拥有用户"><a href="#拥有用户" class="headerlink" title="拥有用户"></a>拥有用户</h3><p>对于任何软件来说，获取用户都是一个艰难的生存挑战，持续的用户反馈能够帮助软件不断修正前进方向，没有用户也即意味着软件的死亡。开源软件能够在早期发展阶段吸引到足够的注意力和用户。</p>
<p>一种形式是如原文作者继承 popclient 项目，从而直接继承其用户群。这在商业公司开发的软件当中是不容易做到的，因为涉及到专有软件的所有权转移，总是非常的繁琐且挫败的。大部分商业公司开发的软件，一旦因为种种原因不再维护，往往无法为人所继承而是彻底死亡。</p>
<p>因此，如今的用户对全新的专有软件往往抱有很强的怀疑态度。例如，最近一段时间迸发出来的新兴数据库软件，如果我无法获得它的源码，那么我如何能够自由地探索它呢？成熟的闭源商业软件辅以用户手册或许没有这个烦恼，但是软件的更替是不可避免的，新兴软件刚出世时，往往欠缺文档，功能不全，只有阅读源码甚至加以修改才堪堪能用。这种情况下，开源软件不是比闭源软件更好的问题，而是只有开源软件才能生存下来的问题。</p>
<p>此外，围绕开源软件或软件群形成的开源共同体有内部共通的价值观。如果你制作了一个新的开源软件，在潜在的用户群组里发帖介绍自己是不会被排斥的，如果软件质量不错，还会得到用户的自发传播。例如，我在 GitHub DCO App 异常期间，顺手开发了一个基于 GitHub Actions 的方案并在原 issue 下<a href="https://github.com/probot/dco/issues/162#issuecomment-942926111">评论介绍自己的解决方案</a>。没有回复会认为这是恶意竞争，而是出于解决问题的群策群力。又例如，Engula 项目开发过程中，向 Rust Community 和其他相关主题的资深开源开发者均寻求过意见和建议，其中认可 Engula 项目价值的人，就会自发的传播它。这对于商业软件来说是不可想象的，如果上面的行为替换成一个闭源商业软件，则参与者会认为你是一个销售人员而不是黑客同行，并且对一个完全黑盒的全新解决方案兴趣寥寥。</p>
<p>最后，开源软件不会将自己的用户局限在销售关系以内，这往往能保证软件开发者有更强的主导能力，按照符合软件工程的方式开发高质量软件，而不是在需求爆发的压力下将软件绑定在单一用户的需求上。</p>
<h3 id="同行评审"><a href="#同行评审" class="headerlink" title="同行评审"></a>同行评审</h3><p>同行评审是原文论述的重点，实际上，集市模式的核心价值就在于跨越组织边界的独立的同行评审验证设计和保证正确性。原文将其称为“Linus 定律”，即</p>
<blockquote>
<p>如果有足够多的 beta 测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。</p>
</blockquote>
<p>不过针对这个定律有两点需要解释。</p>
<p>第一点是它所强调的是独立的同行评审实施的简单性和有效性，而不是单纯的“人多力量大”。</p>
<p>开源开发的价值之一就是源代码公开使得任何人都可以分析代码逻辑以定位问题。时至今日，传统的研发组织仍然把开发人员和测试人员区分成两个竖井，测试人员几乎只能完成黑盒测试。可想而知，缺乏分析的现象型 bug 报告往往需要耗费开发人员相当多的时间重新验证、复现和定位。如果让对源代码一无所知的测试人员为 bug 定级，则两类人员之间的冲突会更加尖锐。</p>
<p>开源开发打破了这种困境。由于大家都有真实的源码，开发者和测试者很容易发展出一个共享的表达模式并进行有效的交流。一个现象型 bug 报告和一个直接关联到源码的分析型bug报告，对开发者解决问题的帮助简直是天壤之别。Linus 定律建立在开源开发的基础上，强调的是拥有源码以后加入新的眼睛的成本不在包含商业公司管控带来的限制和摩擦，从而能够从基数足够大的同行评审当中获取高价值的报告。</p>
<p>原文引用<a href="https://book.douban.com/subject/26358448/">《人月神话》</a>的 Brook 定律，提到随着开发人员数目的增长，项目复杂度和沟通成本按人数的平方增加，而工作成果只会呈线性增长。对于这个论点，原文作者是认同的。但是，开源项目所采用的沟通方式，区分成少部分核心开发人员与由 beta 测试者和潜在的贡献者组成的外围人员。外围开发者实际工作在分散而并行的子任务上，他们之间几乎不交流；代码修改和bug报告都会流向核心团队，只有在那个小的核心团队里才会有 Brooks 开销。</p>
<p>这揭示了开源开发的精英领导制内核，也解释了 Linus 定律虽然常被简化成“只要眼睛多，bug 容易捉”，但是却不是简单的“人多力量大”。</p>
<p>第二点是开源软件当中出现 bug 是正常的。这一点过于天经地义以至于当我发现我需要强调它的时候有些震惊。近年来出现的“心脏滴血”和前几天的 Log4Shell 漏洞，导致部分声音认为开源项目的使用是有风险的。</p>
<p>对此，我只能说，这当然啊！软件有 bug 不是正常的事儿么？开源开发不是银弹，任何复杂的软件都会有 bug 存在。Linus 定律成立的案例 Linux 是在高速发展的过程中保持了相对稳定的质量，而不是从来没有 bug 出现。如果你认为开源软件有不可承受的风险，最佳做法是参与其中对它做出改良。</p>
<p>此外，开源软件的许可证往往附带了免责声明，也即这个软件的源代码就这样（AS IS）给你了，没有任何保证（WITHOUT WARRANTIES）。在应用当中整合开源软件之后，保证应用的正确运行与安全性是应用开发者的责任。开源软件会因为安全问题损失声誉，因此作者会尽力提高安全性和正确性，并辅以相应的测试验证，但是这些都是尽力而为，没有保证。</p>
<h3 id="集市模式"><a href="#集市模式" class="headerlink" title="集市模式"></a>集市模式</h3><p>《大教堂与集市》一章的落点在如何以集市模式领导开源项目，这种模式相较传统的管理架构有何不同。</p>
<p>其中很多原则和技巧不是开源特有的，并通过敏捷等理念渗透到商业公司的软件开发当中。例如，“好的软件作品，往往源自开发者的个人需要”，“早发布，常发布，倾听用户的反馈”，以及“想出好主意是好事，从你的用户那里发现好主意也是好事”等等。</p>
<p>其中最重要的一点是关于发布的。开发者在需求列表不能调整和最后期限不能拖延的双重要求下，会完全顾不上质量，整个工作很可能会变成一团乱麻。Linux 通过发布两种不同类型的版本，各自宽松其中一个要求来保证软件质量和进度的协调。</p>
<blockquote>
<p>一种办法是保持最后期限不变而让需求列表灵活一些，允许某些到最后期限时仍未完成的需求被舍弃，这基本上就是“稳定版”核心采取的策略。 Alan Cox（稳定版核心的维护人）以相当规律的时间间隔将核心发布，但并不保证某个特定bug何时被修复，也不保证实验版中的某个特性何时会搬到稳定版中。</p>
<p>另一个办法是设定好想要的需求列表，并在其完成时发布，这基本上是“实验版”核心的策略。 De Marco 和 Lister 引用研究结果，指出这个进度策略即是“好了告诉我”，这不仅能够保证最高质量，而且就平均而言，与“保守”或“激进”的进度安排相比，它的交付时间更短。</p>
</blockquote>
<p>对于与传统的管理架构比较的部分，其理论基础可以参考<a href="https://book.douban.com/subject/26894636">《开放式组织》</a>与<a href="https://book.douban.com/subject/27125968/">《企业的人性面》</a>相关的论述。概括地说，开源的方式给予开发者足够的自由，以吸引高水平的黑客自发地创造价值。这种超越了对安全需要乃至生理需要的追求的模式，激发的是参与者对社会需要和自我实现需要的热忱。</p>
<p>在这里，没有预设的团队和资源，不需要在办公室环境下吞并其他团队的资源或者对其他团队的进攻做出防守。开源开发者是志愿者，是因为兴趣和能力自主选择的，他们会把自己的资源带到工作中，而不需要关心团队之间的领土争端和倾轧。</p>
<p>在这里，参与者凭借其创造的价值赢得权威。也就是说，最有才华的人能够对项目的发展做出最合适的决定。这不同于雇佣关系下被强制调配的人与项目之间的关系，而是对于特定的人，自由选择适合自己的项目，对于特定的项目，自然筛选出最合适的人。</p>
<p>原文还提到一种观点，即传统开发管理能保证艰苦和乏味的工作总能落实。我想这点毫无疑问是错误的。Linux 和 Kubernetes 的文档充足到令人难以置信，反过来只为了领工资才上班的人往往消极对抗撰写文档和测试或调试问题等工作。</p>
<p>开源共同体的目的是制造高质量的软件，在这个共同目标的引领下，不同方面的人才聚拢起来发挥自己的价值，反而是能够找到对传统开发管理认为艰苦和乏味的工作甘之如饴的人才。对于项目维护者来说，认识到这些所谓“无聊”部分的价值，协同参与者完成它们，是项目能够脱颖而出的必要条件。经过二十年来的经验积累，这逐渐成为最有才华的黑客当中的共识。</p>
<p>最后，对于想要实行集市模式的人，这里转述原文提到的“集市模式的必要条件”。</p>
<p>集市从成立伊始，就需要一个可以运行和测试的东西。当开始建设开源共同体的时候，你需要拿出一个像样的承诺。程序此时并不需要特别好，它可以简陋、有错、不完整，文档可以少得可怜。但它至少要做到能运行，且让潜在的合作开发者相信，这个软件在可预见的未来，能演变成一个非常棒的东西。</p>
<p>项目领导人需要能识别出别人的优秀创意，掌握一定水准的设计和编码能力，并且必须具备很好的人际交往和沟通能力。最后一点应该是显而易见的，为了建立一个开源开发共同体，你需要吸引人们，让他们对你做的事感兴趣，让他们乐于看到自己的贡献。一些技巧可能有助于实现这些，但远远不是全部，你的人格特征也很重要。</p>
<h2 id="开源软件的传承"><a href="#开源软件的传承" class="headerlink" title="开源软件的传承"></a>开源软件的传承</h2><p>《开垦心智层》一章讨论开源共同体的发展，以及发展过程中开源软件的所有权及转让的问题。</p>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>原文提到，开源软件的所有权获取有三种形式。</p>
<blockquote>
<p>第一种也是最显然的，就是去创建这个项目，当这个项目在开始时就只有一个维护者而且这个维护者仍然起作用的时候，所有权问题是连提都不该提的。</p>
<p>第二种方式是获取前任对所有权的移交（有点像“接力棒传递”）。这在社区中很容易理解，当项目“所有者”不愿意或者不能在开发和维护中投入必要的时间时，他（她）有义务将项目移交给一个有能力的继任者。</p>
<p>第三种方式是一个项目需要维护但项目所有者已经消失或失去兴趣了。如果你想维护该项目，你的责任是努力找到这个“所有者”，如果找不到，你可以在相关场所（比如 Usenet上专注于该应用领域的新闻组）声明该项目似乎是一个“孤儿”，而你想为之负责。</p>
</blockquote>
<p>我在协助处理 TiDB 里两个合并子项目的工作的时候，实质上就遵循了这里的原则。原来的项目由多名 contributor 参与完成，在当时的 CLA 设置下，要求每位 contributor 都必须和 TiDB 项目签 CLA 才能合并。比起强硬的改变 commit author 绕过 CLA 检查，我建议尝试联系未签署 CLA 的参与者补上。这些参与者被 at 以后很快响应并且解决了问题。</p>
<p>其实参与开源开发的人不是坏人，在项目没有发展出多样性之前，不要擅自以“内部”“外部”这种二元视角界定参与者的属性，也不要假设“外部”是邪恶的。</p>
<h3 id="分化"><a href="#分化" class="headerlink" title="分化"></a>分化</h3><p>原文将分化行为列为开源文化当中的禁忌。分化指的是派生出一个随后不能交换代码的竞争项目，并导致开发者群体的分裂。</p>
<blockquote>
<p>黑客厌恶项目分化的另一个原因是，他们惋惜那些被浪费的重复工作分化后的两个子项目总是有着或多或少平行的演化路线。他们也会注意到分支倾向于分裂合作开发者社区，使得两个子项目的人手都比父项目的人手更少。</p>
</blockquote>
<p>近年来雨后春笋般冒出来的开源项目，在分支和合作问题上起码有两点值得关注。</p>
<p>第一点是对合作的漠视。相当部分项目，号称开源，实则核心成员还是都来自同一个公司团队，规模往往超不出十几人。他们有很强的领地意识，拒绝其他人的参与，或者将其他人的贡献打包进项目整体说成都是该公司的贡献。这样做，使得不同组织的参与者失去动力甚至有种被驱逐出去的意味，实质上只是源码可得的传统项目开发模式。</p>
<p>当然，也有好的案例，且大多来自公司背景不强的项目。例如 <a href="https://github.com/InterestingLab/seatunnel">SeaTunnel</a> 还叫 WaterDrop 的时候，就吸引了不同组织成员的关注和参与，现在又被 Apache 成员关注到，合作进入 Apache 孵化器孵化。</p>
<p>第二点是对分支的痴迷。也就是公司喜欢 fork 出来搞个魔改版本，从不考虑 contributing back 还以为自己占了便宜。且不说这种行为禁锢了原本可以参与共同体的成员，代码分化带来的兼容性问题魔改版本从来不能解决。回过头来把魔改版本抛头换面又煞有介事的“开源”，应该被整个黑客社会所唾弃。</p>
<p>如果说还有一点，那就是那些所谓的“开源技术公司”，如果试图对开源共同体实施某种形式的管控，让商业公司凌驾于志愿者之上，那么这样的项目实际上更容易分化。Elastic 和 <a href="https://github.com/opensearch-project/OpenSearch">OpenSearch</a> 就是一个典型的例子。</p>
<blockquote>
<p>对于相对开放的民主制度而言，它的一个主要优势在于，绝大多数潜在的革命者发现通过在系统中工作比攻击该系统更容易让自己向目标前进。但如果既有政党联合起来“提高门槛”，导致那些较小的不满意团体觉得更难实现自己目标的话，这种优势就很容易被侵蚀破坏。</p>
<p>准入门槛不高的开放过程鼓励参与而非分裂，因为参与者能从中获得成果，而不用付出分裂所需的高昂成本。尽管这种成果可能不像分裂所得成果那样令人印象深刻，但其成本较低，且大多数人都能接受这种折衷。</p>
</blockquote>
<h3 id="冲突与解决"><a href="#冲突与解决" class="headerlink" title="冲突与解决"></a>冲突与解决</h3><p>原文提到，项目当中的冲突与解决主要围绕三个问题展开</p>
<ol>
<li>谁来负责做设计决策？</li>
<li>如何决定哪个贡献者应该被授予荣誉，如何授予？</li>
<li>如何保持项目团队和产品不被分裂为多个分支？</li>
</ol>
<p>第一个问题由上述所有权问题回答。关于分支的问题在上一节已经讨论过了。现在看第二个问题。</p>
<p>无论采用独裁者模型还是委员会模型，黑客的荣誉都跟他创造的价值相关。也就是说，黑客的声誉在礼物文化的大背景下，由他的贡献即赠与开源共同体的礼物的价值所决定。对于独裁者模型来说，独裁者本人需要能够践行这样的规则，否则高水平的参与者就会选择离开。对于委员会模型来说，还有一个额外的问题是委员会自身应该避免冲突。原文质疑委员会模型难以避免冲突</p>
<blockquote>
<p>在这种形式中，我们很难看到内部边界，并因此很难避免冲突，除非委员会内部享有极高水平的和谐与信任。</p>
</blockquote>
<p>但是，今天的软件复杂度越来越不支持独裁者模式。如果独裁者本人已经把部分决策权交给参与者，那么他在运行上就类似于委员会的模式。即使独裁者名义上拥有最终决定权，他与维护某一模块的核心成员仍然需要保持高水平的信任以减少项目当中的摩擦。</p>
<p>结合如今一部分商业公司创建或大规模参与开源项目的背景，如果项目建立的是同侪共同体（community of peers），也就是说成员的角色与个体相关，而不是与他在某个组织的职位相关，在这种情况下依然把委员会的人员增加与企业员工入离职挂钩，这种组织形式就是非常危险的。</p>
<p>具体地说，部分项目照猫画虎地搬来了 Apache 软件基金会式的同侪共同体设计，在决定项目 PMC 成员和 committer 人选时，却变成了公司同事入职，“理应”有 commit 权限，就稀里糊涂的成了什么 committer 或 PMC 成员。一旦离职，则完全不理会项目的发展，甚至出于不愉快恶意捣乱项目的日常事务。这就是没有基于项目的需要和个体对项目的认可和贡献选择委员会成员的弊病。</p>
<p>这是说缺乏多样性的项目中，单一公司的员工需要避嫌吗？当然不是。实际上，成为大力投资该项目的公司的雇员，能够尽可能多的时间投入到项目发展上，公司的员工确实有更大的可能性成为核心成员。但是必须注意的是他的推举应该是客观的，基于项目的需要和个体对项目的认可和贡献来选择。只有这样，才能努力做到委员会内部有极高水平的和谐与信任，这才是这种组织形式下项目长久发展的根基。</p>
<h2 id="开源与商业模式"><a href="#开源与商业模式" class="headerlink" title="开源与商业模式"></a>开源与商业模式</h2><p>《魔法锅》一章的主题是开源与商业模式，着重讨论了反公地模型，软件的使用价值和销售价值，以及当时存在的开源相关的商业模式。</p>
<h3 id="反公地模型"><a href="#反公地模型" class="headerlink" title="反公地模型"></a>反公地模型</h3><p>我曾多次听到有人拿“公地悲剧”来类比开源协同的开发模式，认为后者也会如前者一样失败。</p>
<p>所谓的公地悲剧，指的是假设一个村庄里的所有人都可以不受限制地在一片公共的草地上放牧，如果没有一个共识来抑制过度放牧，出于自身利益的考虑，每个人都会尽可能多的放牧，以期在公地资源耗尽之前从中获取最大价值。</p>
<p>但是，Linux 项目持续三十年，长寿的开源项目比比皆是，这种类比显然是有谬误的。原文从公地悲剧两个必要条件来反驳，一是过度使用，二是供应不足。</p>
<p>公地悲剧的一个必要条件是所有人都放牧会使得草地退化，但是开源软件一旦制造出来，不会因为被过度使用而损失价值。反过来，广泛的使用会提升开源软件带来的价值。这一点很好理解。</p>
<p>公地悲剧的另一个必要条件是没有人会修缮草地，因为公地奖励“搭便车”行为，即你修缮了草地别人就可以无偿分享你的成果，而你的付出别人并不承担，结果是付出比不上被分摊后的收益，于是所有人都不付出。</p>
<p>在开源开发中不会遇到这种情况。这是因为参与者不仅需要解决方案，他们还需要问题被及时解决。因此解决这个问题本身带来的收益就足够偿还成本，而等待别人解决问题则完全无法预期它会在何时被解决。</p>
<p>这部分解释了解决方案必然会被生产出来的问题，但是其创造者为何会无偿发布这个补丁，还需要进一步的讨论。</p>
<p>一方面，很多情况下开发者无法为其确定一个公允的市场价格。另一方面，坐等在补丁上不会有任何收益，反而会带来额外的成本，因为你现在要在上游发布新版本时重复合并这个补丁。由于上游对该补丁的存在并不知晓，这种重复合并甚至有可能是多次重做。毫无疑问，这是非常挫败的。由此看来，只要你需要上游的更新，无偿发布补丁就是最优策略。</p>
<p>但是，这里还有一个问题，如果补丁有足够的差异性，补丁作者为什么不将其闭源以获取其销售价值？对于 GPL 许可的项目来说，项目本身的演化需要与其他各方分享，这不是个问题。但是软件结合的形式有很多，GPL 对软件即服务等方式难以产生约束，还有以其他宽容开源协议如 APL 等许可的项目，这些情形正是当下开源与商业的讨论焦点。</p>
<h3 id="软件的使用价值和销售价值"><a href="#软件的使用价值和销售价值" class="headerlink" title="软件的使用价值和销售价值"></a>软件的使用价值和销售价值</h3><p>在讨论这个焦点之前，我们先看看软件的使用价值和销售价值。</p>
<p>软件的使用价值是它作为一个工具的经济价值，软件的销售价值是它作为一个可买卖商品的价值。大部分软件是作为内部系统被生产出来的，原文认为，这个比例达到九成以上。开发者的薪资实际是出于维护软件的使用价值的目的支付的。</p>
<p>如果你创造的软件主要用于内部系统，而你的薪资也来自于维护它的使用价值，那么通过闭源来保护销售价值是没有意义的，因为你不会将它用于销售。这种情况下，通过开源协同来提高软件本身的开发效率和质量，就是有收益的。</p>
<p>值得注意的是，只要软件的开发在隶属于不同组织的参与者之间共享工作流，采用开源协同的开发方式就没有额外的成本，因为公司为了用上这个软件，总是要付出开发成本的。这个共享工作流的前提条件也是《魔法锅》一文成书时未曾想到的，居然还有人为了形式开源而给同一套代码区分出两套工作流。</p>
<p>原文提到两个常见的反论意见。一个是通过闭源代码保护商业机密。这是无稽之谈，主要是代码设计糟糕。通常来说，你应该将机制开源，编写通用的逻辑，而将商业知识相关的策略单独实现。当然，后者并没有什么开源的必要。</p>
<p>另一个是说闭源能够保护软件安全。这也是谬论。除了上面商业机密泄露的场景，对于纯粹的骇客攻击行为，二进制照样能被破解，开放源码只是多了一种破解的手段。</p>
<p>类似近几天的 Log4Shell 漏洞，难道黑客不读代码就找不到这个问题了吗？如果公司内重新实现日志框架，且不说要达到 log4j2 的水平要付出多大成本，以及生态兼容性的种种问题，难道重新实现的软件就没有其他安全问题吗？</p>
<p>即使不说分析源码的破解手段并不比破解二进制的手段轻松多少，可靠的安全性也依赖于算法及其事先经过彻底的同行评审。这么看来，开源软件反而更容易修复安全问题。Log4Shell 通过同行评审发现后通过必要的 private 邮件列表上报，在上游修复后进行披露，正是这种安全同盟的一般做法。</p>
<h3 id="直接收费的问题"><a href="#直接收费的问题" class="headerlink" title="直接收费的问题"></a>直接收费的问题</h3><p>当然，上面这些讨论仍然没有覆盖当前这波开源浪潮下新出现的商业公司群体，这些公司创造开源软件，并希望基于它们创造的开源软件获利。</p>
<p>原文对直接收费类型的许可证做出了批驳，指出希望在源代码可得的前提下添加某种收费或变相收费的条款，会遭到黑客的反感，从而失去开源共同体的支持。这是因为这类许可证违背了三个开源共同体的共识。</p>
<p>第一个与对等性有关。大多数开源开发者并不反对别人利用他们的礼物获利，只是不能要求有任何人站在一个特权地位上牟利。MongoDB 的 SSPL 在理念上或许沿袭了 GPL 的一些理念，只是它对形成派生作品的描述“形成服务”太过笼统，得不到广泛的支持。但是 MongoDB Inc. 自己并没有按照 SSPL 的要求开放它的整个服务栈的源代码，这种对等性的破坏遭到了黑客的唾弃。实际上，MongoDB 的核心代码几乎只由其公司雇佣的员工开发和评审。</p>
<p>第二个与非有意后果有关。原文提到，对商业使用或销售进行限制并收费的许可证有着令人扫兴的效果。特别是这条规定给某些分发行为笼上了一层法律阴影，而这些活动正是黑客非常愿意鼓励的事。还是 SSPL 的例子，由于“形成服务”太过笼统，几乎所有黑客都倾向于不分发该软件以避免潜在的法律风险。原文认为，黑客很少在这一点上让步。实际上，这也是 OSI 拒绝承认 SSPL 是开源许可证的主要原因。</p>
<p>第三个与保持礼物文化相关，这也是最关键的一个原因。如果许可证在法律上就禁止产生分支，那么黑客们绝对不会认同这样的条款。原文解释到，虽然黑客们不赞成分支，但是分支是“最后一招”。如果维护者不能胜任或者背叛开源文化，可以通过分支来保护礼物的传递。Elastic 与 OpenSearch 就是活生生的例子，以 AWS 的工程师为首的开发者在 Elastic 转向更加封闭的时候基于开源版本分支并独立发展，保持新分支的开源属性。</p>
<h3 id="开源的商业未来"><a href="#开源的商业未来" class="headerlink" title="开源的商业未来"></a>开源的商业未来</h3><p>《魔法锅》随后介绍了当时作者所看到的的若干种基于开源软件的商业模式。这里不需要展开，因为它们都统一在同一个模型下。这个模型就是基础架构和中间件开放，应用和服务收费的模型。</p>
<p>开源基础架构，并利用同行评审的价值，协同跨越组织的参与者创造出类别杀手，做到这点的收益实在太大了。类别杀手指的是即好到没人再想使用其他备选的高质量开源原创项目，例如 Linux 和 Kubernetes 等。</p>
<p>Google 愿意开放 Kubernetes 的源代码，很大一部分原因就是为了联合其他商业公司以及整个开源共同体形成事实标准的垄断，而要做到这一点，开源协同的方式是最高效的。Kubernetes 形成垄断后，越是早期参与项目的组织，越是投入资源大的组织，越能够获得某种程度上的原厂品牌效应，并积累足以应付软件在使用上的种种问题的开发者团队。这些组织通过提供应用级别的定制和维护服务收取报酬。</p>
<p>原文认为应用非常倾向于继续封闭，这种封闭尤其可能出现在自成一体的垂直市场当中，其网络效应也较弱。这其实就是针对特定场景开发的插件或者是针对具体业务接入基础架构的实施。时过境迁，如今的软件复杂度已经不是当年一个全栈工程师从购买服务器到整个网站都能负责开发的年代，雇佣业务实施团队将越来越常见。</p>
<p>这些插件某种意义上也可以算作中间件。实际上，应用和中间件之间的差别会随着时代的发展而变化。原文认为数据库是中间件，但是如今却更被认为是某种基础软件。中间件走向闭源还是开源，取决于软件失效的代价，代价越高，走向开放的市场的压力就越大。</p>
<p>举个例子，AWS 的不少服务是闭源的，但是它们的客户端是开源的。这些客户端就是中间件，如果它们的维护更封闭，那么失效的可能性就会越高。广泛的用户会倾向于使用开源的替代品。一个案例是 AWS S3 的 Rust 客户端 rusoto 和官方后来提供开源版本。</p>
<p>Confluent 依靠提供 Apache Kafka 的服务盈利，整个商业模型包括三个部分。</p>
<p>第一部分是实施，也就是帮助客户业务与 Apache Kafka 对接，乃至于设计整个业务消息平台。这是传统上所说的“外包”工作，由于软件复杂度日益升高，这类工作所需的软件开发技能也越来越丰富，相应的雇佣薪资也就水涨船高。这种模式也被称为订阅，在一个订阅周期内，客户能够获得实施工程师的支持，商业公司在提供工单响应的保障。实施包括支持私有化部署，也包括帮助客户对接云服务。</p>
<p>第二部分是提供基于开源软件的云服务，也就是云上的 Apache Kafka 资源，客户按照使用的节点数或访问量交费，这种模式实际上是商业公司通过出租商业地产盈利。一方面，CPU 和内存等资源本身是成本，用户无论如何也要为这些成本付费。另一方面，商业公司在资源之上提供了消息平台的抽象，屏蔽了部署和运维软件的复杂度，并以此来赚取差价。对于无力自行维护的企业来说，购买云服务就是最优选择。</p>
<p>值得一提的是，这种部署的附加值是工程师水平和硬件成本的函数，云厂商往往能够获取更廉价的硬件成本，因此独立服务提供商最好追求部署和运维本身的开销下降，这种运维和部署的策略是商业机密和盈利的基础。另一方面，可以通过维持云中立，避免供应商锁定等优势，利用云厂商之间的竞争激发用户的优先选择意愿。</p>
<p>第三部分是专有软件，例如 ksqlDB 等。只不过 ksqlDB 的位置更像是接近基础架构的中间件，被 Apache Flink 和 Materialize 等项目挤压了不少生存空间。反观 Apache Pulsar 和 Apache RocketMQ 就没有将类似功能做成专有软件以期销售，避免被其他项目分化用户。</p>
<p>对于哪些软件不适合通过闭源获取商业价值，《魔法锅》一文介绍了应该考虑开放源码的软件，时至今日仍然是正确的</p>
<ol>
<li>可靠性、稳定性、可扩展性非常重要。</li>
<li>除了独立的同行评审，没有其他便捷易行的方法验证设计和实现的正确性。</li>
<li>该软件对客户的业务非常关键，因此客户期望避免供应商锁定。</li>
<li>该类软件受网络效应主导，即你无法实现压倒性的市场控制力。</li>
<li>关键方法属于公共知识。</li>
</ol>
<p>开源与闭源在几乎所有层面上都是并存的，并且呈现出一种动态发展的趋势。</p>
<p>起初，Windows 垄断了操作系统的市场。当 Linux 出现以后，服务端操作系统的份额开始逆转，并且出现 RedHat 等商业公司。原文称为中间件的数据库，起初被 Oracle 主宰，如今它也承受着 PostgreSQL 的冲击，海量提供 PostgreSQL 服务的商业公司也能生存下来。今天，云原生技术和软件即服务的概念改变了软件生产和使用的格局，越来越多的商业公司创造开源软件或参与到其开发当中，目的就是推出下一个类别杀手，并取得之后的软件服务战争的优势。</p>
<p>实际上，最好的商业价值获取方式仍然依赖创造性的垄断，这也是知名商业著作<a href="https://book.douban.com/subject/26297606/">《从 0 到 1》</a>的观点。只不过，软件的复杂度以及开源开发应对这种复杂度在生产力上的显著优势，使得你无法在一个很大的范围内实现垄断。但是你仍然可以找到合适的垂直领域，或者就是为客户做实施——这也许是最垂直的一种方式了。</p>
<p>如今，想要创造局部垄断的一种新方式，是通过开源协同的集市模式创造出一个类别杀手，在此过程中获得某种程度上的原厂品牌效应，并积累足以应付软件在使用上的种种问题的开发者团队。进一步的，将原本的市场格局改变，在不改变固有需求的情况下改变产生商业价值的位置。以操作系统为例，原本商业公司以创造出商业操作系统为竞争优势，Linux 出现后，如何基于 Linux 提供更好的服务，或者看到 RedHat 如今的上云策略，提供海量 Linux 服务器资源的运维和应用的部署服务。</p>
<p>改变不利于自己的商业格局，并在环境有利于自己的时候做好下一次颠覆的准备，才是开源时代的商业未来。我也相信这种形式，能够促使企业家真正成为创新的先锋，而不是被长时间垄断所麻痹，不思进取乃至阻止社会生产力的进步。</p>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>大图书馆</tag>
        <tag>开源协同</tag>
      </tags>
  </entry>
</search>
